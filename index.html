<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>PhoenixAve</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="PhoenixAve">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="PhoenixAve">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PhoenixAve">
  
    <link rel="alternative" href="/atom.xml" title="PhoenixAve" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  <link rel="stylesheet" type="text/css" href="/./main.2d7529.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/head.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">PhoenixAve</a></h1>
		</hgroup>
		
		<p class="header-subtitle">只要相信，期待就会成真</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">PhoenixAve</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>只要相信，期待就会成真<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/随笔/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-Framework/Vue/vuex核心概念" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/06/Framework/Vue/vuex核心概念/">vuex核心概念</a>
    </h1>
  

        
        <a href="/2017/04/06/Framework/Vue/vuex核心概念/" class="archive-article-date">
  	<time datetime="2017-04-06T09:04:19.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-04-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<blockquote>
<p>这几天一直在学习vuex的使用，自己也做了一个小Demo，基本算是会用了，现在就把如何使用vuex整理一下，方便理解以及以后的使用方便，本文需要有一定的 <code>ES6</code> 的基础，比如结构赋值，箭头函数等，如果你不懂这些的话，建议先去看看<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰的ECMAScript 6 入门</a></p>
</blockquote>
<p>vuex的使用有两种方式</p>
<ul>
<li>局部使用</li>
<li>全局注册<br>局部注册需要在每个组建中注册，比较麻烦，因此推荐使用全局注册的方式，如果想学习局部注册，请看<a href="https://vuex.vuejs.org/zh-cn/getting-started.html" target="_blank" rel="external">vuex官方文档</a></li>
</ul>
<h2 id="State-保存状态的属性"><a href="#State-保存状态的属性" class="headerlink" title="State 保存状态的属性"></a>State 保存状态的属性</h2><h3 id="在-Vue-组件中获得-Vuex-状态"><a href="#在-Vue-组件中获得-Vuex-状态" class="headerlink" title="在 Vue 组件中获得 Vuex 状态"></a>在 Vue 组件中获得 Vuex 状态</h3><p>由于 Vuex 的状态存储是响应式的，从 <code>store</code> 实例中读取状态最简单的方法就是在计算属性中返回某个状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line">Vue.use(Vuex)</div><div class="line"></div><div class="line"><span class="comment">// 全局vue组件</span></div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件，且子组件能通过 this.$store 访问到</span></div><div class="line">  store,</div><div class="line">  <span class="attr">components</span>: &#123; Counter &#125;,</div><div class="line">  <span class="attr">template</span>: <span class="string">`</span></div><div class="line">    &lt;div class="app"&gt;</div><div class="line">      &lt;counter&gt;&lt;/counter&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>通过在根实例中注册 <code>store</code> 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到。让我们更新下 <code>Counter</code> 的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 子组件Counter</span></div><div class="line"><span class="keyword">const</span> Counter = &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    count () &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count  <span class="comment">// 通过 this.$store 访问store中存储的内容</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>每次都使用 <code>this.$store.state</code> 获取状态是不是很麻烦呢，所以官方给我们提供了 <code>mapState</code> 辅助函数，由于该函数返回的是一个对象，而计算属性 <code>computed</code> 也是一个对象，因此可以直接将函数的返回值赋给计算属性 <code>computed</code>，所以才有了以下的写法</p>
<blockquote>
<p>使用 <code>mapState</code> 时， <code>mapState</code> 内部的函数会接收一个 <code>state</code> 参数，在函数中可以直接通过 <code>state</code> 去访问store.state的中的属性</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></div><div class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  computed: mapState(&#123;</div><div class="line">    <span class="comment">// 箭头函数可使代码更简练，但是修改了this指向</span></div><div class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</div><div class="line"></div><div class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></div><div class="line">    countAlias: <span class="string">'count'</span>, <span class="comment">//暂时还没明白是什么意思</span></div><div class="line"></div><div class="line">    <span class="comment">// 为了能够使用 `this` 获取局部组件的状态，必须使用常规函数</span></div><div class="line">    countPlusLocalState (state) &#123;</div><div class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>mapState</code> 映射的计算属性的名称与 <code>state</code> 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串<strong>数组</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">computed: mapState([</div><div class="line">  <span class="comment">// 映射 this.count 为 this.$store.state.count，可以直接使用this.count，代替</span></div><div class="line">  <span class="string">'count'</span></div><div class="line">])</div></pre></td></tr></table></figure>
<p>当我们需要编写自己的计算属性时，上面的写法就不能满足了，因此可以使用<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="external">对象展开运算符</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></div><div class="line">  ...mapState(&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Getters-比作-store-的计算属性"><a href="#Getters-比作-store-的计算属性" class="headerlink" title="Getters 比作 store 的计算属性"></a>Getters 比作 store 的计算属性</h2><p>有时候我们需要对 <code>store</code> 中的一些状态进行计算，如果只有一个组件的话还好，可是有多个组件同时需要用到这种计算呢，此时我们就可以使用 <code>getters</code> 了</p>
<blockquote>
<p>因为 <code>Getters</code> 只是提供了计算功能，因此我们需要在计算属性中去使用 <code>Getters</code> ，从而达到状态更新时，得到的结果也能一起更新<br><code>Getters</code> 会暴露为 <code>store.getters</code> 对象：可以在子组件中通过 <code>this.$store.getters</code> 调用 <code>getters</code> 的方法<br><code>getters</code> 中的函数接收的第一个参数是 <code>state</code>， 第二个参数是其他的 <code>getters</code>，第二个参数也可以不写</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">todos</span>: [</div><div class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</div><div class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在子组件中调用 <code>getters</code> 中的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  doneTodosCount () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Getters</code> 接受其他 <code>getters</code> 作为第二个参数的用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> getters.doneTodos.length</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h3><p>又是同样的套路，为了不用重复写 <code>this.$store.getters</code> ，官方又提供了 <code>mapGetters</code> 辅助函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  computed: &#123;</div><div class="line">  <span class="comment">// 使用对象展开运算符将 getters 混入 computed 对象中</span></div><div class="line">    ...mapGetters([</div><div class="line">      <span class="string">'doneTodosCount'</span>,</div><div class="line">      <span class="string">'anotherGetter'</span>,</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想将一个<code>getter</code> 属性另取一个名字，使用对象形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mapGetters(&#123;</div><div class="line">  <span class="comment">// 映射 this.doneCount 为 store.getters.doneTodosCount</span></div><div class="line">  doneCount: <span class="string">'doneTodosCount'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Mutations-提交状态"><a href="#Mutations-提交状态" class="headerlink" title="Mutations 提交状态"></a>Mutations 提交状态</h2><p>更改 <code>Vuex</code> 的 <code>store</code> 中的状态的唯一方法是提交 <code>mutation</code>。<code>Vuex</code> 中的 <code>mutations</code> 非常类似于事件：每个 <code>mutation</code> 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 <code>state</code> 作为第一个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">count</span>: <span class="number">1</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      <span class="comment">// 变更状态</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>子组件想要提交状态的更改需要使用 <code>store.commit</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</div></pre></td></tr></table></figure>
<h3 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h3><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>
<p>传递普通类型的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">mutations: &#123;</div><div class="line">  increment (state, n) &#123;</div><div class="line">    state.count += n</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>传递一个对象<br>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 <code>mutation</code> 会更易读</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">mutations: &#123;</div><div class="line">  increment (state, payload) &#123;</div><div class="line">    state.count += payload.amount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>, &#123;</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h3><p>提交 mutation 的另一种方式是直接使用包含 <code>type</code> 属性的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$store.commit(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'increment'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  increment (state, payload) &#123;</div><div class="line">    state.count += payload.amount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Mutations-需遵守-Vue-的响应规则"><a href="#Mutations-需遵守-Vue-的响应规则" class="headerlink" title="Mutations 需遵守 Vue 的响应规则"></a>Mutations 需遵守 Vue 的响应规则</h3><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>
<ol>
<li><p>最好提前在你的 <code>store</code> 中初始化好所有所需属性。</p>
</li>
<li><p>当需要在对象上添加新属性时，你应该</p>
<ul>
<li><p>使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, 或者 -</p>
</li>
<li><p>以新对象替换老对象。例如，利用 stage-3 的<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="external">对象展开运算符</a>我们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h3><p>使用常量替代 <code>mutation</code> 事件类型在各种 <code>Flux</code> 实现中是很常见的模式。这样可以使 <code>linter</code> 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 <code>app</code> 包含的 <code>mutation</code> 一目了然：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mutation-types.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// store.js</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></div><div class="line">    [SOME_MUTATION] (state) &#123;</div><div class="line">      <span class="comment">// mutate state</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>用不用常量取决于你 —— 在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>
</blockquote>
<h3 id="mutation-必须是同步函数"><a href="#mutation-必须是同步函数" class="headerlink" title="mutation 必须是同步函数"></a>mutation 必须是同步函数</h3><p>一条重要的原则就是要记住<strong> mutation 必须是同步函数</strong>。如果想要执行异步函数，请使用 <code>Actions</code></p>
<h3 id="在组件中提交-Mutations"><a href="#在组件中提交-Mutations" class="headerlink" title="在组件中提交 Mutations"></a>在组件中提交 Mutations</h3><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'increment'</span> <span class="comment">// 映射 this.increment() 为 this.$store.commit('increment')</span></div><div class="line">    ]),</div><div class="line">    ...mapMutations(&#123;</div><div class="line">      <span class="attr">add</span>: <span class="string">'increment'</span> <span class="comment">// 映射 this.add() 为 this.$store.commit('increment')</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Actions-执行异步操作的地方"><a href="#Actions-执行异步操作的地方" class="headerlink" title="Actions 执行异步操作的地方"></a>Actions 执行异步操作的地方</h2><blockquote>
<p><strong><code>Action</code> 之间也能够互相触发异步执行，使用 <code>stroe</code> 的 <code>dispatch</code> 属性配合 <code>Promise</code></strong></p>
</blockquote>
<p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<p>让我们来注册一个简单的 action：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">count</span>: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123;</div><div class="line">    increment (context) &#123;</div><div class="line">      context.commit(<span class="string">'increment'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>Action</code> 函数接受一个与 <code>store</code> 实例具有相同方法和属性的 <code>context</code> 对象，因此你可以调用 <code>context.commit</code> 提交一个 <code>mutation</code>，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 <code>state</code> 和 <code>getters</code>。当我们在之后介绍到 <a href="https://vuex.vuejs.org/zh-cn/modules.html" target="_blank" rel="external">Modules</a> 时，你就知道 <code>context</code> 对象为什么不是 <code>store</code> 实例本身了。</p>
<p>实践中，我们会经常会用到 ES2015 的 <a href="https://github.com/lukehoban/es6features#destructuring" target="_blank" rel="external">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  increment (&#123; commit &#125;) &#123;</div><div class="line">    commit(<span class="string">'increment'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h3><p><code>Action</code> 在组件中通过 <code>store.dispatch</code> 方法触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'increment'</span>)</div></pre></td></tr></table></figure>
<p>乍一眼看上去感觉多此一举，我们直接分发 <code>mutation</code> 岂不更方便？实际上并非如此，还记得 <strong>mutation 必须同步执行</strong>这个限制么？<code>Action</code> 就不受约束！我们可以在 <code>action</code> 内部执行<strong>异步</strong>操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  incrementAsync (&#123; commit &#125;) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      commit(<span class="string">'increment'</span>)</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以载荷形式分发</span></div><div class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 以对象形式分发</span></div><div class="line">store.dispatch(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'incrementAsync'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>来看一个更加实际的购物车示例，涉及到<strong>调用异步 API</strong> 和 <strong>分发多重 mutations</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  checkout (&#123; commit, state &#125;, products) &#123;</div><div class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></div><div class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</div><div class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></div><div class="line">    commit(types.CHECKOUT_REQUEST)</div><div class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></div><div class="line">    shop.buyProducts(</div><div class="line">      products,</div><div class="line">      <span class="comment">// 成功操作</span></div><div class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</div><div class="line">      <span class="comment">// 失败操作</span></div><div class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意我们正在进行一系列的异步操作，并且通过提交 <code>mutation</code> 来记录 <code>action</code> 产生的副作用（即状态变更）。</p>
<h3 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h3><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapActions([</div><div class="line">      <span class="string">'increment'</span> <span class="comment">// 映射 this.increment() 为 this.$store.dispatch('increment')</span></div><div class="line">    ]),</div><div class="line">    ...mapActions(&#123;</div><div class="line">      <span class="attr">add</span>: <span class="string">'increment'</span> <span class="comment">// 映射 this.add() 为 this.$store.dispatch('increment')</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="组合-Actions"><a href="#组合-Actions" class="headerlink" title="组合 Actions"></a>组合 Actions</h3><p><code>Action</code> 通常是异步的，那么如何知道 <code>action</code> 什么时候结束呢？更重要的是，我们如何才能组合多个 <code>action</code>，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 <code>action</code> 的回调函数返回的 <code>Promise</code>，并且 <code>store.dispatch</code> 仍旧返回 <code>Promise</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  actionA (&#123; commit &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        commit(<span class="string">'someMutation'</span>)</div><div class="line">        resolve()</div><div class="line">      &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在在子组件中你可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在另外一个 <code>action</code> 中也可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      commit(<span class="string">'someOtherMutation'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，如果我们利用 <a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="external">async / await</a> 这个 JavaScript 即将到来的新特性，我们可以像这样组合 <code>action</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></div><div class="line"></div><div class="line">actions: &#123;</div><div class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</div><div class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</div><div class="line">  &#125;,</div><div class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></div><div class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 <code>action</code> 函数。在这种情况下，只有当所有触发函数完成后，返回的 <code>Promise</code> 才会执行。</p>
</blockquote>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，<code>store</code> 对象会变得臃肿不堪。</p>
<p>为了解决以上问题，<code>Vuex</code> 允许我们将 <code>store</code> 分割到<strong>模块（module）</strong>。每个模块拥有自己的 <code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>、甚至是嵌套子模块——从上至下进行类似的分割：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">modules</span>: &#123;</div><div class="line">    <span class="attr">a</span>: moduleA,</div><div class="line">    <span class="attr">b</span>: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></div><div class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></div></pre></td></tr></table></figure>
<h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>对于模块内部的 <code>mutation</code> 和 <code>getter</code>，接收的第一个参数是<strong>模块的局部状态</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  state: &#123; count: 0 &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      // state 模块的局部状态</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  getters: &#123;</div><div class="line">    doubleCount (state) &#123;</div><div class="line">      return state.count * 2</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，对于模块内部的 <code>action</code>，<code>context.state</code> 是局部状态，根节点的状态是 <code>context.rootState</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  // ...</div><div class="line">  actions: &#123;</div><div class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</div><div class="line">      if ((state.count + rootState.count) % 2 === 1) &#123;</div><div class="line">        commit(&apos;increment&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于模块内部的 <code>getter</code>，根节点状态会作为第三个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  // ...</div><div class="line">  getters: &#123;</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      return state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>模块内部的 <code>action</code>、<code>mutation</code>、和 <code>getter</code> 现在仍然注册在<strong>全局命名空间</strong>——这样保证了多个模块能够响应同一 <code>mutation</code> 或 <code>action</code>。你可以通过添加前缀或后缀的方式隔离各模块，以避免名称冲突。你也可能希望写出一个可复用的模块，其使用环境不可控。例如，我们想创建一个 <code>todos</code> 模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// types.js</span></div><div class="line"></div><div class="line"><span class="comment">// 定义 getter、action、和 mutation 的名称为常量，以模块名 `todos` 为前缀</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> DONE_COUNT = <span class="string">'todos/DONE_COUNT'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> FETCH_ALL = <span class="string">'todos/FETCH_ALL'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> TOGGLE_DONE = <span class="string">'todos/TOGGLE_DONE'</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// modules/todos.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../types'</span></div><div class="line"></div><div class="line"><span class="comment">// 使用添加了前缀的名称定义 getter、action 和 mutation</span></div><div class="line"><span class="keyword">const</span> todosModule = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; <span class="attr">todos</span>: [] &#125;,</div><div class="line"></div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    [types.DONE_COUNT] (state) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">actions</span>: &#123;</div><div class="line">    [types.FETCH_ALL] (context, payload) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    [types.TOGGLE_DONE] (state, payload) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h3><p>在 <code>store</code> 创建<strong>之后</strong>，你可以使用 <code>store.registerModule</code> 方法注册模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>模块的状态将是 <code>store.state.myModule</code>。</p>
<p>模块动态注册功能可以让其他 <code>Vue</code> 插件为了应用的 <code>store</code> 附加新模块，以此来分割 <code>Vuex</code> 的状态管理。例如，<a href="https://github.com/vuejs/vuex-router-sync" target="_blank" rel="external"><code>vuex-router-sync</code></a> 插件可以集成 <code>vue-router</code> 与 <code>vuex</code>，管理动态模块的路由状态。</p>
<p>你也可以使用 <code>store.unregisterModule(moduleName)</code> 动态地卸载模块。注意，你不能使用此方法卸载静态模块（在创建 <code>store</code> 时声明的模块）。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">vue,vuex</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/04/06/Framework/Vue/vuex核心概念/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Others/前端面试题整理" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/02/Others/前端面试题整理/">前端面试题整理</a>
    </h1>
  

        
        <a href="/2017/04/02/Others/前端面试题整理/" class="archive-article-date">
  	<time datetime="2017-04-02T12:07:44.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-04-02</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.cnblogs.com/strick/p/4968200.html" target="_blank" rel="external">前端面试题目搜集</a></p>
<h1 id="一、理论知识"><a href="#一、理论知识" class="headerlink" title="一、理论知识"></a>一、理论知识</h1><p><strong>1.1、讲讲输入完网址按下回车，到看到网页这个过程中发生了什么</strong></p>
<p>a. 域名解析</p>
<p>b. 发起TCP的3次握手</p>
<p>c. 建立TCP连接后发起http请求</p>
<p>d. 服务器端响应http请求，浏览器得到html代码</p>
<p>e. 浏览器解析html代码，并请求html代码中的资源</p>
<p>f. 浏览器对页面进行渲染呈现给用户</p>
<p>参考《<a href="http://www.cnblogs.com/strick/p/5494869.html" target="_blank" rel="external">输入URL到展现页面的全过程</a>》</p>
<p><strong>1.2、谈谈你对前端性能优化的理解</strong></p>
<p>a. 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</p>
<p>b. 请求带宽：开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体</p>
<p>c. 缓存利用：使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</p>
<p>d. 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</p>
<p>e. 代码校验：避免CSS表达式，避免重定向</p>
<p>参考《<a href="http://div.io/topic/371" target="_blank" rel="external">前端工程与性能优化</a>》《<a href="http://www.cnblogs.com/strick/p/6228339.html" target="_blank" rel="external">前端网络、JavaScript优化以及开发小技巧</a>》《<a href="http://www.cnblogs.com/strick/p/5475758.html" target="_blank" rel="external">实践一下前端性能分析</a>》</p>
<p><strong>1.3、前端 MV*框架的意义</strong></p>
<p>早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，基本不太需要框架。</p>
<p>随着 AJAX 的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了。</p>
<p>如果是页面型产品，多数确实不太需要它，因为页面中的 JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。</p>
<p>长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。</p>
<p>从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的 MV框架，这个状况会大有改观。</p>
<p>之所以感受不到 MV*框架的重要性，是因为Model部分代码较少，View的相对多一些。如果主要在操作View和Controller，那当然 jQuery 这类库比较好用了。</p>
<p>参考《<a href="http://segmentfault.com/a/1190000002794454" target="_blank" rel="external">前端 MV*框架的意义</a>》</p>
<p><strong>1.4、请简述盒模型</strong></p>
<p>IE6盒子模型与W3C盒子模型。</p>
<p>文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。</p>
<p>CSS3中有个<a href="http://css.doyoe.com/properties/user-interface/box-sizing.htm" target="_blank" rel="external">box-sizing</a>属性可以控制盒子的计算方式，</p>
<p>content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。（W3C盒子模型）</p>
<p>border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。（IE6盒子模型）</p>
<p>参考《<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box_model" target="_blank" rel="external">盒模型</a>》</p>
<p><strong>1.5、请你谈谈Cookie的弊端</strong></p>
<p>a. 每个特定的域名下最多生成的cookie个数有限制</p>
<p>b. IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie</p>
<p>c. cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节</p>
<p>d. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。</p>
<p><strong>1.6、浏览器本地存储</strong></p>
<p>在HTML5中提供了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="external">sessionStorage</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="external">localStorage</a>。</p>
<p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。</p>
<p>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<p><strong>1.7、web storage和cookie的区别</strong></p>
<p>a. Cookie的大小是受限的</p>
<p>b. 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽</p>
<p>c. cookie还需要指定作用域，不可以跨域调用</p>
<p>d. Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie</p>
<p>e. Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p>
<p>f. IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage</p>
<p><strong>1.8、对BFC规范的理解</strong></p>
<p>BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。</p>
<p>BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。</p>
<p>BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>
<p>利用BFC可以闭合浮动，防止与浮动元素重叠。</p>
<p>参考《<a href="http://elcarim5efil.github.io/blog/2015/08/20/Learning_BFC.html" target="_blank" rel="external">Learning BFC</a>》</p>
<p><strong>1.9、线程与进程的区别</strong></p>
<p>a. 一个程序至少有一个进程，一个进程至少有一个线程</p>
<p>b. 线程的划分尺度小于进程，使得多线程程序的并发性高</p>
<p>c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</p>
<p>d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p>
<p>e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</p>
<p><strong>1.10、请说出三种减少页面加载时间的方法</strong></p>
<p>a. 尽量减少页面中重复的HTTP请求数量</p>
<p>b. 服务器开启gzip压缩</p>
<p>c. css样式的定义放置在文件头部</p>
<p>d. Javascript脚本放在文件末尾</p>
<p>e. 压缩合并Javascript、CSS代码</p>
<p>f. 使用多域名负载网页内的多个文件、图片</p>
<p>参考《<a href="http://eadonlearning.blog.51cto.com/6642994/1334446" target="_blank" rel="external">减低页面加载时间的方法</a>》</p>
<p><strong>1.11、你都使用哪些工具来测试代码的性能？</strong></p>
<p><a href="http://jsperf.com/" target="_blank" rel="external">JSPerf</a>, <a href="https://github.com/jeresig/dromaeo" target="_blank" rel="external">Dromaeo</a></p>
<p><strong>1.12、你遇到过比较难的技术问题是？你是如何解决的？</strong></p>
<p><strong>1.13、常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</strong></p>
<p><strong>1.14、列举IE与其他浏览器不一样的特性？</strong></p>
<p>a. IE的排版引擎是Trident （又称为MSHTML）</p>
<p>b. Trident内核曾经几乎与W3C标准脱节（2005年）</p>
<p>c. Trident内核的大量 Bug等安全性问题没有得到及时解决</p>
<p>d. JS方面，有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等</p>
<p>e. CSS方面，也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式</p>
<p>参考《<a href="https://zh.wikipedia.org/wiki/Trident_(%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E" target="_blank" rel="external">Trident（排版引擎）</a>)》</p>
<p><strong>1.15、什么叫优雅降级和渐进增强？</strong></p>
<p><strong>渐进增强 progressive enhancement：</strong></p>
<p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p><strong>优雅降级 graceful degradation：</strong></p>
<p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p><strong>区别：</strong></p>
<p>a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给</p>
<p>b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</p>
<p>c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>
<p>参考《<a href="http://www.cnblogs.com/mofish/p/3822879.html" target="_blank" rel="external">优雅降级和渐进增强的区别</a>》</p>
<p><strong>1.16、WEB应用从服务器主动推送Data到客户端有那些方式？</strong></p>
<p>a. html5 websoket</p>
<p>b. WebSocket 通过 Flash</p>
<p>c. XHR长时间连接</p>
<p>d. XHR Multipart Streaming</p>
<p>e. 不可见的Iframe</p>
<p>f. \<script\>标签的长时间连接(可跨域)</script\></p>
<p><strong>1.17、对前端界面工程师这个职位是怎么样理解的？</strong></p>
<p>a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好</p>
<p>b. 参与项目，快速高质量完成实现效果图，精确到1px；</p>
<p>c. 与团队成员，UI设计，产品经理的沟通；</p>
<p>d. 做好的页面结构，页面重构和用户体验；</p>
<p>e. 处理hack，兼容、写出优美的代码格式；</p>
<p>f. 针对服务器的优化、拥抱最新前端技术。</p>
<p><strong>1.18、你在现在的团队处于什么样的角色，起到了什么明显的作用？</strong></p>
<p><strong>1.19、你的优点是什么？缺点是什么？</strong></p>
<p><strong>1.20、如何管理前端团队?</strong></p>
<p><strong>1.21、最近在学什么？能谈谈你未来3，5年给自己的规划吗？</strong></p>
<p><strong>1.22、平时如何管理你的项目？</strong></p>
<p>a. 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</p>
<p>b. 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</p>
<p>c. 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</p>
<p>d. 页面进行标注（例如 页面 模块 开始和结束）；</p>
<p>e. CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</p>
<p>f. JS 分文件夹存放 命名以该JS功能为准的英文翻译。</p>
<p>g. 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</p>
<p><strong>1.23、说说最近最流行的一些东西吧？常去哪些网站？</strong></p>
<p>CSDN、SegmentFault、php.net、MDN、css参考手册、iconfont、</p>
<p>underscore、github、Bootstrap、W3Shool、W3Cplus、caniuse</p>
<p><strong>1.24、Flash、Ajax各自的优缺点，在使用中如何取舍？</strong></p>
<p><strong>Flash：</strong><br>a. Flash适合处理多媒体、矢量图形、访问机器</p>
<p>b. 对CSS、处理文本上不足，不容易被搜索</p>
<p><strong>Ajax：</strong></p>
<p>a. Ajax对CSS、文本支持很好，支持搜索</p>
<p>b. 多媒体、矢量图形、机器访问不足</p>
<p><strong>共同点：</strong></p>
<p>a. 与服务器的无刷新传递消息</p>
<p>b. 可以检测用户离线和在线状态</p>
<p>c. 操作DOM</p>
<p><strong>1.25、请解释一下 JavaScript 的同源策略</strong></p>
<p>同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</p>
<p>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<p><strong>1.26、AMD和CMD 规范的区别？</strong></p>
<p>AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现</p>
<p>CMD 按需执行依赖 - 懒执行，seaJS 是它的实现</p>
<p>参考《<a href="http://www.douban.com/note/283566440/" target="_blank" rel="external">SeaJS与RequireJS最大的区别</a>》、《<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="external">与 RequireJS 的异同</a>》</p>
<p><strong>1.27、网站重构的理解</strong></p>
<p>重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。</p>
<p>a. 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</p>
<p>b. 对于移动平台的优化，针对于SEO进行优化</p>
<p>c. 减少代码间的耦合，让代码保持弹性</p>
<p>d. 压缩或合并JS、CSS、image等前端资源</p>
<p><strong>1.28、浏览器的内核分别是什么?</strong></p>
<p>IE浏览器的内核Trident、Mozilla的Gecko、Chrome的Blink（WebKit的分支）、Opera内核原为Presto，现为Blink；</p>
<p><strong>1.29、请介绍下cache-control</strong></p>
<p>每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略</p>
<p>Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久</p>
<p>Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。</p>
<p><strong>1.30、前端页面有哪三层构成，分别是什么？作用是什么？</strong></p>
<p>a. 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。</p>
<p>b. 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。</p>
<p>c. 行为层：由脚本负责。解决了页面上“内容应该如何对事件作出反应”的问题。</p>
<p><strong>1.31、知道的网页制作会用到的图片格式有哪些？</strong></p>
<p>png-8，png-24，jpeg，gif，svg</p>
<p>Webp：谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。</p>
<p>Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。</p>
<p><strong>1.32、一次js请求一般情况下有哪些地方会有缓存处理？</strong></p>
<p>a. 浏览器端存储</p>
<p>b. 浏览器端文件缓存</p>
<p>c. HTTP缓存304</p>
<p>d. 服务器端文件类型缓存</p>
<p>e. 表现层&amp;DOM缓存</p>
<p>参考《<a href="http://www.nowamagic.net/librarys/veda/detail/162" target="_blank" rel="external">一次HTTP请求中有哪些地方可以缓存</a>》</p>
<p><strong>1.33、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</strong></p>
<p>a. 图片懒加载，滚动到相应位置才加载图片。</p>
<p>b. 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。</p>
<p>c. 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。</p>
<p>d. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p>
<p><strong>1.34、谈谈以前端角度出发做好SEO需要考虑什么？</strong></p>
<p>a. 了解搜索引擎如何抓取网页和如何索引网页</p>
<p>b. meta标签优化</p>
<p>c. 关键词分析</p>
<p>d. 付费给搜索引擎</p>
<p>e. 链接交换和链接广泛度（Link Popularity）</p>
<p>f. 合理的标签使用</p>
<h1 id="二、HTML"><a href="#二、HTML" class="headerlink" title="二、HTML"></a>二、HTML</h1><p><strong>2.1、<code>&lt;img&gt;</code>标签上title属性与alt属性的区别是什么？</strong></p>
<p>alt属性是为了给那些不能看到你文档中图像的浏览者提供文字说明的。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。</p>
<p>这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等。</p>
<p>title属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。参考《<a href="http://www.yzznl.cn/archives/alt-and-title.html" target="_blank" rel="external">alt和title属性的区别及应用</a>》</p>
<p><strong>2.2、分别写出以下几个HTML标签：文字加粗、下标、居中、字体</strong></p>
<p>加粗：<code>&lt;b&gt;</code>、<code>&lt;strong&gt;</code></p>
<p>下标：<code>&lt;sub&gt;</code></p>
<p>居中：<code>&lt;center&gt;</code></p>
<p>字体：<code>&lt;font&gt;</code>、<code>&lt;basefont&gt;</code>、参考《HTML标签列表》</p>
<p><strong>2.3、请写出至少5个html5新增的标签，并说明其语义和应用场景</strong></p>
<p>section：定义文档中的一个章节</p>
<p>nav：定义只包含导航链接的章节</p>
<p>header：定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。</p>
<p>footer：定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。</p>
<p>aside：定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。</p>
<p>参考《<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list" target="_blank" rel="external">HTML5 标签列表</a>》</p>
<p><strong>2.4、请说说你对标签语义化的理解？</strong></p>
<p>a. 去掉或者丢失样式的时候能够让页面呈现出清晰的结构</p>
<p>b. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</p>
<p>c. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</p>
<p>d. 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>
<p><strong>2.5、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</strong></p>
<p>&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档。</p>
<p>严格模式的排版和 JS 运作模式是，以该浏览器支持的最高标准运行。</p>
<p>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>
<p>DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p>
<p><strong>2.6、你知道多少种Doctype文档类型？</strong></p>
<p>标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>
<p>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。</p>
<p>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。</p>
<p>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，</p>
<p>Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
<p><strong>2.7、HTML与XHTML——二者有什么区别</strong></p>
<p>a. XHTML 元素必须被正确地嵌套。</p>
<p>b. XHTML 元素必须被关闭。</p>
<p>c. 标签名必须用小写字母。</p>
<p>d. XHTML 文档必须拥有根元素。</p>
<p>参考《<a href="http://www.w3school.com.cn/xhtml/xhtml_html.asp" target="_blank" rel="external">XHTML 与 HTML 之间的差异</a>》</p>
<p><strong>2.8、html5有哪些新特性、移除了那些元素？</strong></p>
<p>a. HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<p>b. 拖拽释放(Drag and drop) API</p>
<p>c. 语义化更好的内容标签（header,nav,footer,aside,article,section）</p>
<p>d. 音频、视频API(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio" target="_blank" rel="external">audio</a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video" target="_blank" rel="external">video</a>)</p>
<p>e. 画布(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="external">Canvas</a>) API</p>
<p>f. 地理(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/Using_geolocation" target="_blank" rel="external">Geolocation</a>) API</p>
<p>g. 本地离线存储 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="external">localStorage</a> 长期存储数据，浏览器关闭后数据不丢失</p>
<p>h. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="external">sessionStorage</a> 的数据在页面会话结束时会被清除</p>
<p>i. 表单控件，calendar、date、time、email、url、search </p>
<p>j. 新的技术<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">webworker</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="external">websocket</a>等</p>
<p><strong>移除的元素：</strong></p>
<p>a. 纯表现的元素：basefont，big，center, s，strike，tt，u；</p>
<p>b. 对可用性产生负面影响的元素：frame，frameset，noframes；</p>
<p><strong>2.9、iframe的优缺点？</strong></p>
<p><strong>优点：</strong></p>
<p>a. 解决加载缓慢的第三方内容如图标和广告等的加载问题</p>
<p>b. iframe无刷新文件上传</p>
<p>c. iframe跨域通信</p>
<p><strong>缺点：</strong></p>
<p>a. iframe会阻塞主页面的Onload事件</p>
<p>b. 无法被一些搜索引擎索引到</p>
<p>c. 页面会增加服务器的http请求</p>
<p>d. 会产生很多页面，不容易管理。</p>
<p>参考《<a href="http://www.cnblogs.com/strick/p/3814872.html" target="_blank" rel="external">iframe的一些记录</a>》</p>
<p><strong>2.10、Quirks模式是什么？它和Standards模式有什么区别？</strong></p>
<p>在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。IE6以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。</p>
<p><strong>区别：总体会有布局、样式解析和脚本执行三个方面的区别。</strong></p>
<p>a. 盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。</p>
<p>b. 设置行内元素的高宽：在Standards模式下，给<code>&lt;span&gt;</code>等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。</p>
<p>c. 设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用</p>
<p>d. 设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。</p>
<p><strong>2.11、请阐述table的缺点</strong></p>
<p>a. 太深的嵌套，比如table&gt;tr&gt;td&gt;h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了冗余代码量。</p>
<p>b. 灵活性差，比如要将tr设置border等属性，是不行的，得通过td</p>
<p>c. 代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱</p>
<p>d. 混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱。</p>
<p>e. table需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。</p>
<p>f. 不够语义</p>
<p>参考《<a href="http://jo2.org/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4table%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80%E4%B8%8D%E5%A5%BD%EF%BC%9F/" target="_blank" rel="external">为什么说table表格布局不好？</a>》</p>
<p><strong>2.12、简述一下src与href的区别</strong></p>
<p>src用于替换当前元素；href用于在当前文档和引用资源之间确立联系。</p>
<p>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置</p>
<p>href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接</p>
<h1 id="三、CSS"><a href="#三、CSS" class="headerlink" title="三、CSS"></a>三、CSS</h1><p><strong>3.1、谈谈你对CSS布局的理解</strong></p>
<p><strong>3.2、请列举几种可以清除浮动的方法（至少两种）</strong></p>
<p>浮动会漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是这种特性，导致框内部由于不存在其他普通流元素了，表现出高度为0（高度塌陷）。</p>
<p>a. 添加额外标签，例如<code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></p>
<p>b. 使用br标签和其自身的html属性，例如<code>&lt;br clear=&quot;all&quot; /&gt;</code></p>
<p>c. 父元素设置 overflow：hidden；在IE6中还需要触发<a href="http://yiminghe.iteye.com/blog/367384" target="_blank" rel="external">hasLayout</a>，例如zoom：1；</p>
<p>d. 父元素设置 overflow：auto 属性；同样IE6需要触发hasLayout</p>
<p>e. 父元素也设置浮动</p>
<p>f. 父元素设置display:table</p>
<p>g. 使用:after 伪元素；由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p>
<p>在CSS2.1里面有一个很重要的概念，那就是 Block formatting contexts （块级格式化上下文），简称 <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">BFC</a>。</p>
<p>创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，同时BFC仍然属于文档中的普通流。</p>
<p>IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念。</p>
<p>参考《<a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="external">那些年我们一起清除过的浮动</a>》</p>
<p><strong>3.3、请列举几种隐藏元素的方法</strong></p>
<p>a. visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。</p>
<p>b. opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate</p>
<p>c. position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。</p>
<p>d. display: none；元素会变得不可见，并且不会再占用文档的空间。</p>
<p>e. transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。</p>
<p>f. HTML5 hidden attribute；hidden属性的效果和display:none;相同，这个属性用于记录一个元素的状态</p>
<p>g. height: 0; overflow: hidden；将元素在垂直方向上收缩为0,使元素消失。只要元素没有可见的边框，该技术就可以正常工作。</p>
<p>h. filter: blur(0)；将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中。</p>
<p>参考《<a href="http://www.htmleaf.com/ziliaoku/qianduanjiaocheng/201502271431.html" target="_blank" rel="external">使用CSS隐藏HTML元素的4种常用方法</a>》《<a href="http://www.htmleaf.com/ziliaoku/qianduanjiaocheng/201502281436.html" target="_blank" rel="external">通过HTML和CSS隐藏和显示元素的4种方法</a>》</p>
<p><strong>3.4、如何让一段文本中的所有英文单词的首字母大写</strong></p>
<p><a href="http://css.doyoe.com/properties/text/text-transform.htm" target="_blank" rel="external">text-transform</a>：</p>
<p>none| capitalize(将每个单词的第一个字母转换成大写) | uppercase(将每个单词转换成大写 ) | lowercase(将每个单词转换成小写 )</p>
<p><strong>3.5、请简述CSS样式表继承</strong></p>
<p>CSS样式表继承指的是，特定的CSS属性向下传递到子孙元素。会被继承下去的属性如下：参考《<a href="http://www.cnphp.info/css-style-inheritance.html" target="_blank" rel="external">CSS样式表继承详解</a>》</p>
<p>文本相关：font-family，font-size， font-style，font-variant，font-weight， font，letter-spacing，line-height，color</p>
<p>列表相关：list-style-image，list-style-position，list-style-type， list-style</p>
<p><strong>3.6、请简述CSS的选择器</strong></p>
<p>元素选择器：* 、E、 E#id、 E.class</p>
<p>关系选择器：E、F、E&gt;F、E+F、E~F</p>
<p>属性选择器：E[att]、E[att=”val”]、E[att~=”val”]、E[att^=”val”]、E[att$=”val”]、E[att*=”val”]、E[att|=”val”]</p>
<p>伪类选择器：E:link、E:visited、E:hover、E:active、E:focus、E:lang(fr)、E:not(s)、E:root、E:first-child、E:last-chil等</p>
<p>伪对象选择器：E:first-letter/E::first-letter、E:first-line/E::first-line、E:before/E::before、E:after/E::after、E::selection</p>
<p>参考《<a href="http://css.doyoe.com/selectors/index.htm" target="_blank" rel="external">选择符列表</a>》</p>
<p><strong>3.7、CSS伪类与CSS伪对象的区别</strong></p>
<p>CSS 引入伪类和伪元素的概念是为了描述一些现有CSS无法描述的东西</p>
<p>根本区别在于：它们是否创造了新的元素（抽象）</p>
<p>伪类：一开始用来表示一些元素的动态状态，随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类</p>
<p>伪对象：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中</p>
<p>参考《<a href="http://swordair.com/origin-and-difference-between-css-pseudo-classes-and-pseudo-elements/" target="_blank" rel="external">CSS伪类与CSS伪元素的区别及由来</a>》</p>
<p><strong>3.8、请简述CSS的权重规则</strong></p>
<p>一个行内样式+1000，一个id+100，一个属性选择器/class类/伪类选择器+10，一个元素名/伪对象选择器+1。</p>
<p>关系选择器将拆分为两个选择器再计算。参考《<a href="http://www.w3cplus.com/css/css-specificity-things-you-should-know.html" target="_blank" rel="external">CSS权重</a>》</p>
<p><strong>3.9、请写出多种等高布局</strong></p>
<p>a. 假等高列：使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像</p>
<p>b. 给容器div使用单独的背景色（<a href="http://codepen.io/strick/pen/ZbZYoW" target="_blank" rel="external">固定布局</a>）（<a href="http://codepen.io/strick/pen/WQWOPK" target="_blank" rel="external">流体布局</a>）：用<code>&lt;div&gt;</code>元素中的最大高度撑大其他的<code>&lt;div&gt;</code>容器高度</p>
<p>c. 创建<a href="http://codepen.io/strick/pen/bVJRQv" target="_blank" rel="external">带边框的两列</a>等高布局：用border-left来做，只能使用两列。</p>
<p>d. 使用<a href="http://codepen.io/strick/pen/qOwXEN" target="_blank" rel="external">正padding和负margin</a>对冲实现多列布局方法：在所有列中使用正的上、下padding和负的上、下margin，并在所有列外面加上一个容器，设置overflow:hiden把溢出背景切掉</p>
<p>e. 使用<a href="http://codepen.io/strick/pen/XmQabJ" target="_blank" rel="external">边框和定位模拟</a>列等高：但不能使用在多列</p>
<p>f. <a href="http://codepen.io/strick/pen/ZbZJGg" target="_blank" rel="external">模仿表格布局</a>等高列效果：兼容性不好，在ie6-7无法正常运行</p>
<p><strong>3.10、在CSS样式中常使用px、em，各有什么优劣，在表现上有什么区别？</strong></p>
<p>px是相对长度单位，相对于显示器屏幕分辨率而言的。</p>
<p>em是相对长度单位，相对于当前对象内文本的字体尺寸。</p>
<p>px定义的字体，无法用浏览器字体放大功能。</p>
<p>em的值并不是固定的，会继承父级元素的字体大小，1 ÷ 父元素的font-size × 需要转换的像素值 = em值。</p>
<p><strong>3.11、CSS中 link 和@import 的区别是什么？</strong></p>
<p>a. link属于HTML标签，而@import是CSS提供的，且只能加载 CSS</p>
<p>b. 页面被加载时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p>
<p>c. import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p>
<p>d. link方式的样式的权重 高于@import的权重</p>
<p>e. 当使用 Javascript 控制 DOM 去改变样式的时候，只能使用 link 方式，因为 @import 眼里只有 CSS ，不是 DOM 可以控制</p>
<p><strong>3.12、position的absolute与fixed共同点与不同点</strong></p>
<p><strong>相同：</strong></p>
<p>a. 改变行内元素的呈现方式，display被置为block</p>
<p>b. 让元素脱离普通流，不占据空间</p>
<p>c. 默认会覆盖到非定位元素上</p>
<p><strong>区别：</strong></p>
<p>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。</p>
<p>当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>
<p><strong>3.13、position的值， relative和absolute分别是相对于谁进行定位的？</strong></p>
<p>absolute：生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位</p>
<p>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 （IE6不支持）</p>
<p>relative：生成相对定位的元素，相对于其在普通流中的位置进行定位</p>
<p>static：默认值。没有定位，元素出现在正常的流中</p>
<p><strong>3.14、CSS3有哪些新特性？</strong></p>
<p>CSS3实现圆角（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius" target="_blank" rel="external">border-radius</a>），阴影（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow" target="_blank" rel="external">box-shadow</a>），对文字加特效（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow" target="_blank" rel="external">text-shadow</a>），线性渐变（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient" target="_blank" rel="external">gradient</a>），变形（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform" target="_blank" rel="external">transform</a>）</p>
<p>增加了更多的CSS选择器  多背景 rgba，在CSS3中唯一引入的伪元素是::selection，媒体查询，多栏布局</p>
<p>参考《<a href="http://www.cnblogs.com/strick/p/3839873.html" target="_blank" rel="external">CSS3中的动画效果记录</a>》、《<a href="http://www.cnblogs.com/strick/p/4843595.html" target="_blank" rel="external">CSS3中border-radius、box-shadow与gradient那点事儿</a>》</p>
<p><strong>3.15、为什么要初始化CSS样式？</strong></p>
<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
<p>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
<p><strong>3.16、解释下 CSS sprites原理，优缺点</strong></p>
<p>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，</p>
<p>再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，</p>
<p>background-position可以用数字精确的定位出背景图片的位置。</p>
<p><strong>优点：</strong></p>
<p>a. 减少网页的http请求</p>
<p>b. 减少图片的字节</p>
<p>c. 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名</p>
<p>d. 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。</p>
<p><strong>缺点：</strong></p>
<p>a. 在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂</p>
<p>b. CSS Sprites在开发的时候，要通过photoshop或其他工具测量计算每一个背景单元的精确位置</p>
<p>c. 在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片</p>
<p><strong>3.17、解释下浮动和它的工作原理？</strong></p>
<p>a. 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</p>
<p>b. 浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
<p><strong>3.18、浮动元素引起的问题</strong></p>
<p>a. 父元素的高度无法被撑开，影响与父元素同级的元素</p>
<p>b. 与浮动元素同级的非浮动元素会跟随其后</p>
<p>c. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</p>
<p><strong>3.19、什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</strong></p>
<p>如果使用import方法对CSS进行导入，会导致某些页面在Windows下的IE出现一些奇怪的现象：</p>
<p>以无样式显示页面内容的瞬间闪烁，这种现象称之为文档样式短暂失效(Flash of Unstyled Content)，简称为FOUC。</p>
<p>原理：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</p>
<p>解决方法：使用LINK标签将样式表放在文档HEAD中。</p>
<p><strong>3.20、line-height三种赋值方式有何区别？（带单位、纯数字、百分比）</strong></p>
<p>带单位：px不用计算，em则会使元素以其父元素font-size值为参考来计算自己的行高</p>
<p>纯数字：把比例传递给后代，例如父级行高为1.5，子元素字体为18px，则子元素行高为1.5*18=27px</p>
<p>百分比：将计算后的值传递给后代</p>
<p>参考《<a href="http://ixdfan.github.io/css/2014/04/01/line-height.html" target="_blank" rel="external">line-height的理解</a>》、《<a href="http://www.html-js.com/article/2952" target="_blank" rel="external">浅析line-height和vertical</a>》，<a href="http://codepen.io/strick/pen/RWzKrz" target="_blank" rel="external">查看在线源码</a>。</p>
<p><strong>3.21、:link、:visited、:hover、:active的执行顺序是怎么样的？</strong></p>
<p>L-V-H-A，l(link)ov(visited)e h(hover)a(active)te，即用喜欢和讨厌两个词来概括</p>
<p><strong>3.22、经常遇到的浏览器兼容性有哪些？如何解决？</strong></p>
<p>a. 浏览器默认的margin和padding不同</p>
<p>b. IE6双边距bug</p>
<p>c. 在ie6，ie7中元素高度超出自己设置高度。原因是IE8以前的浏览器中会给元素设置默认的行高的高度导致的</p>
<p>d. min-height在IE6下不起作用</p>
<p>e. 透明性IE用filter:Alpha(Opacity=60)，而其他主流浏览器用 opacity:0.6</p>
<p>f. input边框问题，去掉input边框一般用border:none;就可以，但由于IE6在解析input样式时的BUG(优先级问题)，在IE6下无效</p>
<p><strong>3.23、有哪项方式可以对一个DOM设置它的CSS样式？</strong></p>
<p>a. 外部样式表：通过<code>&lt;link&gt;</code>标签引入一个外部css文件</p>
<p>b. 内部样式表：将css代码放在 <code>&lt;style&gt;</code> 标签内部</p>
<p>c. 内联样式：将css样式直接定义在 HTML 元素内部</p>
<p><strong>3.24、什么是外边距重叠？重叠的结果是什么？</strong></p>
<p>外边距重叠就是margin-collapse。</p>
<p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</p>
<p>折叠结果遵循下列计算规则：</p>
<p>a. 两个相邻的外边距都是正数时，折叠结果是它们两者之间<strong>较大的值</strong>。</p>
<p>b. 两个相邻的外边距都是负数时，折叠结果是两者<strong>绝对值的较大值</strong>。</p>
<p>c. 两个外边距一正一负时，折叠结果是两者的<strong>相加的和</strong>。</p>
<p><strong>3.25、rgba()和opacity的透明效果有什么不同？</strong></p>
<p>a. opacity作用于元素，以及元素内的所有内容的透明度，rgba()只作用于元素的颜色或其背景色。</p>
<p>b. 设置rgba透明的元素的子元素不会继承透明效果！</p>
<p><strong>3.26、css属性content有什么作用？有什么应用？</strong></p>
<p>css的content属性专门应用在 before/after 伪元素上，用于来插入生成内容。</p>
<p>可以配合自定义字体显示特殊符号。</p>
<h1 id="四、JavaScript"><a href="#四、JavaScript" class="headerlink" title="四、JavaScript"></a>四、JavaScript</h1><p><strong>4.1、请解释一下什么是闭包</strong></p>
<p>闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。</p>
<p>可以把闭包简单理解成 “定义在一个函数内部的函数”，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包有如下特性：</p>
<p>a. JavaScript允许你使用在当前函数以外定义的变量</p>
<p>b. 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量</p>
<p>c. 闭包可以更新外部变量的值</p>
<p>d. 用闭包模拟私有方法</p>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题</p>
<p>参考《<a href="http://www.cnblogs.com/strick/p/5806427.html" target="_blank" rel="external">作用域、提升与闭包</a>》</p>
<p><strong>4.2、call 和 apply 的区别是什么？</strong></p>
<p>call 和 apply 就是为了改变函数体内部 this 的指向。</p>
<p>区别是从第二个参数起，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。</p>
<p>当参数明确时用call与apply都行, 当参数不明确时可用apply给合arguments</p>
<p><strong>4.3、如何使用原生 Javascript 代码深度克隆一个对象（注意区分对象类型）</strong></p>
<p>在网上找了个函数，用递归的方式做复制。传入的参数必须得是Array或Object。</p>
<p>并且用到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="external">JSON.stringify</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="external">JSON.parse</a>。<a href="http://codepen.io/strick/pen/rORKWp" target="_blank" rel="external">查看在线代码</a>。参考《<a href="http://myweb.jowai.info/javascript-clone-and-copy-and-whatever/" target="_blank" rel="external">JavaScript中的对象克隆</a>》</p>
<p><strong>4.4、 jQuery中 $(′.class′)和$(‘div.class’) 哪个效率更高？</strong></p>
<p>jQuery内部使用Sizzle引擎，处理各种选择器。Sizzle引擎的选择顺序是从右到左，所以这条语句是先选.class，</p>
<p>第二个会直接过滤出div标签，而第一个就不会过滤了，将所有相关标签都列出。参考《<a href="http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html" target="_blank" rel="external">jQuery最佳实践</a>》</p>
<p><strong>4.5、实现输出document对象中所有成员的名称和类型</strong></p>
<p>用一个for in方式循环document，然后在将内容console出来，</p>
<p>就是看到篇文章还会判断document.hasOwnProperty，然后再做打印，我测试了下这样的话打印不出来。</p>
<p><a href="http://codepen.io/strick/pen/WQWExL" target="_blank" rel="external">查看在线代码</a>。参考《<a href="http://myweb.jowai.info/javascript-main-points-archive-dom/" target="_blank" rel="external">JavaScript要点归档：DOM</a>》</p>
<p><strong>4.6、获得一个DOM元素的绝对位置</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetTop" target="_blank" rel="external">offsetTop</a>：返回当前元素相对于其 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent" target="_blank" rel="external">offsetParent</a> 元素的顶部的距离</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetLeft" target="_blank" rel="external">offsetLeft</a>：返回当前元素相对于其 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent" target="_blank" rel="external">offsetParent</a> 元素的左边的距离</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external">getBoundingClientRect()</a>：返回值是一个<a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect" target="_blank" rel="external">DOMRect</a>对象，它包含了一组用于描述边框的只读属性——left、top、right和bottom，属性单位为像素</p>
<p>参考《<a href="http://www.cnblogs.com/strick/p/4826273.html" target="_blank" rel="external">JavaScript中尺寸、坐标</a>》，<a href="http://codepen.io/strick/pen/XmQaaX" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.7、如何利用JS生成一个table？</strong></p>
<p>首先是用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createElement" target="_blank" rel="external">createElement</a>创建一个table，再用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/setAttribute" target="_blank" rel="external">setAttribute</a>设置table的属性，</p>
<p>然后用for循环设置tr和td的内容，用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild" target="_blank" rel="external">appendChild</a>拼接内容，设置td的时候还用到<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML" target="_blank" rel="external">innerHTML</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Properties_Reference" target="_blank" rel="external">style</a>.padding。</p>
<p><a href="http://codepen.io/strick/pen/wKZqpR" target="_blank" rel="external">查看在线代码</a>。参考《<a href="http://myweb.jowai.info/javascript-main-points-archive-dom-table/" target="_blank" rel="external">JavaScript要点归档：DOM表格</a>》《<a href="http://myweb.jowai.info/javascript-main-points-archive-dom/" target="_blank" rel="external">JavaScript要点归档：DOM</a>》</p>
<p><strong>4.8、实现预加载一张图片，加载完成后显示在网页中并设定其高度为50px，宽度为50px</strong></p>
<p>先new <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement/Image" target="_blank" rel="external">Image</a>()获取一个图片对象，然后在图片对象的onload中设置宽度和高度。<a href="http://codepen.io/strick/pen/vNMJVr" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.9、假设有一个4行tr的table，将table里面tr顺序颠倒</strong></p>
<p>先是通过table.tBodies[0].rows获取到当前tbody中的行，接下来是两种方法处理。获取到的行没有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="external">reverse</a>这个方法。</p>
<p>第一种是将这些行push到另外一个数组中</p>
<p>第二种是用Array.prototype.<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="external">slice</a>.call()将那些行变成数组，</p>
<p>接着用reverse倒叙，table再appendChild。<a href="http://codepen.io/strick/pen/VvNzqX" target="_blank" rel="external">查看在线代码</a>。</p>
<p>这里我有个疑问，就是在appendChild的时候，并不是在最后把列加上，而是做了替换操作？</p>
<p><strong>4.10、模拟一个HashTable类，一个类上注册四个方法：包含有add、remove、contains、length方法</strong></p>
<p>先是在构造函数中定义一个数组，然后用push模拟add，splice模拟remove。</p>
<p>四个方法都放在了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="external">prototype</a>上面。<a href="http://codepen.io/strick/pen/VvNBom" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.11、Ajax读取一个XML文档并进行解析的实例</strong></p>
<p>a. 初始化一个HTTP请求，IE以ActiveX对象引入。 后来标准浏览器提供了XMLHttpRequest类，它支持ActiveX对象所提供的方法和属性</p>
<p>b. 发送请求，可以调用HTTP请求类的open()和send()方法</p>
<p>c. 处理服务器的响应，通过http_request.onreadystatechange = nameOfTheFunction。来指定函数</p>
<p>参考《<a href="https://developer.mozilla.org/zh-CN/docs/AJAX" target="_blank" rel="external">AJAX</a>》《<a href="https://developer.mozilla.org/zh-CN/docs/AJAX/Getting_Started" target="_blank" rel="external">开始AJAX</a>》，<a href="http://codepen.io/strick/pen/yYrxLw" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.12、JS如何实现面向对象和继承机制？</strong></p>
<p><strong>创建对象方法：</strong></p>
<p>a. 利用json创建对象</p>
<p>b. 使用JavaScript中的Object类型</p>
<p>c. 通过创建函数来生成对象</p>
<p><strong>继承机制：</strong></p>
<p>a. 构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上</p>
<p>b. prototype模式，继承new函数的模式</p>
<p>c. 直接继承函数的prototype属性，对b的一种改进</p>
<p>d. 利用空对象作为中介</p>
<p>e. 在ECMAScript5中定义了一个新方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create()</a>，用于创建一个新方法</p>
<p>f. 拷贝继承，把父对象的所有属性和方法，拷贝进子对象，实现继承。参考《<a href="http://myweb.jowai.info/javascript-clone-and-copy-and-whatever/" target="_blank" rel="external">JavaScript中的对象克隆</a>》</p>
<p>参考《<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="external">Javascript继承机制的设计思想</a>》《<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">构造函数的继承</a>》，<a href="http://codepen.io/strick/pen/xweaZZ" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.13、JS模块的封装方法，比如怎样实现私有变量，不能直接赋值，只能通过公有方法</strong></p>
<p>a. 通过json生成对象的原始模式，多写几个就会非常麻烦，也不能反映出它们是同一个原型对象的实例</p>
<p>b. 原始模式的改进，可以写一个函数，解决代码重复的问题。同样不能反映出它们是同一个原型对象的实例</p>
<p>c. 构造函数模式，就是一个普通函数，不过内部使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">this</a>变量，但是存在一个浪费内存的问题。</p>
<p>d. Prototype模式，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承，可以把那些不变的属性和方法，直接定义在prototype对象上。Prototype模式的验证方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf" target="_blank" rel="external">isPrototypeOf()</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="external">hasOwnProperty()</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in" target="_blank" rel="external">in</a>运算符。</p>
<p>参考《<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">封装</a>》，<a href="http://codepen.io/strick/pen/dYLqOW" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.14、对this指针的理解，可以列举几种使用情况？</strong></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">this</a>指的是：调用函数的那个对象。</p>
<p>a. 纯粹的函数调用，属于全局性调用，因此this就代表全局对象Global。</p>
<p>b. 作为对象方法的调用，这时this就指这个上级对象。</p>
<p>c. 作为构造函数调用，就是通过这个函数new一个新对象（object）。这时，this就指这个新对象。</p>
<p>d. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external">apply</a>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external">call</a>的调用，它们的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。</p>
<p>参考《<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">Javascript的this用法</a>》《<a href="http://www.cnblogs.com/strick/p/5813749.html" target="_blank" rel="external">this</a>》，<a href="http://codepen.io/strick/pen/qOwwwP" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.15、在JavaScript中，常用的绑定事件的方法有哪些？</strong></p>
<p>a. 在DOM元素中直接绑定，DOM元素，可以理解为HTML标签，onXXX=”JavaScript Code”，<a href="http://www.w3school.com.cn/jsref/jsref_events.asp" target="_blank" rel="external">查看事件列表</a>。</p>
<p>b. 在JavaScript代码中绑定，elementObject.onXXX=function(){}，通称为DOM0事件系统。</p>
<p>c. 绑定事件监听函数，标准浏览器使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="external">addEventListener()</a> ，IE11以下版本<a href="https://msdn.microsoft.com/en-us/library/ms536343(VS.85" target="_blank" rel="external">attachEvent()</a>.aspx) 来绑定事件监听函数，通称为DOM2事件系统。</p>
<p>参考《<a href="http://www.itxueyuan.org/view/6338.html" target="_blank" rel="external">JavaScript绑定事件的方法</a>》《<a href="http://www.cnblogs.com/strick/p/5004921.html" target="_blank" rel="external">JavaScript中事件处理</a>》</p>
<p><strong>4.16、解释下javascript的冒泡和捕获</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"click1"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"click2"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"click3"</span>&gt;</span>事件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>a. Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型</p>
<p>b. 微软则保持元素3具有优先权，这种事件顺序被称为冒泡型</p>
<p>c. W3C选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</p>
<p>事件监听函数<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="external">addEventListener()</a>的第三个参数就是控制方法是捕获还是冒泡</p>
<p>参考《<a href="http://myweb.jowai.info/javascript-main-points-archive-events/" target="_blank" rel="external">事件</a>》、《<a href="http://www.cnblogs.com/hh54188/archive/2012/02/08/2343357.html" target="_blank" rel="external">javascript的冒泡和捕获</a>》，<a href="http://codepen.io/strick/pen/QjPRdj" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.17、jQuery的特点</strong></p>
<p>a. 一款轻量级的js库</p>
<p>b. 丰富快速的DOM选择器</p>
<p>c. 链式表达式</p>
<p>d. 事件、样式、动画等特效支持</p>
<p>e. Ajax操作封装，支持跨域</p>
<p>f. 跨浏览器兼容</p>
<p>g. 插件扩展开发</p>
<p>参考《<a href="http://www.cnblogs.com/sanmaospace/archive/2013/06/15/3137905.html" target="_blank" rel="external">JQuery特点、优缺点及其常用操作</a>》</p>
<p><strong>4.18、Ajax有哪些好处和弊端？</strong></p>
<p><strong>优点：</strong></p>
<p>a. 无刷新更新数据</p>
<p>b. 异步与服务器通信</p>
<p>c. 前端和后端负载平衡</p>
<p>d. 基于标准被广泛支持</p>
<p>e. 界面与应用分离</p>
<p><strong>缺点：</strong></p>
<p>a. AJAX干掉了Back和History功能，即对浏览器机制的破坏</p>
<p>b. AJAX的安全问题</p>
<p>c. 对搜索引擎支持较弱</p>
<p>d. 违背URL和资源定位的初衷</p>
<p>参考《<a href="http://www.cnblogs.com/sanmaospace/archive/2013/06/15/3137180.html" target="_blank" rel="external">AJAX工作原理及其优缺点</a>》</p>
<p><strong>4.19、null和undefined的区别？</strong></p>
<p><strong>null：</strong></p>
<p>a. null是一个表示”无”的对象，转为数值时为0</p>
<p>b. null表示”没有对象”，即该处不应该有值。</p>
<p><strong>undefined：</strong></p>
<p>a. undefined是一个表示”无”的原始值，转为数值时为NaN。</p>
<p>b. undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<p>参考《<a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">undefined与null的区别</a>》</p>
<p><strong>4.20、new操作符具体干了什么呢?</strong></p>
<p>a. 一个新对象被创建。它继承自函数原型</p>
<p>b. 构造函数被执行。执行的时候，相应的传参会被传入</p>
<p>c. 上下文(this)会被指定为这个新实例</p>
<p>d. 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果</p>
<p>参考《<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="external">new运算符</a>》</p>
<p><strong>4.21、js延迟加载的方式有哪些？</strong></p>
<p>a. 将script节点放置在最后<code>&lt;/body&gt;</code>之前</p>
<p>b. 使用script标签的defer和async属性，defer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载</p>
<p>c. 通过监听onload事件，动态添加script节点</p>
<p>d. 通过ajax下载js脚本，动态添加script节点</p>
<p>参考《<a href="http://blog.csdn.net/newborn2012/article/details/17057759" target="_blank" rel="external">javascript延迟加载方式</a>》</p>
<p><strong>4.22、如何解决跨域问题?</strong></p>
<p>a. <a href="http://segmentfault.com/a/1190000000718840" target="_blank" rel="external">JSONP</a>（JSON with Padding），填充式JSON</p>
<p>b. <a href="http://www.cnblogs.com/strick/p/3814872.html" target="_blank" rel="external">iframe</a>跨域</p>
<p>c. HTML5的window.<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">postMessage</a>方法跨域</p>
<p>d. 通过设置<a href="http://www.zhangsichu.com/blogview.asp?Content_Id=102" target="_blank" rel="external">img</a>的src属性，进行跨域请求</p>
<p>e. 跨域资源共享（<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a>），服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求</p>
<p><strong>4.23、documen.write和 innerHTML的区别</strong></p>
<p><strong>write：</strong></p>
<p>a. 改变 HTML 输出流</p>
<p>b. 当在文档加载之后使用 document.write()，这会覆盖该文档。例如onload事件中</p>
<p>c. 输入css的style标签能改变样式，例如document.write(“<em><code>&lt;style&gt;b{color:red;font-weight:bold;}&lt;/style&gt;</code></em>“);</p>
<p><strong>innerHTML：</strong></p>
<p>a. 改变 HTML 内容</p>
<p>b. 输入css的style标签不能改变样式。也是能改变样式的</p>
<p>参考《<a href="http://www.w3school.com.cn/js/js_htmldom_html.asp" target="_blank" rel="external">JavaScript HTML DOM - 改变 HTML</a>》</p>
<p><strong>4.24、哪些操作会造成内存泄漏？</strong></p>
<p>a. 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。</p>
<p>b. 在IE中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会处理。</p>
<p>c. 闭包可以维持函数内局部变量，使其得不到释放。</p>
<p>d. 在销毁对象的时候，要遍历属性中属性，依次删除，否则会泄漏。</p>
<p>参考《<a href="http://www.cnblogs.com/sprying/archive/2013/05/31/3109517.html" target="_blank" rel="external">js内存泄漏的几种情况</a>》、《<a href="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools/blob/master/md/Performance-Profiling/javascript-memory-profiling.md" target="_blank" rel="external">JavaScript内存分析</a>》</p>
<p><strong>4.25、JavaScript中的变量声明提升？</strong></p>
<p>函数声明和变量声明总是被JavaScript解释器隐式地提升到包含他们的作用域的最顶端。</p>
<p>function优先声明于var。</p>
<p>函数表达式中只会提升名称，函数体只有在执行到赋值语句时才会被赋值。</p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    bar();</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;<span class="comment">//等同于</span></div><div class="line">    <span class="keyword">var</span> x;</div><div class="line">    bar();</div><div class="line">    x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo(); <span class="comment">// TypeError "foo is not a function"</span></div><div class="line">    bar(); <span class="comment">// "this will run!"</span></div><div class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;<span class="comment">// 函数表达式被赋值给变量'foo'</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; &#125;<span class="comment">// 名为'bar'的函数声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</p>
<p><strong>4.26、如何判断当前脚本运行在浏览器还是node环境中？</strong></p>
<p>通过判断<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="external">Global</a>对象是否为window，如果是window，当前脚本运行在浏览器中</p>
<p><strong>4.27、什么是 “use strict”</strong></p>
<p>ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）</p>
<p>设立”严格模式”的目的，主要有以下几个：</p>
<p>a. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p>
<p>b. 消除代码运行的一些不安全之处，保证代码运行的安全；</p>
<p>c. 提高编译器效率，增加运行速度；</p>
<p>d. 为未来新版本的Javascript做好铺垫。</p>
<p>注：经过测试IE6,7,8,9均不支持严格模式</p>
<p>参考《<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="external">Javascript 严格模式详解</a>》</p>
<p><strong>4.28、eval是做什么的？</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="external">eval()</a>函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>
<p>eval()是一个顶级函数并且跟任何对象无关。</p>
<p>如果字符串表示了一个表达式，eval()会对表达式求值。如果参数表示了一个或多个JavaScript声明， 那么eval()会执行声明。</p>
<p><strong>4.29、JavaScript原型，原型链 ? </strong></p>
<p><strong>原型：</strong></p>
<p>a. 原型是一个对象，其他对象可以通过它实现属性继承。</p>
<p>b. 一个对象的真正原型是被对象内部的[[Prototype]]属性(property)所持有。浏览器支持非标准的访问器<strong>proto</strong>。</p>
<p>c. 在javascript中，一个对象就是任何无序键值对的集合，如果它不是一个主数据类型(undefined，null，boolean，number，string)，那它就是一个对象。</p>
<p><strong>原型链：</strong></p>
<p>a. 因为每个对象和原型都有一个原型(注:原型也是一个对象)，对象的原型指向对象的父，而父的原型又指向父的父，我们把这种通过原型层层连接起来的关系撑为原型链。</p>
<p>b. 这条链的末端一般总是默认的对象原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a.__proto__ = b; </div><div class="line">b.__proto__ = c; </div><div class="line">c.__proto__ = &#123;&#125;; <span class="comment">//default object </span></div><div class="line">&#123;&#125;.__proto__.__proto__; <span class="comment">//null</span></div></pre></td></tr></table></figure>
<p>参考《<a href="http://blog.jobbole.com/9648/" target="_blank" rel="external">理解JavaScript原型</a>》《<a href="http://www.cnblogs.com/strick/p/5838126.html" target="_blank" rel="external">原型</a>》</p>
<p><strong>4.30、画出此对象的内存图</strong></p>
<p><a href="http://codepen.io/strick/pen/MaMbew" target="_blank" rel="external">查看在线代码</a>。</p>
<p><strong>4.31、JQuery与jQuery UI 有啥区别？</strong></p>
<p>jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。</p>
<p>jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</p>
<p><strong>4.32、jQuery的源码看过吗？能不能简单说一下它的实现原理？</strong></p>
<p>jQuery给我们带来了一个简洁方便的编码模型(1&gt;创建jQuery对象;2&gt;直接使用jQuery对象的属性/方法/事件),</p>
<p>一个强悍的dom元素查找器($)，插件式编程接口(jQuery.fn)，以及插件初始化的”配置”对象思想</p>
<p>参考《<a href="http://ccvita.com/121.html" target="_blank" rel="external">jQuery工作原理解析以及源代码示例</a>》《<a href="http://www.cnblogs.com/aaronjs/category/511281.html" target="_blank" rel="external">jQuery系列分析</a>》</p>
<p><strong>4.33、jQuery 中如何将数组转化为json字符串</strong></p>
<p>在jQuery1.8.3中有个方法“parseJSON”，在这个方法中会做从string转换为json。</p>
<p>如果当前浏览器支持window.<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="external">JSON</a>，那就直接调用这个对象中的方法。</p>
<p>如果没有就使用( new Function( “return “ + data ) )();执行代码返回。</p>
<p><a href="http://www.cnblogs.com/shine-li/articles/2772737.html" target="_blank" rel="external">eval和new Function是有区别的</a>。</p>
<p><strong>4.34、请写出console.log中的内容</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="string">'hello'</span>;<span class="comment">//顶级作用域window下有个变量msg</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">great</span>(<span class="params">name, attr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">'david'</span>;</div><div class="line">    <span class="keyword">var</span> greating = msg + name + <span class="string">'!'</span>;</div><div class="line">    <span class="keyword">var</span> msg = <span class="string">'你好'</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="keyword">var</span> next = msg + <span class="string">'你的id是'</span> + i * <span class="number">2</span> + i;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    <span class="built_in">console</span>.log(greating);</div><div class="line">    <span class="built_in">console</span>.log(next);</div><div class="line">&#125;</div><div class="line">great(<span class="string">'Tom'</span>)</div></pre></td></tr></table></figure></p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</p>
<p><a href="http://codepen.io/strick/pen/zvVZZg" target="_blank" rel="external">查看在线代码</a>。</p>
<p>a. arguments[0]被覆盖了</p>
<p>b. msg出现了声明提升，可以查看4.25的例子</p>
<p>c. next中出现了隐式的类型转换</p>
<p><strong>4.35、请说明下下面代码的执行过程</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t=<span class="literal">true</span>;</div><div class="line"><span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        t=<span class="literal">false</span>;</div><div class="line">&#125;,<span class="number">1000</span>);</div><div class="line"><span class="keyword">while</span>(t)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">alert(<span class="string">'end'</span>);</div></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</p>
<p><a href="http://codepen.io/strick/pen/meZWBw" target="_blank" rel="external">查看在线代码</a>。</p>
<p>a. JavaScript引擎是单线程运行的，浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序</p>
<p>b. setTimeout是异步线程，需要等待js引擎处理完同步代码（while语句）之后才会执行，while语句直接是个死循环，js引擎没有空闲，不会执行下面的alert，也不会插入setTimeout。我在chrome中执行在线代码，最后浏览器是终止死循环执行alert。</p>
<p>c. JavaScript的工作机制是：当线程中没有执行任何同步代码的前提下才会执行异步代码，setTimeout是异步代码，所以setTimeout只能等js空闲才会执行，但死循环是永远不会空闲的，所以setTimeout也永远不会执行。</p>
<p><strong>4.36、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26</strong></p>
<p>参考《<a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp" target="_blank" rel="external">JavaScript Date 对象</a>》《<a href="http://www.cnblogs.com/strick/p/6362008.html" target="_blank" rel="external">日月如梭，玩转JavaScript日期</a>》</p>
<p><strong>4.37、Javascript中callee和caller的作用？</strong></p>
<p>arguments.<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments/callee" target="_blank" rel="external">callee</a>属性包含当前正在执行的函数。</p>
<p>Function.<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/caller" target="_blank" rel="external">caller</a>返回一个对函数的引用，该函数调用了当前函数。</p>
<p><strong>4.38、函数柯里化（Currying）如何理解？</strong></p>
<p>柯里化：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<p>柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。</p>
<p>参考《<a href="http://www.cnblogs.com/pigtail/p/3447660.html" target="_blank" rel="external">前端开发者进阶之函数柯里化Currying</a>》</p>
<p><strong>4.39、JS异步编程方式有几种？</strong></p>
<p>a. 回调函数</p>
<p>b. 事件监听</p>
<p>c. 发布订阅</p>
<p>d. promise</p>
<p>参考《<a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="external">异步编程的4种方法</a>》</p>
<p><strong>4.40、请说说在JavaScript引用类型和值类型的理解</strong></p>
<p>值类型：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。即Undefined、Null、Boolean、Number 和 String。</p>
<p>引用类型：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。即对象、数组</p>
<p>参考《<a href="http://www.w3school.com.cn/js/pro_js_value.asp" target="_blank" rel="external">ECMAScript 原始值和引用值</a>》，<a href="http://codepen.io/strick/pen/adzyMR" target="_blank" rel="external">查看在线代码</a>。下面有道题目可以研究下，具体流程参考《<a href="http://www.cnblogs.com/vajoy/p/3703859.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">理解js引用类型指针的工作方式</a>》</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;; </div><div class="line"><span class="keyword">var</span> b = a;  </div><div class="line">a.x = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;; </div><div class="line"><span class="built_in">console</span>.log(a.x);<span class="comment">// --&gt; undefined </span></div><div class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">// --&gt; [object Object]</span></div></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/yexiaochai/p/3899974.html" target="_blank" rel="external">【答阿里寒冬面试题】呵呵，大神的面试题就是好！</a></p>
<p><a href="http://www.cnblogs.com/yexiaochai/p/3163657.html" target="_blank" rel="external">做几道前端面试题休息休息吧</a></p>
<p><a href="http://www.cnblogs.com/yexiaochai/p/3154031.html" target="_blank" rel="external">来看一点CSS相关的吧</a></p>
<p><a href="http://www.cnblogs.com/yexiaochai/p/3152858.html" target="_blank" rel="external">前端面试题第二弹袭来，接招！</a></p>
<p><a href="http://www.w3cfuns.com/blog-5449691-5399942.html" target="_blank" rel="external">阿里巴巴校招笔试题整理（HTML+CSS篇）</a></p>
<p><a href="http://blog.csdn.net/kongjiea/article/details/46341575" target="_blank" rel="external">最全前端面试问题及答案总结</a></p>
<p><a href="http://segmentfault.com/a/1190000000465431" target="_blank" rel="external">2014年最新前端开发面试题</a></p>
<p><a href="http://www.cnblogs.com/QingFlye/p/4295417.html" target="_blank" rel="external">2014PPTV-题解</a></p>
<p><a href="http://www.cnblogs.com/leolai/archive/2013/04/29/3050908.html" target="_blank" rel="external">一些前端开发的笔试题及答案【编程题】</a></p>
<p><a href="http://www.cnblogs.com/jscode/archive/2012/07/10/2583856.html" target="_blank" rel="external">常见前端面试题之HTML/CSS部分</a></p>
<p><a href="http://www.cnblogs.com/coco1s/p/4034937.html" target="_blank" rel="external">BAT及各大互联网公司2014前端笔试面试题–Html,Css篇</a></p>
<p><a href="http://www.cnblogs.com/coco1s/p/4029708.html" target="_blank" rel="external">BAT及各大互联网公司2014前端笔试面试题–JavaScript篇【编程题】</a></p>
<p><a href="http://www.cnblogs.com/zichi/p/4359786.html" target="_blank" rel="external">10道javascript笔试题【编程题】</a></p>
<p>分类: <a href="http://www.cnblogs.com/strick/category/586146.html" target="_blank" rel="external">CSS</a>,<a href="http://www.cnblogs.com/strick/category/586127.html" target="_blank" rel="external">JavaScript</a>,<a href="http://www.cnblogs.com/strick/category/849620.html" target="_blank" rel="external">面试题目</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">CSS,JavaScript,面试题目</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/04/02/Others/前端面试题整理/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Others/前端模块化" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/02/Others/前端模块化/">前端模块化</a>
    </h1>
  

        
        <a href="/2017/04/02/Others/前端模块化/" class="archive-article-date">
  	<time datetime="2017-04-02T12:03:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-04-02</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><p>在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀</p>
<p>这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——<code>package</code>，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接<code>import</code>对应的package即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div></pre></td></tr></table></figure>
<p>遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。</p>
<p>一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了</p>
<p>规范形成的过程是痛苦的，前端的先驱在刀耕火种、茹毛饮血的阶段开始，发展到现在初具规模，简单了解一下这段不凡的历程</p>
<h3 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h3><p>我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在需要的以后夹在函数所在文件，调用函数就可以了</p>
<p>这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = &#123;</div><div class="line">    <span class="attr">var1</span>: <span class="number">1</span>,</div><div class="line"></div><div class="line">    <span class="attr">var2</span>: <span class="number">2</span>,</div><div class="line"></div><div class="line">    <span class="attr">fn1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">fn2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们在希望调用模块的时候引用对应文件，然后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myModule.fn2();</div></pre></td></tr></table></figure>
<p>这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系</p>
<p>看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myModel.var1 = <span class="number">100</span>;</div></pre></td></tr></table></figure>
<p>这样就会产生意外的安全问题</p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>可以通过立即执行函数，来达到隐藏细节的目的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> var1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> var2 = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">fn1</span>: fn1,</div><div class="line">        <span class="attr">fn2</span>: fn2</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>这样在模块外部无法修改我们没有暴露出来的变量、函数</p>
<p>上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：<code>CommonJS</code>和<code>AMD</code></p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>我们先从CommonJS谈起，因为在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，<a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="external">CommonJS规范</a>是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。</p>
<ol>
<li><p>定义模块<br>根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性</p>
</li>
<li><p>模块输出：<br>模块只有一个出口，<code>module.exports</code>对象，我们需要把模块希望输出的内容放入该对象</p>
</li>
<li><p>加载模块：<br>加载模块使用<code>require</code>方法，该方法读取一个文件并执行，返回文件内部的<code>module.exports</code>对象</p>
</li>
</ol>
<p>看个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//模块定义 myModel.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">'Byron'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFullName</span>(<span class="params">firstName</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(firstName + name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">printName</span>: printName,</div><div class="line">    <span class="attr">printFullName</span>: printFullName</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//加载模块</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> nameModule = <span class="built_in">require</span>(<span class="string">'./myModel.js'</span>);</div><div class="line"></div><div class="line">nameModule.printName();</div></pre></td></tr></table></figure>
<p>不同的实现对require时的路径有不同要求，一般情况可以省略<code>js</code>拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）</p>
<h2 id="尴尬的浏览器"><a href="#尴尬的浏览器" class="headerlink" title="尴尬的浏览器"></a>尴尬的浏览器</h2><p>仔细看上面的代码，会发现<code>require</code>是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。</p>
<p>这在服务器端实现很简单，也很自然，然而， 想在浏览器端实现问题却很多。</p>
<p>浏览器端，加载JavaScript最佳、最容易的方式是在document中插入<code>script</code> 标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。</p>
<p>解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</p>
<p>另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧：</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 即<code>Asynchronous Module Definition</code>，中文名是<strong>异步模块定义</strong>的意思。它是一个在浏览器端模块化开发的规范</p>
<p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎<code>RequireJS</code>，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p>
<p>requireJS主要解决两个问题</p>
<ol>
<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>
<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>
</ol>
<p>看一个使用requireJS的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义模块 myModule.js</span></div><div class="line">define([<span class="string">'dependency'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">'Byron'</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">printName</span>: printName</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 加载模块</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">my</span>)</span>&#123;</div></pre></td></tr></table></figure>
<p>　 my.printName();<br>});</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>requireJS定义了一个函数 define，它是全局变量，用来定义模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define(id?, dependencies?, factory);</div></pre></td></tr></table></figure>
<ol>
<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>
<li>dependencies：是一个当前模块依赖的模块名称数组</li>
<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>
</ol>
<p>在页面上使用<code>require</code>函数加载模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([dependencies], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>require()函数接受两个参数</p>
<ol>
<li>第一个参数是一个数组，表示所依赖的模块</li>
<li>第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>
</ol>
<p>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 即<code>Common Module Definition</code>通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>Sea.js 推崇一个模块一个文件，遵循统一的写法</p>
<h4 id="define"><a href="#define" class="headerlink" title="define"></a>define</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define(id?, deps?, factory)</div></pre></td></tr></table></figure>
<p>因为CMD推崇</p>
<ol>
<li>一个文件一个模块，所以经常就用文件名作为模块id</li>
<li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li>
</ol>
<p>factory有三个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span></div></pre></td></tr></table></figure>
<h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p>require 是 factory 函数的第一个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(id)</div></pre></td></tr></table></figure>
<p>require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口</p>
<h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>exports 是一个对象，用来向外提供模块接口</p>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义模块  myModule.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>)</div><div class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 加载模块</span></div><div class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="AMD与CMD区别"><a href="#AMD与CMD区别" class="headerlink" title="AMD与CMD区别"></a>AMD与CMD区别</h2><p>关于这两个的区别网上可以搜出一堆文章，简单总结一下</p>
<p>最明显的区别就是在模块定义时对依赖的处理不同</p>
<ol>
<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li>
<li>CMD推崇就近依赖，只有在用到某个模块的时候再去require</li>
</ol>
<p>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>
<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同</p>
<p>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略</p>
<p>为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）</p>
<p>同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行</p>
<p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的</p>
<p>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/seajs/seajs/issues/269" target="_blank" rel="external">从 CommonJS 到 Sea.js</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">Javascript模块化编程（一）：模块的写法</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="external">Javascript模块化编程（二）：AMD规范</a></p>
<p><a href="http://segmentfault.com/a/1190000000733959" target="_blank" rel="external">详解JavaScript模块化开发</a></p>
<p><a href="https://github.com/amdjs/amdjs-api/wiki/require" target="_blank" rel="external">require</a></p>
<p><a href="https://github.com/seajs/seajs/issues/266" target="_blank" rel="external">SeaJS API 快速参考</a></p>
<p><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="external">SeaJS 与 RequireJS 的异同</a></p>
<p>分类: <a href="http://www.cnblogs.com/dolphinX/category/517466.html" target="_blank" rel="external">Web综合</a>标签: <a href="http://www.cnblogs.com/dolphinX/tag/%E6%A8%A1%E5%9D%97%E5%8C%96/" target="_blank" rel="external">模块化</a>, <a href="http://www.cnblogs.com/dolphinX/tag/CMD/" target="_blank" rel="external">CMD</a>, <a href="http://www.cnblogs.com/dolphinX/tag/AMD/" target="_blank" rel="external">AMD</a>, <a href="http://www.cnblogs.com/dolphinX/tag/CommonJS/" target="_blank" rel="external">CommonJS</a>, <a href="http://www.cnblogs.com/dolphinX/tag/seajs/" target="_blank" rel="external">seajs</a>, <a href="http://www.cnblogs.com/dolphinX/tag/requireJS/" target="_blank" rel="external">requireJS</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">模块化,CMD,AMD,CommonJS,seajs,requireJS</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/04/02/Others/前端模块化/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-JavaScript/ECMAScript-2015" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/JavaScript/ECMAScript-2015/">ECMAScript-2015</a>
    </h1>
  

        
        <a href="/2017/03/31/JavaScript/ECMAScript-2015/" class="archive-article-date">
  	<time datetime="2017-03-31T14:59:11.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-31</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h2 id="1-ECMAScript-6简介"><a href="#1-ECMAScript-6简介" class="headerlink" title="1.  ECMAScript 6简介"></a>1.  ECMAScript 6简介</h2><p><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="external">详细内容</a></p>
<h2 id="2-let-和-const-命令"><a href="#2-let-和-const-命令" class="headerlink" title="2.  let 和 const 命令"></a>2.  let 和 const 命令</h2><p><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="external">详细内容</a></p>
<h2 id="3-变量的解构赋值"><a href="#3-变量的解构赋值" class="headerlink" title="3.  变量的解构赋值"></a>3.  变量的解构赋值</h2><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="external">详细内容</a></p>
<h2 id="4-字符串的扩展"><a href="#4-字符串的扩展" class="headerlink" title="4.  字符串的扩展"></a>4.  字符串的扩展</h2><p><a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="external">详细内容</a></p>
<h2 id="5-正则的扩展"><a href="#5-正则的扩展" class="headerlink" title="5.  正则的扩展"></a>5.  正则的扩展</h2><p><a href="http://es6.ruanyifeng.com/#docs/regex" target="_blank" rel="external">详细内容</a></p>
<h2 id="6-数值的扩展"><a href="#6-数值的扩展" class="headerlink" title="6.  数值的扩展"></a>6.  数值的扩展</h2><p><a href="http://es6.ruanyifeng.com/#docs/number" target="_blank" rel="external">详细内容</a></p>
<h2 id="7-数组的扩展"><a href="#7-数组的扩展" class="headerlink" title="7.  数组的扩展"></a>7.  数组的扩展</h2><p><a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="external">详细内容</a></p>
<h3 id="1-Array-from"><a href="#1-Array-from" class="headerlink" title="1. Array.from()"></a>1. Array.from()</h3><blockquote>
<p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
</blockquote>
<ol>
<li>参数一：要转换的对象或者字符串</li>
<li>参数二：（可选）一个函数，类似数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</li>
<li>参数三：（可选）如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(<span class="string">'hello'</span>)</div><div class="line"><span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"><span class="built_in">Array</span>.from(namesSet) <span class="comment">// ['a', 'b']</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div></pre></td></tr></table></figure>
<p>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> toArray = <span class="function">(<span class="params">(</span>) =&gt;</span></div><div class="line">  <span class="built_in">Array</span>.from ? <span class="built_in">Array</span>.from : <span class="function"><span class="params">obj</span> =&gt;</span> [].slice.call(obj)</div><div class="line">)();</div></pre></td></tr></table></figure>
<h3 id="2-Array-of"><a href="#2-Array-of" class="headerlink" title="2. Array.of()"></a>2. Array.of()</h3><blockquote>
<p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></div></pre></td></tr></table></figure>
<p>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p>Array.of方法可以用下面的代码模拟实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-数组实例的copyWithin"><a href="#3-数组实例的copyWithin" class="headerlink" title="3. 数组实例的copyWithin()"></a>3. 数组实例的copyWithin()</h3><blockquote>
<p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</div></pre></td></tr></table></figure>
<ol>
<li>参数一：target（必需）：从该位置开始替换数据。</li>
<li>参数二：start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>参数三：end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ol>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<p>下面是更多例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将3号位复制到0号位</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>)</div><div class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// 将3号位复制到0号位</span></div><div class="line">[].copyWithin.call(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></div><div class="line"><span class="keyword">var</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// 对于没有部署TypedArray的copyWithin方法的平台</span></div><div class="line"><span class="comment">// 需要采用下面的写法</span></div><div class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<h3 id="4-数组实例的find-和findIndex"><a href="#4-数组实例的find-和findIndex" class="headerlink" title="4. 数组实例的find()和findIndex()"></a>4. 数组实例的find()和findIndex()</h3><blockquote>
<p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</div><div class="line">&#125;) <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<blockquote>
<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</div><div class="line">&#125;) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>两个方法参数</p>
<ol>
<li>参数一：回调函数<br> 回调函数可以接收三个参数<ol>
<li>参数一：当前值value</li>
<li>参数二：当前的位置index</li>
<li>参数三：原数组array</li>
</ol>
</li>
<li>参数二：（可选）thisArg用来绑定回调函数内部的this </li>
</ol>
<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>IndexOf</code>方法的不足。下面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</div><div class="line"><span class="comment">// -1</span></div><div class="line"></div><div class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</div><div class="line"><span class="comment">// 0</span></div></pre></td></tr></table></figure>
<h3 id="5-数组实例的fill"><a href="#5-数组实例的fill" class="headerlink" title="5. 数组实例的fill()"></a>5. 数组实例的fill()</h3><blockquote>
<p><code>fill</code>方法使用给定值，填充一个数组。</p>
</blockquote>
<ol>
<li>参数一：填充的值</li>
<li>参数二：（可选）填充的起始位置</li>
<li>参数三：（可选）填充的结束位置，不包括该位置</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</div><div class="line"><span class="comment">// [7, 7, 7]</span></div></pre></td></tr></table></figure>
<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="comment">// ['a', 7, 'c']</span></div></pre></td></tr></table></figure>
<p>上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。</p>
<h3 id="6-数组实例的entries-，keys-和values"><a href="#6-数组实例的entries-，keys-和values" class="headerlink" title="6. 数组实例的entries()，keys()和values()"></a>6. 数组实例的entries()，keys()和values()</h3><blockquote>
<p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div></pre></td></tr></table></figure>
<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">let</span> entries = letter.entries();</div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></div></pre></td></tr></table></figure>
<h3 id="7-数组实例的includes"><a href="#7-数组实例的includes" class="headerlink" title="7. 数组实例的includes()"></a>7. 数组实例的includes()</h3><blockquote>
<p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但Babel转码器已经支持。</p>
</blockquote>
<ol>
<li>参数一：要查找的值</li>
<li>参数二：（可选）搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度，则会重置为从0开始</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> contains = <span class="function">(<span class="params">(</span>) =&gt;</span></div><div class="line">  <span class="built_in">Array</span>.prototype.includes</div><div class="line">    ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</div><div class="line">    : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</div><div class="line">)();</div><div class="line">contains([<span class="string">"foo"</span>, <span class="string">"bar"</span>], <span class="string">"baz"</span>); <span class="comment">// =&gt; false</span></div></pre></td></tr></table></figure>
<p>另外，Map和Set数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>
</ul>
<h3 id="8-数组的空位"><a href="#8-数组的空位" class="headerlink" title="8. 数组的空位"></a>8. 数组的空位</h3><blockquote>
<p>数组的空位指，数组的某一个位置没有任何值。<br><strong>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。</strong></p>
</blockquote>
<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// forEach方法</span></div><div class="line">[,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// filter方法</span></div><div class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></div><div class="line"></div><div class="line"><span class="comment">// every方法</span></div><div class="line">[,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// some方法</span></div><div class="line">[,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// map方法</span></div><div class="line">[,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></div><div class="line"></div><div class="line"><span class="comment">// join方法</span></div><div class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></div><div class="line"></div><div class="line"><span class="comment">// toString方法</span></div><div class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></div></pre></td></tr></table></figure>
<p>ES6则是明确将空位转为<code>undefined</code>。</p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</div><div class="line"><span class="comment">// [ "a", undefined, "b" ]</span></div></pre></td></tr></table></figure>
<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</div><div class="line"><span class="comment">// [ "a", undefined, "b" ]</span></div></pre></td></tr></table></figure>
<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></div></pre></td></tr></table></figure>
<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></div></pre></td></tr></table></figure>
<p><code>for...of</code>循环也会遍历空位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [, ,];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entries()</span></div><div class="line">[...[,<span class="string">'a'</span>].entries()] <span class="comment">// [[0,undefined], [1,"a"]]</span></div><div class="line"></div><div class="line"><span class="comment">// keys()</span></div><div class="line">[...[,<span class="string">'a'</span>].keys()] <span class="comment">// [0,1]</span></div><div class="line"></div><div class="line"><span class="comment">// values()</span></div><div class="line">[...[,<span class="string">'a'</span>].values()] <span class="comment">// [undefined,"a"]</span></div><div class="line"></div><div class="line"><span class="comment">// find()</span></div><div class="line">[,<span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// findIndex()</span></div><div class="line">[,<span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h2 id="8-函数的扩展"><a href="#8-函数的扩展" class="headerlink" title="8.  函数的扩展"></a>8.  函数的扩展</h2><p><a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="external">详细内容</a></p>
<h3 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1. 函数参数的默认值"></a>1. 函数参数的默认值</h3><h3 id="2-rest参数"><a href="#2-rest参数" class="headerlink" title="2. rest参数"></a>2. rest参数</h3><h3 id="3-扩展运算符"><a href="#3-扩展运算符" class="headerlink" title="3. 扩展运算符"></a>3. 扩展运算符</h3><h3 id="4-严格模式"><a href="#4-严格模式" class="headerlink" title="4. 严格模式"></a>4. 严格模式</h3><h3 id="5-name-属性"><a href="#5-name-属性" class="headerlink" title="5. name 属性"></a>5. name 属性</h3><h3 id="6-箭头函数"><a href="#6-箭头函数" class="headerlink" title="6. 箭头函数"></a>6. 箭头函数</h3><h3 id="7-绑定-this"><a href="#7-绑定-this" class="headerlink" title="7. 绑定 this"></a>7. 绑定 this</h3><h3 id="8-尾调用优化"><a href="#8-尾调用优化" class="headerlink" title="8. 尾调用优化"></a>8. 尾调用优化</h3><h3 id="9-函数参数的尾逗号"><a href="#9-函数参数的尾逗号" class="headerlink" title="9. 函数参数的尾逗号"></a>9. 函数参数的尾逗号</h3><h2 id="9-对象的扩展"><a href="#9-对象的扩展" class="headerlink" title="9.  对象的扩展"></a>9.  对象的扩展</h2><p><a href="http://es6.ruanyifeng.com/#docs/object" target="_blank" rel="external">详细内容</a></p>
<h2 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10.  Symbol"></a>10.  Symbol</h2><p><a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="external">详细内容</a></p>
<h2 id="11-Set-和-Map-数据结构"><a href="#11-Set-和-Map-数据结构" class="headerlink" title="11.  Set 和 Map 数据结构"></a>11.  Set 和 Map 数据结构</h2><p><a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="external">详细内容</a></p>
<h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><blockquote>
<p>ES6 提供了新的数据结构 Set。它类似于数组，<strong>但是成员的值都是唯一的，没有重复的值。</strong></p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 3 5 4</span></div></pre></td></tr></table></figure>
<p>上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>
<p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例一</span></div><div class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</div><div class="line">[...set]</div><div class="line"><span class="comment">// [1, 2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="comment">// 例二</span></div><div class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</div><div class="line">items.size <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="comment">// 例三</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">divs</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [...document.querySelectorAll(<span class="string">'div'</span>)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(divs());</div><div class="line">set.size <span class="comment">// 56</span></div><div class="line"></div><div class="line"><span class="comment">// 类似于</span></div><div class="line">divs().forEach(<span class="function"><span class="params">div</span> =&gt;</span> set.add(div));</div><div class="line">set.size <span class="comment">// 56</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在Set内部，两个NaN是相等。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span>;</div><div class="line">set.add(a);</div><div class="line">set.add(b);</div><div class="line">set <span class="comment">// Set &#123;NaN&#125;</span></div></pre></td></tr></table></figure>
<h4 id="2-Set实例的属性和方法"><a href="#2-Set实例的属性和方法" class="headerlink" title="2. Set实例的属性和方法"></a>2. Set实例的属性和方法</h4><p>Set结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p><code>Array.from</code>方法可以将Set结构转为数组。</p>
<p>这就提供了去除数组重复成员的另一种方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</div><div class="line">&#125;</div><div class="line"></div><div class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<h4 id="3-遍历操作"><a href="#3-遍历操作" class="headerlink" title="3. 遍历操作"></a>3. 遍历操作</h4><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"><span class="comment">// red</span></div><div class="line"><span class="comment">// green</span></div><div class="line"><span class="comment">// blue</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"><span class="comment">// red</span></div><div class="line"><span class="comment">// green</span></div><div class="line"><span class="comment">// blue</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"><span class="comment">// ["red", "red"]</span></div><div class="line"><span class="comment">// ["green", "green"]</span></div><div class="line"><span class="comment">// ["blue", "blue"]</span></div></pre></td></tr></table></figure>
<p>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历Set。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"><span class="comment">// red</span></div><div class="line"><span class="comment">// green</span></div><div class="line"><span class="comment">// blue</span></div></pre></td></tr></table></figure>
<p><strong>（2）<code>forEach()</code></strong></p>
<p>Set结构的实例的<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>
<ol>
<li>参数一：处理函数<br> 函数有三个参数<ol>
<li>参数一：value</li>
<li>参数二：key</li>
<li>参数三：set</li>
</ol>
</li>
<li>参数二：thisArg，绑定函数内的this对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(value * <span class="number">2</span>) )</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="comment">// 6</span></div></pre></td></tr></table></figure>
<p><strong>（3）遍历的应用</strong></p>
<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于Set结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</div><div class="line"><span class="keyword">let</span> arr = [...set];</div><div class="line"><span class="comment">// ['red', 'green', 'blue']</span></div></pre></td></tr></table></figure>
<p>数组的<code>map</code>和<code>filter</code>方法也可以用于Set了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</div><div class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</div><div class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></div></pre></td></tr></table></figure>
<p>因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 并集</span></div><div class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</div><div class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 交集</span></div><div class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</div><div class="line"><span class="comment">// set &#123;2, 3&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 差集</span></div><div class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</div><div class="line"><span class="comment">// Set &#123;1&#125;</span></div></pre></td></tr></table></figure>
<p>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用<code>Array.from</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</div><div class="line"><span class="comment">// set的值是2, 4, 6</span></div><div class="line"></div><div class="line"><span class="comment">// 方法二</span></div><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, val =&gt; val * <span class="number">2</span>));</div><div class="line"><span class="comment">// set的值是2, 4, 6</span></div></pre></td></tr></table></figure>
<h3 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h3><blockquote>
<p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>
<p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。<br>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</div><div class="line">ws.add(<span class="number">1</span>)</div><div class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></div><div class="line">ws.add(<span class="built_in">Symbol</span>())</div><div class="line"><span class="comment">// TypeError: invalid value used in weak set</span></div></pre></td></tr></table></figure>
<p>上面代码试图向WeakSet添加一个数值和<code>Symbol</code>值，结果报错，因为WeakSet只能放置对象。</p>
<p>WeakSet结构有以下三个方法。</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向WeakSet实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除WeakSet实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在WeakSet实例之中。</li>
</ul>
<p>WeakSet没有<code>size</code>属性，没有办法遍历它的成员。</p>
<p>WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h3 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h3><h4 id="1-Map结构的目的和基本用法"><a href="#1-Map结构的目的和基本用法" class="headerlink" title="1. Map结构的目的和基本用法"></a>1. Map结构的目的和基本用法</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>
<p>作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</div><div class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</div><div class="line">]);</div><div class="line"></div><div class="line">map.size <span class="comment">// 2</span></div><div class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></div><div class="line">map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span></div><div class="line">map.has(<span class="string">'title'</span>) <span class="comment">// true</span></div><div class="line">map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></div></pre></td></tr></table></figure>
<p>上面代码在新建Map实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>
<p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = [</div><div class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</div><div class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</div><div class="line">];</div><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">items.forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.set(key, value));</div></pre></td></tr></table></figure>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<p>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</div><div class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p><strong>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</strong></p>
<p><strong>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括<code>0</code>和<code>-0</code>。另外，虽然<code>NaN</code>不严格相等于自身，但Map将其视为同一个键。</strong></p>
<h4 id="2-实例的属性和操作方法"><a href="#2-实例的属性和操作方法" class="headerlink" title="2. 实例的属性和操作方法"></a>2. 实例的属性和操作方法</h4><p>Map结构的实例有以下属性和操作方法。</p>
<p><strong>（1）size属性</strong></p>
<p><code>size</code>属性返回Map结构的成员总数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</div><div class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line">map.size <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p><strong>（2）set(key, value)</strong></p>
<p><code>set</code>方法设置<code>key</code>所对应的键值，然后返回整个Map结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">m.set(<span class="string">"edition"</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></div><div class="line">m.set(<span class="number">262</span>, <span class="string">"standard"</span>)     <span class="comment">// 键是数值</span></div><div class="line">m.set(<span class="literal">undefined</span>, <span class="string">"nah"</span>)    <span class="comment">// 键是undefined</span></div></pre></td></tr></table></figure>
<p><code>set</code>方法返回的是Map本身，因此可以采用<strong>链式</strong>写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</div><div class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</div><div class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</div></pre></td></tr></table></figure>
<p><strong>（3）get(key)</strong></p>
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">"hello"</span>);&#125;</div><div class="line">m.set(hello, <span class="string">"Hello ES6!"</span>) <span class="comment">// 键是函数</span></div><div class="line"></div><div class="line">m.get(hello)  <span class="comment">// Hello ES6!</span></div></pre></td></tr></table></figure>
<p><strong>（4）has(key)</strong></p>
<p><code>has</code>方法返回一个布尔值，表示某个键是否在Map数据结构中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">m.set(<span class="string">"edition"</span>, <span class="number">6</span>);</div><div class="line">m.set(<span class="number">262</span>, <span class="string">"standard"</span>);</div><div class="line">m.set(<span class="literal">undefined</span>, <span class="string">"nah"</span>);</div><div class="line"></div><div class="line">m.has(<span class="string">"edition"</span>)     <span class="comment">// true</span></div><div class="line">m.has(<span class="string">"years"</span>)       <span class="comment">// false</span></div><div class="line">m.has(<span class="number">262</span>)           <span class="comment">// true</span></div><div class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong>（5）delete(key)</strong></p>
<p><code>delete</code>方法删除某个键，返回true。如果删除失败，返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">m.set(<span class="literal">undefined</span>, <span class="string">"nah"</span>);</div><div class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></div><div class="line"></div><div class="line">m.delete(<span class="literal">undefined</span>)</div><div class="line">m.has(<span class="literal">undefined</span>)       <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><strong>（6）clear()</strong></p>
<p><code>clear</code>方法清除所有成员，没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</div><div class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line">map.size <span class="comment">// 2</span></div><div class="line">map.clear()</div><div class="line">map.size <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<h4 id="3-遍历方法"><a href="#3-遍历方法" class="headerlink" title="3. 遍历方法"></a>3. 遍历方法</h4><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器。</li>
<li><code>values()</code>：返回键值的遍历器。</li>
<li><code>entries()</code>：返回所有成员的遍历器。</li>
<li><code>forEach()</code>：遍历Map的所有成员。</li>
</ul>
<p>需要特别注意的是，Map的遍历顺序就是插入顺序。</p>
<p>下面是使用实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="string">'F'</span>, <span class="string">'no'</span>],</div><div class="line">  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "F"</span></div><div class="line"><span class="comment">// "T"</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "no"</span></div><div class="line"><span class="comment">// "yes"</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "F" "no"</span></div><div class="line"><span class="comment">// "T" "yes"</span></div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于使用map.entries()</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码最后的那个例子，表示Map结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">map[<span class="built_in">Symbol</span>.iterator] === map.entries</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（<code>...</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</div><div class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</div><div class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</div><div class="line">]);</div><div class="line"></div><div class="line">[...map.keys()]</div><div class="line"><span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line">[...map.values()]</div><div class="line"><span class="comment">// ['one', 'two', 'three']</span></div><div class="line"></div><div class="line">[...map.entries()]</div><div class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></div><div class="line"></div><div class="line">[...map]</div><div class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></div></pre></td></tr></table></figure>
<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现Map的遍历和过滤（Map本身没有<code>map</code>和<code>filter</code>方法）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</div><div class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</div><div class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</div><div class="line">  [...map0].filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</div><div class="line">);</div><div class="line"><span class="comment">// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(</div><div class="line">  [...map0].map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">'_'</span> + v])</div><div class="line">    );</div><div class="line"><span class="comment">// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></div></pre></td></tr></table></figure>
<p>此外，Map还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reporter = &#123;</div><div class="line">  <span class="attr">report</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.report(key, value);</div><div class="line">&#125;, reporter);</div></pre></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>
<h4 id="4-与其他数据结构的互相转换"><a href="#4-与其他数据结构的互相转换" class="headerlink" title="4. 与其他数据结构的互相转换"></a>4. 与其他数据结构的互相转换</h4><p><strong>（1）Map转为数组</strong></p>
<p>前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]);</div><div class="line">[...myMap]</div><div class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></div></pre></td></tr></table></figure>
<p><strong>（2）数组转为Map</strong></p>
<p>将数组转入Map构造函数，就可以转为Map。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="literal">true</span>, <span class="number">7</span>], [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]]])</div><div class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125;</span></div></pre></td></tr></table></figure>
<p><strong>（3）Map转为对象</strong></p>
<p>如果所有Map的键都是字符串，它可以转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</div><div class="line">    obj[k] = v;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);</div><div class="line">strMapToObj(myMap)</div><div class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></div></pre></td></tr></table></figure>
<p><strong>（4）对象转为Map</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</div><div class="line">    strMap.set(k, obj[k]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> strMap;</div><div class="line">&#125;</div><div class="line"></div><div class="line">objToStrMap(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</div><div class="line"><span class="comment">// [ [ 'yes', true ], [ 'no', false ] ]</span></div></pre></td></tr></table></figure>
<p><strong>（5）Map转为JSON</strong></p>
<p>Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);</div><div class="line">strMapToJson(myMap)</div><div class="line"><span class="comment">// '&#123;"yes":true,"no":false&#125;'</span></div></pre></td></tr></table></figure>
<p>另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]);</div><div class="line">mapToArrayJson(myMap)</div><div class="line"><span class="comment">// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span></div></pre></td></tr></table></figure>
<p><strong>（6）JSON转为Map</strong></p>
<p>JSON转为Map，正常情况下，所有键名都是字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr));</div><div class="line">&#125;</div><div class="line"></div><div class="line">jsonToStrMap(<span class="string">'&#123;"yes":true,"no":false&#125;'</span>)</div><div class="line"><span class="comment">// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125;</span></div></pre></td></tr></table></figure>
<p>但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToMap</span>(<span class="params">jsonStr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(jsonStr));</div><div class="line">&#125;</div><div class="line"></div><div class="line">jsonToMap(<span class="string">'[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span>)</div><div class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125;</span></div></pre></td></tr></table></figure>
<h3 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4.WeakMap"></a>4.WeakMap</h3><blockquote>
<p><code>WeakMap</code>结构与<code>Map</code>结构基本类似，唯一的区别是它只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>
</blockquote>
<p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有<code>key()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性；二是无法清空，即不支持<code>clear</code>方法。这与<code>WeakMap</code>的键不被计入引用、被垃圾回收机制忽略有关。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<h2 id="12-Proxy"><a href="#12-Proxy" class="headerlink" title="12.  Proxy"></a>12.  Proxy</h2><p><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="external">详细内容</a></p>
<h2 id="13-Reflect"><a href="#13-Reflect" class="headerlink" title="13.  Reflect"></a>13.  Reflect</h2><p><a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="external">详细内容</a></p>
<h2 id="14-Promise-对象"><a href="#14-Promise-对象" class="headerlink" title="14.  Promise 对象"></a>14.  Promise 对象</h2><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">详细内容</a></p>
<h2 id="15-Iterator-和-for…of-循环"><a href="#15-Iterator-和-for…of-循环" class="headerlink" title="15.  Iterator 和 for…of 循环"></a>15.  Iterator 和 for…of 循环</h2><p><a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="external">详细内容</a></p>
<h2 id="16-Generator-函数的语法"><a href="#16-Generator-函数的语法" class="headerlink" title="16.  Generator 函数的语法"></a>16.  Generator 函数的语法</h2><p><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">详细内容</a></p>
<h2 id="17-Generator-函数的异步应用"><a href="#17-Generator-函数的异步应用" class="headerlink" title="17.  Generator 函数的异步应用"></a>17.  Generator 函数的异步应用</h2><p><a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="external">详细内容</a></p>
<h2 id="18-async-函数"><a href="#18-async-函数" class="headerlink" title="18.  async 函数"></a>18.  async 函数</h2><p><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">详细内容</a></p>
<h2 id="19-Class"><a href="#19-Class" class="headerlink" title="19.  Class"></a>19.  Class</h2><p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="external">详细内容</a></p>
<h2 id="20-Decorator"><a href="#20-Decorator" class="headerlink" title="20.  Decorator"></a>20.  Decorator</h2><p><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="external">详细内容</a></p>
<h2 id="21-Module-的语法"><a href="#21-Module-的语法" class="headerlink" title="21.  Module 的语法"></a>21.  Module 的语法</h2><p><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">详细内容</a></p>
<h2 id="22-Module-的加载实现"><a href="#22-Module-的加载实现" class="headerlink" title="22.  Module 的加载实现"></a>22.  Module 的加载实现</h2><p><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="external">详细内容</a></p>
<h2 id="23-编程风格"><a href="#23-编程风格" class="headerlink" title="23.  编程风格"></a>23.  编程风格</h2><p><a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="external">详细内容</a></p>
<h2 id="24-读懂规格"><a href="#24-读懂规格" class="headerlink" title="24.  读懂规格"></a>24.  读懂规格</h2><p><a href="http://es6.ruanyifeng.com/#docs/spec" target="_blank" rel="external">详细内容</a></p>
<h2 id="25-二进制数组"><a href="#25-二进制数组" class="headerlink" title="25.  二进制数组"></a>25.  二进制数组</h2><p><a href="http://es6.ruanyifeng.com/#docs/arraybuffer" target="_blank" rel="external">详细内容</a></p>
<h2 id="26-SIMD"><a href="#26-SIMD" class="headerlink" title="26.  SIMD"></a>26.  SIMD</h2><p><a href="http://es6.ruanyifeng.com/#docs/simd" target="_blank" rel="external">详细内容</a></p>
<h2 id="27-参考链接"><a href="#27-参考链接" class="headerlink" title="27.  参考链接"></a>27.  参考链接</h2><p><a href="http://es6.ruanyifeng.com/#docs/reference" target="_blank" rel="external">详细内容</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">javascript,es6</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/31/JavaScript/ECMAScript-2015/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Framework/Webpack/Gulp和Webpack对比" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/Framework/Webpack/Gulp和Webpack对比/">Gulp和Webpack对比</a>
    </h1>
  

        
        <a href="/2017/03/18/Framework/Webpack/Gulp和Webpack对比/" class="archive-article-date">
  	<time datetime="2017-03-18T13:50:52.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-18</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文  <a href="http://chping.website/2016/10/18/gulp和webpack对比/">http://chping.website/2016/10/18/gulp和webpack对比/</a></p>
<p>在现在的前端开发中，前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等等一些原本后端的思想开始逐渐渗透到“大前端”的开发中。前端开发过程越来越繁琐，当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且Webapp通常是一个单页面应用(SPA)，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。</p>
        
          <a class="article-more-a" href="/2017/03/18/Framework/Webpack/Gulp和Webpack对比/#more">more >></a>
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">Webpack,Gulp</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/18/Framework/Webpack/Gulp和Webpack对比/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Others/BFC神奇背后的原理" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/Others/BFC神奇背后的原理/">Gulp和Webpack对比</a>
    </h1>
  

        
        <a href="/2017/03/18/Others/BFC神奇背后的原理/" class="archive-article-date">
  	<time datetime="2017-03-18T13:50:52.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-18</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文： <a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">前端精选文摘：BFC 神奇背后的原理</a></p>
<p>　　BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清浮动，防止 margin 重叠等）。虽然我知道如何利用 BFC 解决这些问题，但当别人问我 BFC 是什么，我还是不能很有底气地解释清楚。于是这两天仔细阅读了CSS2.1 spec 和许多文章来全面地理解BFC。</p>
<h3 id="一、BFC是什么？"><a href="#一、BFC是什么？" class="headerlink" title="一、BFC是什么？"></a>一、BFC是什么？</h3><p>　　在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。</p>
<h4 id="Box-CSS布局的基本单位"><a href="#Box-CSS布局的基本单位" class="headerlink" title="Box: CSS布局的基本单位"></a>Box: CSS布局的基本单位</h4><p>　　Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p>
<ul>
<li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li>
<li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li>
<li>run-in box: css3 中才有， 这儿先不讲了。</li>
</ul>
<h4 id="Formatting-context"><a href="#Formatting-context" class="headerlink" title="Formatting context"></a>Formatting context</h4><p>　　Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p>
<p>　　CSS2.1 中只有 <code>BFC</code>和 <code>IFC</code>, <strong><a href="http://www.cnblogs.com/lhb25/category/146075.html" target="_blank" rel="external">CSS3</a> </strong>中还增加了 <code>GFC</code>和 <code>FFC。</code></p>
<h4 id="BFC-定义"><a href="#BFC-定义" class="headerlink" title="BFC 定义"></a>BFC 定义</h4><p>　　BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h4 id="BFC布局规则："><a href="#BFC布局规则：" class="headerlink" title="BFC布局规则："></a>BFC布局规则：</h4><ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
<h3 id="二、哪些元素会生成BFC"><a href="#二、哪些元素会生成BFC" class="headerlink" title="二、哪些元素会生成BFC?"></a>二、哪些元素会生成BFC?</h3><ol>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ol>
<h3 id="三、BFC的作用及原理"><a href="#三、BFC的作用及原理" class="headerlink" title="三、BFC的作用及原理"></a>三、BFC的作用及原理</h3><h4 id="1-自适应两栏布局"><a href="#1-自适应两栏布局" class="headerlink" title="1. 自适应两栏布局"></a>1. 自适应两栏布局</h4><p>　　代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">body</span> &#123;</div><div class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">        <span class="attribute">position</span>: relative;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="selector-class">.aside</span> &#123;</div><div class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">        <span class="attribute">height</span>: <span class="number">150px</span>;</div><div class="line">        <span class="attribute">float</span>: left;</div><div class="line">        <span class="attribute">background</span>: <span class="number">#f66</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="selector-class">.main</span> &#123;</div><div class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　页面：</p>
<p>  <img src="/2017/03/18/Others/BFC神奇背后的原理/4dca44a927d4c1ffc30e3ae5f53a0b79.png" alt=""></p>
<p>　　根据<code>BFC</code>布局规则第3条：</p>
<blockquote>
<p>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p>
</blockquote>
<p>　　因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。</p>
<p>　　根据<code>BFC</code>布局规则第四条：</p>
<blockquote>
<p><code>BFC</code>的区域不会与<code>float box</code>重叠。</p>
</blockquote>
<p>　　我们可以通过通过触发main生成<code>BFC</code>， 来实现自适应两栏布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.main</span> &#123;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　当触发main生成<code>BFC</code>后，这个新的<code>BFC</code>不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：</p>
<h4 id="2-清除内部浮动"><a href="#2-清除内部浮动" class="headerlink" title="2. 清除内部浮动"></a>2. 清除内部浮动</h4><p>　　代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-class">.par</span> &#123;</div><div class="line">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fcc</span>;</div><div class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="selector-class">.child</span> &#123;</div><div class="line">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f66</span>;</div><div class="line">        <span class="attribute">width</span>:<span class="number">100px</span>;</div><div class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">        <span class="attribute">float</span>: left;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"par"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　页面：</p>
<p>  <img src="/2017/03/18/Others/BFC神奇背后的原理/t016035b58195e7909a.png" alt=""></p>
<p>　　根据<code>BFC</code>布局规则第六条：</p>
<blockquote>
<p>计算<code>BFC</code>的高度时，浮动元素也参与计算</p>
</blockquote>
<p>　　为达到清除内部浮动，我们可以触发par生成<code>BFC</code>，那么par在计算高度时，par内部的浮动元素child也会参与计算。</p>
<p>　　代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.par</span> &#123;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　效果如下：<br>　　 <img src="/2017/03/18/Others/BFC神奇背后的原理/t016bbbe5236ef1ffd5.png" alt=""></p>
<h4 id="3-防止垂直-margin-重叠"><a href="#3-防止垂直-margin-重叠" class="headerlink" title="3. 防止垂直 margin 重叠"></a>3. 防止垂直 margin 重叠</h4><p>　　代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">p</span> &#123;</div><div class="line">        <span class="attribute">color</span>: <span class="number">#f55</span>;</div><div class="line">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</div><div class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</div><div class="line">        <span class="attribute">text-align</span>:center;</div><div class="line">        <span class="attribute">margin</span>: <span class="number">100px</span>;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hehe<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　页面：</p>
<p><img src="/2017/03/18/Others/BFC神奇背后的原理/t01b47b8b7d153c07cc.png" alt=""></p>
<p>　　两个p之间的距离为100px，发送了margin重叠。<br>　　根据BFC布局规则第二条：</p>
<blockquote>
<p><code>Box</code>垂直方向的距离由margin决定。属于同一个<code>BFC</code>的两个相邻<code>Box</code>的margin会发生重叠</p>
</blockquote>
<p>　　我们可以在p外面包裹一层容器，并触发该容器生成一个<code>BFC</code>。那么两个P便不属于同一个<code>BFC</code>，就不会发生margin重叠了。<br>　　代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-class">.wrap</span> &#123;</div><div class="line">        <span class="attribute">overflow</span>: hidden;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-tag">p</span> &#123;</div><div class="line">        <span class="attribute">color</span>: <span class="number">#f55</span>;</div><div class="line">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</div><div class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</div><div class="line">        <span class="attribute">text-align</span>:center;</div><div class="line">        <span class="attribute">margin</span>: <span class="number">100px</span>;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hehe<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　效果如下:</p>
<p><img src="/2017/03/18/Others/BFC神奇背后的原理/t0118d1d2badbb00521.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　其实以上的几个例子都体现了<code>BFC</code>布局规则第五条：</p>
<blockquote>
<p><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
</blockquote>
<p>　　因为<code>BFC</code>内部的元素和外部的元素绝对不会互相影响，因此， 当<code>BFC</code>外部存在浮动时，它不应该影响<code>BFC</code>内部Box的布局，<code>BFC</code>会通过变窄，而不与浮动有重叠。同样的，当<code>BFC</code>内部有浮动时，为了不影响外部元素的布局，<code>BFC</code>计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p>
<p>您可能感兴趣的相关文章</p>
<ul>
<li><a href="http://www.cnblogs.com/lhb25/p/loading-spinners-animated-with-css3.html" target="_blank" rel="external">使用 CSS3 实现超炫的加载动画效果</a></li>
<li><a href="http://www.cnblogs.com/lhb25/p/css-balls.html" target="_blank" rel="external">你想不到的！CSS 实现的各种球体效果</a></li>
<li><a href="http://www.cnblogs.com/lhb25/archive/2012/09/27/10-css3-online-generator-tools.html" target="_blank" rel="external">精心挑选的在线 CSS3 代码生成工具</a></li>
<li><a href="http://www.cnblogs.com/lhb25/archive/2011/05/15/2046038.html" target="_blank" rel="external">推荐10个特别方便的 CSS3 开发工具</a></li>
<li><a href="http://www.cnblogs.com/lhb25/archive/2011/04/20/2001131.html" target="_blank" rel="external">推荐收集的40款优秀的免费 CSS 工具</a></li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">Webpack,Gulp</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/18/Others/BFC神奇背后的原理/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Others/CSS命名规范——BEM思想" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/15/Others/CSS命名规范——BEM思想/">CSS命名规范——BEM思想</a>
    </h1>
  

        
        <a href="/2017/03/15/Others/CSS命名规范——BEM思想/" class="archive-article-date">
  	<time datetime="2017-03-15T13:40:20.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-15</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自<a href="http://www.cnblogs.com/dujishi/p/5862911.html">CSS命名规范——BEM思想（非常赞的规范）</a></p>
<p>人们问我最多的问题之一是在CSS类名中<code>--</code>和<code>__</code>是什么意思？它们的出现是源于<a href="http://bem.info/">BEM</a>和<a href="http://twitter.com/necolas">Nicolas Gallagher</a>…</p>
<p>BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由<a href="http://yandex.ru/">Yandex</a>团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。</p>
<p>重要的是要注意，我使用的基于BEM的命名方式是经过<a href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture">Nicolas Gallagher修改过的</a>。这篇文章中介绍的这种命名技术并不是原始的BEM，但却是一个我更喜欢的改进版。无论实际使用了什么样的符号，它们其实都是基于同样的BEM原则。</p>
        
          <a class="article-more-a" href="/2017/03/15/Others/CSS命名规范——BEM思想/#more">more >></a>
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">css</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/15/Others/CSS命名规范——BEM思想/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Framework/Webpack/webpack" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/13/Framework/Webpack/webpack/">webpack的使用</a>
    </h1>
  

        
        <a href="/2017/03/13/Framework/Webpack/webpack/" class="archive-article-date">
  	<time datetime="2017-03-12T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-13</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://webpackdoc.com/module-system.html">原文地址</a></p>
<p><a href="https://github.com/webpack/webpack">Webpack</a> 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。</p>
        
          <a class="article-more-a" href="/2017/03/13/Framework/Webpack/webpack/#more">more >></a>
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">webpack,打包工具</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/13/Framework/Webpack/webpack/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-DataBase/mongodb/mongodb的安装、配置与基本使用" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/12/DataBase/mongodb/mongodb的安装、配置与基本使用/">mongodb的安装、配置与基本使用</a>
    </h1>
  

        
        <a href="/2017/03/12/DataBase/mongodb/mongodb的安装、配置与基本使用/" class="archive-article-date">
  	<time datetime="2017-03-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h2><p>MongoDB官网:<a href="https://www.mongodb.com/">https://www.mongodb.com/</a><br>下载地址:<a href="https://www.mongodb.com/download-center?jmp=nav#community">https://www.mongodb.com/download-center?jmp=nav#community</a><br>菜鸟教程：<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html">http://www.runoob.com/mongodb/mongodb-tutorial.html</a></p>
<h2 id="为什么选择MongoDB"><a href="#为什么选择MongoDB" class="headerlink" title="为什么选择MongoDB?"></a>为什么选择MongoDB?</h2><p>1.只要会js/json就会mongodb(学习成本低)<br>2.mongodb对js的兼容性最好<br>3.mongodb存数据就是存json</p>
        
          <a class="article-more-a" href="/2017/03/12/DataBase/mongodb/mongodb的安装、配置与基本使用/#more">more >></a>
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">mongodb,数据库</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/12/DataBase/mongodb/mongodb的安装、配置与基本使用/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Framework/Node/node" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/07/Framework/Node/node/">nodejs</a>
    </h1>
  

        
        <a href="/2017/03/07/Framework/Node/node/" class="archive-article-date">
  	<time datetime="2017-03-06T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-07</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>## </p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">nodejs,node,javascript</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/07/Framework/Node/node/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 PhoenixAve
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p="./",n(0)}([function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,n){var e=/\/|index.html/g;return t.replace(e,"")===n.replace(e,"")}function i(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,e=0,r=t.length;e<r;e++){var i=t[e];o(n,i.getAttribute("href"))&&(0,d.default)(i,"active")}}function u(t){for(var n=t.offsetLeft,e=t.offsetParent;null!==e;)n+=e.offsetLeft,e=e.offsetParent;return n}function f(t){for(var n=t.offsetTop,e=t.offsetParent;null!==e;)n+=e.offsetTop,e=e.offsetParent;return n}function c(t,n,e,r,o){var i=u(t),c=f(t)-n;if(c-e<=o){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(e||c)+"px",a.style.left=i+"px",a.style.zIndex=r||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");c(t,document.body.scrollTop,-63,2,0),c(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}function l(){x.default.versions.mobile&&window.screen.width<800&&(i(),s())}var p=e(71),d=r(p),v=e(72),y=(r(v),e(84)),h=r(y),b=e(69),x=r(b),m=e(75),g=r(m),w=e(70);l(),(0,w.addLoadEvent)(function(){g.default.init()}),t.exports={}},function(t,n){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,n){var e={}.hasOwnProperty;t.exports=function(t,n){return e.call(t,n)}},function(t,n,e){var r=e(49),o=e(15);t.exports=function(t){return r(o(t))}},function(t,n,e){t.exports=!e(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,e){var r=e(6),o=e(12);t.exports=e(4)?function(t,n,e){return r.f(t,n,o(1,e))}:function(t,n,e){return t[n]=e,t}},function(t,n,e){var r=e(10),o=e(30),i=e(24),u=Object.defineProperty;n.f=e(4)?Object.defineProperty:function(t,n,e){if(r(t),n=i(n,!0),r(e),o)try{return u(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[n]=e.value),t}},function(t,n,e){var r=e(22)("wks"),o=e(13),i=e(1).Symbol,u="function"==typeof i,f=t.exports=function(t){return r[t]||(r[t]=u&&i[t]||(u?i:o)("Symbol."+t))};f.store=r},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,e){var r=e(35),o=e(16);t.exports=Object.keys||function(t){return r(t,o)}},function(t,n,e){var r=e(11);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var e=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+r).toString(36))}},function(t,n){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,e){var r=e(6).f,o=e(2),i=e(7)("toStringTag");t.exports=function(t,n,e){t&&!o(t=e?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},function(t,n,e){var r=e(22)("keys"),o=e(13);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,n,e){var r=e(1),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,n){var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},function(t,n,e){var r=e(11);t.exports=function(t,n){if(!r(t))return t;var e,o;if(n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!r(o=e.call(t)))return o;if(!n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},function(t,n,e){var r=e(1),o=e(14),i=e(18),u=e(26),f=e(6).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||f(n,t,{value:u.f(t)})}},function(t,n,e){n.f=e(7)},function(t,n,e){var r=e(1),o=e(14),i=e(46),u=e(5),f="prototype",c=function(t,n,e){var a,s,l,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,h=t&c.B,b=t&c.W,x=d?o:o[n]||(o[n]={}),m=x[f],g=d?r:v?r[n]:(r[n]||{})[f];d&&(e=n);for(a in e)s=!p&&g&&void 0!==g[a],s&&a in x||(l=s?g[a]:e[a],x[a]=d&&"function"!=typeof g[a]?e[a]:h&&s?i(l,r):b&&g[a]==l?function(t){var n=function(n,e,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,e)}return new t(n,e,r)}return t.apply(this,arguments)};return n[f]=t[f],n}(l):y&&"function"==typeof l?i(Function.call,l):l,y&&((x.virtual||(x.virtual={}))[a]=l,t&c.R&&m&&!m[a]&&u(m,a,l)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c},function(t,n){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,n,e){var r=e(11),o=e(1).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,e){t.exports=!e(4)&&!e(8)(function(){return 7!=Object.defineProperty(e(29)("div"),"a",{get:function(){return 7}}).a})},function(t,n,e){"use strict";var r=e(18),o=e(27),i=e(36),u=e(5),f=e(2),c=e(17),a=e(51),s=e(20),l=e(58),p=e(7)("iterator"),d=!([].keys&&"next"in[].keys()),v="@@iterator",y="keys",h="values",b=function(){return this};t.exports=function(t,n,e,x,m,g,w){a(e,n,x);var O,S,_,j=function(t){if(!d&&t in A)return A[t];switch(t){case y:return function(){return new e(this,t)};case h:return function(){return new e(this,t)}}return function(){return new e(this,t)}},P=n+" Iterator",E=m==h,M=!1,A=t.prototype,T=A[p]||A[v]||m&&A[m],L=T||j(m),N=m?E?j("entries"):L:void 0,C="Array"==n?A.entries||T:T;if(C&&(_=l(C.call(new t)),_!==Object.prototype&&(s(_,P,!0),r||f(_,p)||u(_,p,b))),E&&T&&T.name!==h&&(M=!0,L=function(){return T.call(this)}),r&&!w||!d&&!M&&A[p]||u(A,p,L),c[n]=L,c[P]=b,m)if(O={values:E?L:j(h),keys:g?L:j(y),entries:N},w)for(S in O)S in A||i(A,S,O[S]);else o(o.P+o.F*(d||M),n,O);return O}},function(t,n,e){var r=e(10),o=e(55),i=e(16),u=e(21)("IE_PROTO"),f=function(){},c="prototype",a=function(){var t,n=e(29)("iframe"),r=i.length,o="<",u=">";for(n.style.display="none",e(48).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write(o+"script"+u+"document.F=Object"+o+"/script"+u),t.close(),a=t.F;r--;)delete a[c][i[r]];return a()};t.exports=Object.create||function(t,n){var e;return null!==t?(f[c]=r(t),e=new f,f[c]=null,e[u]=t):e=a(),void 0===n?e:o(e,n)}},function(t,n,e){var r=e(35),o=e(16).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,e){var r=e(2),o=e(3),i=e(45)(!1),u=e(21)("IE_PROTO");t.exports=function(t,n){var e,f=o(t),c=0,a=[];for(e in f)e!=u&&r(f,e)&&a.push(e);for(;n.length>c;)r(f,e=n[c++])&&(~i(a,e)||a.push(e));return a}},function(t,n,e){t.exports=e(5)},function(t,n,e){var r=e(15);t.exports=function(t){return Object(r(t))}},function(t,n,e){t.exports={default:e(41),__esModule:!0}},function(t,n,e){t.exports={default:e(42),__esModule:!0}},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var o=e(39),i=r(o),u=e(38),f=r(u),c="function"==typeof f.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":typeof t};n.default="function"==typeof f.default&&"symbol"===c(i.default)?function(t){return"undefined"==typeof t?"undefined":c(t)}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":"undefined"==typeof t?"undefined":c(t)}},function(t,n,e){e(65),e(63),e(66),e(67),t.exports=e(14).Symbol},function(t,n,e){e(64),e(68),t.exports=e(26).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,e){var r=e(3),o=e(61),i=e(60);t.exports=function(t){return function(n,e,u){var f,c=r(n),a=o(c.length),s=i(u,a);if(t&&e!=e){for(;a>s;)if(f=c[s++],f!=f)return!0}else for(;a>s;s++)if((t||s in c)&&c[s]===e)return t||s||0;return!t&&-1}}},function(t,n,e){var r=e(43);t.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(e){return t.call(n,e)};case 2:return function(e,r){return t.call(n,e,r)};case 3:return function(e,r,o){return t.call(n,e,r,o)}}return function(){return t.apply(n,arguments)}}},function(t,n,e){var r=e(9),o=e(34),i=e(19);t.exports=function(t){var n=r(t),e=o.f;if(e)for(var u,f=e(t),c=i.f,a=0;f.length>a;)c.call(t,u=f[a++])&&n.push(u);return n}},function(t,n,e){t.exports=e(1).document&&document.documentElement},function(t,n,e){var r=e(28);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,n,e){var r=e(28);t.exports=Array.isArray||function(t){return"Array"==r(t)}},function(t,n,e){"use strict";var r=e(32),o=e(12),i=e(20),u={};e(5)(u,e(7)("iterator"),function(){return this}),t.exports=function(t,n,e){t.prototype=r(u,{next:o(1,e)}),i(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,e){var r=e(9),o=e(3);t.exports=function(t,n){for(var e,i=o(t),u=r(i),f=u.length,c=0;f>c;)if(i[e=u[c++]]===n)return e}},function(t,n,e){var r=e(13)("meta"),o=e(11),i=e(2),u=e(6).f,f=0,c=Object.isExtensible||function(){return!0},a=!e(8)(function(){return c(Object.preventExtensions({}))}),s=function(t){u(t,r,{value:{i:"O"+ ++f,w:{}}})},l=function(t,n){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!c(t))return"F";if(!n)return"E";s(t)}return t[r].i},p=function(t,n){if(!i(t,r)){if(!c(t))return!0;if(!n)return!1;s(t)}return t[r].w},d=function(t){return a&&v.NEED&&c(t)&&!i(t,r)&&s(t),t},v=t.exports={KEY:r,NEED:!1,fastKey:l,getWeak:p,onFreeze:d}},function(t,n,e){var r=e(6),o=e(10),i=e(9);t.exports=e(4)?Object.defineProperties:function(t,n){o(t);for(var e,u=i(n),f=u.length,c=0;f>c;)r.f(t,e=u[c++],n[e]);return t}},function(t,n,e){var r=e(19),o=e(12),i=e(3),u=e(24),f=e(2),c=e(30),a=Object.getOwnPropertyDescriptor;n.f=e(4)?a:function(t,n){if(t=i(t),n=u(n,!0),c)try{return a(t,n)}catch(t){}if(f(t,n))return o(!r.f.call(t,n),t[n])}},function(t,n,e){var r=e(3),o=e(33).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],f=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?f(t):o(r(t))}},function(t,n,e){var r=e(2),o=e(37),i=e(21)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,e){var r=e(23),o=e(15);t.exports=function(t){return function(n,e){var i,u,f=String(o(n)),c=r(e),a=f.length;return c<0||c>=a?t?"":void 0:(i=f.charCodeAt(c),i<55296||i>56319||c+1===a||(u=f.charCodeAt(c+1))<56320||u>57343?t?f.charAt(c):i:t?f.slice(c,c+2):(i-55296<<10)+(u-56320)+65536)}}},function(t,n,e){var r=e(23),o=Math.max,i=Math.min;t.exports=function(t,n){return t=r(t),t<0?o(t+n,0):i(t,n)}},function(t,n,e){var r=e(23),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,n,e){"use strict";var r=e(44),o=e(52),i=e(17),u=e(3);t.exports=e(31)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==n?o(0,e):"values"==n?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,n){},function(t,n,e){"use strict";var r=e(59)(!0);e(31)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,e=this._i;return e>=n.length?{value:void 0,done:!0}:(t=r(n,e),this._i+=t.length,{value:t,done:!1})})},function(t,n,e){"use strict";var r=e(1),o=e(2),i=e(4),u=e(27),f=e(36),c=e(54).KEY,a=e(8),s=e(22),l=e(20),p=e(13),d=e(7),v=e(26),y=e(25),h=e(53),b=e(47),x=e(50),m=e(10),g=e(3),w=e(24),O=e(12),S=e(32),_=e(57),j=e(56),P=e(6),E=e(9),M=j.f,A=P.f,T=_.f,L=r.Symbol,N=r.JSON,C=N&&N.stringify,k="prototype",F=d("_hidden"),q=d("toPrimitive"),I={}.propertyIsEnumerable,B=s("symbol-registry"),D=s("symbols"),W=s("op-symbols"),H=Object[k],K="function"==typeof L,R=r.QObject,J=!R||!R[k]||!R[k].findChild,U=i&&a(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,n,e){var r=M(H,n);r&&delete H[n],A(t,n,e),r&&t!==H&&A(H,n,r)}:A,G=function(t){var n=D[t]=S(L[k]);return n._k=t,n},$=K&&"symbol"==typeof L.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof L},z=function(t,n,e){return t===H&&z(W,n,e),m(t),n=w(n,!0),m(e),o(D,n)?(e.enumerable?(o(t,F)&&t[F][n]&&(t[F][n]=!1),e=S(e,{enumerable:O(0,!1)})):(o(t,F)||A(t,F,O(1,{})),t[F][n]=!0),U(t,n,e)):A(t,n,e)},Y=function(t,n){m(t);for(var e,r=b(n=g(n)),o=0,i=r.length;i>o;)z(t,e=r[o++],n[e]);return t},Q=function(t,n){return void 0===n?S(t):Y(S(t),n)},X=function(t){var n=I.call(this,t=w(t,!0));return!(this===H&&o(D,t)&&!o(W,t))&&(!(n||!o(this,t)||!o(D,t)||o(this,F)&&this[F][t])||n)},V=function(t,n){if(t=g(t),n=w(n,!0),t!==H||!o(D,n)||o(W,n)){var e=M(t,n);return!e||!o(D,n)||o(t,F)&&t[F][n]||(e.enumerable=!0),e}},Z=function(t){for(var n,e=T(g(t)),r=[],i=0;e.length>i;)o(D,n=e[i++])||n==F||n==c||r.push(n);return r},tt=function(t){for(var n,e=t===H,r=T(e?W:g(t)),i=[],u=0;r.length>u;)!o(D,n=r[u++])||e&&!o(H,n)||i.push(D[n]);return i};K||(L=function(){if(this instanceof L)throw TypeError("Symbol is not a constructor!");var t=p(arguments.length>0?arguments[0]:void 0),n=function(e){this===H&&n.call(W,e),o(this,F)&&o(this[F],t)&&(this[F][t]=!1),U(this,t,O(1,e))};return i&&J&&U(H,t,{configurable:!0,set:n}),G(t)},f(L[k],"toString",function(){return this._k}),j.f=V,P.f=z,e(33).f=_.f=Z,e(19).f=X,e(34).f=tt,i&&!e(18)&&f(H,"propertyIsEnumerable",X,!0),v.f=function(t){return G(d(t))}),u(u.G+u.W+u.F*!K,{Symbol:L});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;nt.length>et;)d(nt[et++]);for(var nt=E(d.store),et=0;nt.length>et;)y(nt[et++]);u(u.S+u.F*!K,"Symbol",{for:function(t){return o(B,t+="")?B[t]:B[t]=L(t)},keyFor:function(t){if($(t))return h(B,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){J=!0},useSimple:function(){J=!1}}),u(u.S+u.F*!K,"Object",{create:Q,defineProperty:z,defineProperties:Y,getOwnPropertyDescriptor:V,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),N&&u(u.S+u.F*(!K||a(function(){var t=L();return"[null]"!=C([t])||"{}"!=C({a:t})||"{}"!=C(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!$(t)){for(var n,e,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return n=r[1],"function"==typeof n&&(e=n),!e&&x(n)||(n=function(t,n){if(e&&(n=e.call(this,t,n)),!$(n))return n}),r[1]=n,C.apply(N,r)}}}),L[k][q]||e(5)(L[k],q,L[k].valueOf),l(L,"Symbol"),l(Math,"Math",!0),l(r.JSON,"JSON",!0)},function(t,n,e){e(25)("asyncIterator")},function(t,n,e){e(25)("observable")},function(t,n,e){e(62);for(var r=e(1),o=e(5),i=e(17),u=e(7)("toStringTag"),f=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],c=0;c<5;c++){var a=f[c],s=r[a],l=s&&s.prototype;l&&!l[u]&&o(l,u,a),i[a]=i.Array}},function(t,n){"use strict";var e={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&t.indexOf("KHTML")==-1,mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:t.indexOf("Safari")==-1,weixin:t.indexOf("MicroMessenger")==-1}}()};t.exports=e},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=e(40),i=r(o),u=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):o[t]||t}function n(t){return l[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,r=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},f=/\u00a0/g,c=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var p in o)l[o[p]]=p;return o["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(r,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(c,"\n").replace(e,t).replace(f," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e+=2)n.push(String.fromCharCode("0x"+t.slice(e,e+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,e=t.length;e>n;n++)t[n]=u.encodeObject(t[n]);else if("object"==("undefined"==typeof t?"undefined":(0,i.default)(t)))for(var r in t)t[r]=u.encodeObject(t[r]);else if("string"==typeof t)return u.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=u},function(t,n){function e(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=e},function(t,n){function e(t,n){if(t.classList)t.classList.remove(n);else{var e=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(e," ")}}t.exports=e},,,function(t,n){"use strict";function e(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){var n=document.querySelectorAll(".article-entry a:not(.article-more-a)");n.forEach(function(t){t.setAttribute("target","_blank")})}var e=document.querySelector("#js-aboutme");e&&0!==e.length&&(e.innerHTML=e.innerText)}t.exports={init:e}},,,,,,,,,function(t,n){function e(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var e=t.nextSibling;return e?t.parentNode.insertBefore(n,e):t.parentNode.appendChild(n)}t.exports=e}])</script><script src="/./main.2d7529.js"></script><script>!function(){var e=function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)};e("/slider.885efe.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">简历,求职,web前端</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">前端,资源</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">javascript,es6</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">javascript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">模块化,CMD,AMD,CommonJS,seajs,requireJS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">css</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">windows,windows 10</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Webpack,Gulp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">跨域</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">CSS,JavaScript,面试题目</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Sass,CSS预编译</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">mongodb,数据库</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">angular</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">gulp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">express,node</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">gulp，</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">nodejs,node,javascript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">nodejs</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">vue,vuex</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">webpack</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">webpack,打包工具</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://www.ruanyifeng.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>阮一峰</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.zhangxinxu.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>张鑫旭</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.liaoxuefeng.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>廖雪峰</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.cnblogs.com/TomXu/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>汤姆大叔</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.haorooms.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>Aaron</a>
            </li>
          
            <li class="search-li">
              <a href="https://segmentfault.com/a/1190000007062464" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>前端资源</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.nowcoder.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>牛客网</a>
            </li>
          
            <li class="search-li">
              <a href="https://laod.cn/hosts/2016-google-hosts.html" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>老D翻墙</a>
            </li>
          
            <li class="search-li">
              <a href="http://lanterncn.cn/down" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>蓝灯工作站</a>
            </li>
          
            <li class="search-li">
              <a href="http://jeffjade.com/archives/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>晚晴幽草轩</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>