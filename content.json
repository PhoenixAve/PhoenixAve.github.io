[{"title":"CSS命名规范——BEM思想","date":"2017-03-15T13:40:20.000Z","path":"2017/03/15/Others/CSS命名规范——BEM思想/","text":"转载自CSS命名规范——BEM思想（非常赞的规范） 人们问我最多的问题之一是在CSS类名中--和__是什么意思？它们的出现是源于BEM和Nicolas Gallagher… BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。 重要的是要注意，我使用的基于BEM的命名方式是经过Nicolas Gallagher修改过的。这篇文章中介绍的这种命名技术并不是原始的BEM，但却是一个我更喜欢的改进版。无论实际使用了什么样的符号，它们其实都是基于同样的BEM原则。 命名约定的模式如下：123.block&#123;&#125; .block__element&#123;&#125; .block--modifier&#123;&#125; .block 代表了更高级别的抽象或组件。 .block__element 代表.block的后代，用于形成一个完整的.block的整体。 .block--modifier代表.block的不同状态或不同版本。 之所以使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定，如：123.site-search&#123;&#125; /* 块 */ .site-search__field&#123;&#125; /* 元素 */ .site-search--full&#123;&#125; /* 修饰符 */ BEM的关键是光凭名字就可以告诉其他开发者某个标记是用来干什么的。通过浏览HTML代码中的class属性，你就能够明白模块之间是如何关联的：有一些仅仅是组件，有一些则是这些组件的子孙或者是元素,还有一些是组件的其他形态或者是修饰符。我们用一个类比/模型来思考一下下面的这些元素是怎么关联的：12345.person&#123;&#125; .person__hand&#123;&#125; .person--female&#123;&#125; .person--female__hand&#123;&#125; .person__hand--left&#123;&#125; 顶级块是‘person’，它拥有一些元素，如‘hand’。一个人也会有其他形态，比如女性，这种形态进而也会拥有它自己的元素。下面我们把他们写成‘常规’CSS:12345.person&#123;&#125; .hand&#123;&#125; .female&#123;&#125; .female-hand&#123;&#125; .left-hand&#123;&#125; 这些‘常规’CSS都是有意义的，但是它们之间却有些脱节。就拿.female来说，是指女性人类还是某种雌性的动物？还有.hand，是在说一只钟表的指针（译注：英文中hand有指针的意思）？还是一只正在玩纸牌的手？使用BEM我们可以获得更多的描述和更加清晰的结构，单单通过我们代码中的命名就能知道元素之间的关联。BEM真是强大。 再来看一个之前用‘常规’方式命名的.site-search的例子：1234&lt;form class=\"site-search full\"&gt; &lt;input type=\"text\" class=\"field\"&gt; &lt;input type=\"Submit\" value =\"Search\" class=\"button\"&gt; &lt;/form&gt; 这些CSS类名真是太不精确了，并不能告诉我们足够的信息。尽管我们可以用它们来完成工作，但它们确实非常含糊不清。用BEM记号法就会是下面这个样子：1234&lt;form class=\"site-search site-search--full\"&gt; &lt;input type=\"text\" class=\"site-search__field\"&gt; &lt;input type=\"Submit\" value =\"Search\" class=\"site-search__button\"&gt; &lt;/form&gt; 我们能清晰地看到有个叫.site-search的块，他内部是一个叫.site-search__field的元素。并且.site-search还有另外一种形态叫.site-search–full。 我们再来举个例子…… 如果你熟悉OOCSS（面向对象CSS），那么你对media对象一定也不陌生。用BEM的方式，media对象就会是下面这个样子：1234.media&#123;&#125; .media__img&#123;&#125; .media__img--rev&#123;&#125; .media__body&#123;&#125; 从这种CSS的写法上我们就已经知道.mediaimg 和.mediabody一定是位于.media内部的，而且.mediaimg–rev是.mediaimg的另一种形态。仅仅通过CSS选择器的名字我们就能获取到以上全部信息。 BEM的另外一个好处是针对下面这种情况：1234567&lt;div class=\"media\"&gt; &lt;img src=\"logo.png\" alt=\"Foo Corp logo\" class=\"img-rev\"&gt; &lt;div class=\"body\"&gt; &lt;h3 class=\"alpha\"&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=\"lede\"&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 光从上面的代码来看，我们根本不明白.media和.alpha两个class彼此之间是如何相互关联的？同样我们也无从知晓.body和.lede之间，或者.img-rev 和.media之间各是什么关系？从这段HTML（除非你对那个media对象非常了解）中我们也不知道这个组件是由什么组成的和它还有什么其他的形态。如果我们用BEM方式重写这段代码：1234567&lt;div class=\"media\"&gt; &lt;img src=\"logo.png\" alt=\"Foo Corp logo\" class=\"media__img--rev\"&gt; &lt;div class=\"media__body\"&gt; &lt;h3 class=\"alpha\"&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=\"lede\"&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 我们立马就能明白.media是一个块，.media__img–rev是一个加了修饰符的.media__img的变体，它是属于.media的元素。而.media__body是一个尚未被改变过的也是属于.media的元素。所有以上这些信息都通过它们的class名称就能明白，由此看来BEM确实非常实用。 丑极了！通常人们会认为BEM这种写法难看。我敢说，如果你仅仅是因为这种代码看上去不怎么好看而羞于使用它，那么你将错失最重要的东西。除非使用BEM让代码增加了不必要的维护困难，或者这么做确实让代码更难读了，那么你在使用它之前就要三思而行了。但是，如果只是“看起来有点怪”而事实上是一种有效的手段，那么我们在开发之前当然应该充分考虑它。 是，BEM看上去确实怪怪的，但是它的好处远远超过它外观上的那点瑕疵。 BEM可能看上去有点滑稽，而且有可能导致我们输入更长的文本（大部分编辑器都有自动补全功能，而且gzip压缩将会让我们消除对文件体积的担忧），但是它依旧强大。 用还是不用BEM?我在我的所有项目中都使用了BEM记号法，因为它的有效性已经被它自己一次又一次地证明。我也极力地建议别人使用BEM，因为它让所有东西之间的联系变得更加紧密，让团队甚至是你个人都能够更加容易地维护代码。 然而，当你真正使用BEM的时候，重要的是，请记住你没必要真的在每个地方都用上它。比如：1.caps&#123; text-transform:uppercase; &#125; 这条CSS不属于任何一个BEM范畴，它仅仅只是一条单独的样式。 另一个没有使用BEM的例子是：1.site-logo&#123;&#125; 这是一个logo，我们可以把它写成BEM格式，像下面这样：12.header&#123;&#125; .header__logo&#123;&#125; 但我们没必要这么做。使用BEM的诀窍是，你要知道什么时候哪些东西是应该写成BEM格式的。因为某些东西确实是位于一个块的内部，但这并不意味它就是BEM中所说的元素。这个例子中，网站logo完全是恰巧在.header的内部，它也有可能在侧边栏或是页脚里面。一个元素的范围可能开始于任何上下文，因此你要确定只在你需要用到BEM的地方你才使用它。再看一个例子：123&lt;div class=\"content\"&gt; &lt;h1 class=\"content__headline\"&gt;Lorem ipsum dolor...&lt;/h1&gt; &lt;/div&gt; 在这个例子里，我们也许仅仅只需要另一个class，可以叫它.headline；它的样式取决于它是如何被层叠的，因为它在.content的内部；或者它只是恰巧在.content的内部。如果它是后者（即恰巧在.content的内部，而不总是在）我们就不需要使用BEM。 然而，一切都有可能潜在地用到BEM。我们再来看一下.site-logo的例子，想象一下我们想要给网站增加一点圣诞节的气氛，所以我们想有一个圣诞版的logo。于是我们有了下面的代码：12.site-logo&#123;&#125; .site-logo--xmas&#123;&#125; 我们可以通过使用–修饰符来快速地为我们的代码构建另一个版本。 BEM最难的部分之一是明确作用域是从哪开始和到哪结束的，以及什么时候使用（不使用）它。随着接触的多了，有了经验积累，你慢慢就会知道怎么用，这些问题也不再是问题。 结束语所以，BEM（或BEM的变体）是一个非常有用，强大，简单的命名约定，以至于让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确而且更加严密。 尽管BEM看上去多少有点奇怪，但是无论什么项目，它对前端开发者都是一个巨有价值的工具。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"webpack的使用","date":"2017-03-12T16:00:00.000Z","path":"2017/03/13/Framework/Webpack/webpack/","text":"原文地址 Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 前言现状伴随着移动互联的大潮，当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。 前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 模块系统的演进模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统。 &lt;script&gt;标签1234&lt;script src=\"module1.js\"&gt;&lt;/script&gt;&lt;script src=\"module2.js\"&gt;&lt;/script&gt;&lt;script src=\"libraryA.js\"&gt;&lt;/script&gt;&lt;script src=\"module3.js\"&gt;&lt;/script&gt; 这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 YUI 库。 这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突 文件只能按照&lt;script&gt; 的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonJS服务器端的 Node.js 遵循 CommonJS规范，该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。1234require(\"module\");require(\"../file.js\");exports.doStuff = function() &#123;&#125;;module.exports = someValue; 优点： 服务器端模块便于重用 NPM 中已经有将近20万个可以使用模块包 简单并容易使用 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 实现： 服务器端的 Node.js Browserify，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大 modules-webmake，类似Browserify，还不如 Browserify 灵活 wreq，Browserify 的前身 AMDAsynchronous Module Definition 规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。1234define(\"module\", [\"dep1\", \"dep2\"], function(d1, d2) &#123; return someExportedValue;&#125;);require([\"module\", \"../file\"], function(module, file) &#123; /* ... */ &#125;); 优点： 适合在浏览器环境中异步加载模块 可以并行加载多个模块 缺点： 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅 不符合通用的模块化思维方式，是一种妥协的实现 实现： RequireJS curl CMDCommon Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。123456define(function(require, exports, module) &#123; var $ = require('jquery'); var Spinning = require('./spinning'); exports.doSomething = ... module.exports = ...&#125;) 优点： 依赖就近，延迟执行 可以很容易在 Node.js 中运行 缺点： 依赖 SPM 打包，模块的加载逻辑偏重 实现： Sea.js coolie UMDUniversal Module Definition 规范类似于兼容 CommonJS 和 AMD 的语法糖，是模块定义的跨平台解决方案。 ES6 模块EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。123import \"jquery\";export function doStuff() &#123;&#125;module \"localModule\" &#123;&#125; 优点： 容易进行静态分析 面向未来的 EcmaScript 标准 缺点： 原生浏览器端还没有实现该标准 全新的命令字，新版的 Node.js才支持 实现： Babe 期望的模块系统可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。 前端模块加载前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。 模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。 分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。 要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。 所有资源都是模块在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。 如果他们都可以视作模块，并且都可以通过require的方式来加载，将带来优雅的开发体验，比如：1234require(\"./style.css\");require(\"./style.less\");require(\"./template.jade\");require(\"./image.png\"); 那么如何做到让 require 能加载各种资源呢？ 静态分析在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用 LESS 写的样式模块，可以先用 LESS 加载器将它转成一个CSS 模块，在通过 CSS 模块把他插入到页面的 &lt;style&gt; 标签中执行。Webpack 就是在这样的需求中应运而生。 同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们还需要一个模块加载的兼容策略，来避免重写所有的模块。 那么接下来，让我们开始 Webpack 的神奇之旅吧。 什么是webpackWebpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 为什么重复造轮子市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。 这些已有的模块化工具并不能很好的完成如下的目标： 将依赖树拆分成按需加载的块 初始化加载的耗时尽量少 各种静态资源都可以视作模块 将第三方库整合成模块的能力 可以自定义打包逻辑的能力 适合大项目，无论是单页还是多页的 Web 应用 Webpack 的特点Webpack 和其他模块化工具有什么区别呢？ 代码拆分Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 LoaderWebpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。 插件系统Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 准备开始我们通过具体案例来快速上手 Webpack。以下章节中的案例源码可以在 https://github.com/zhaoda/webpack-handbook/tree/master/examples/start 查看。 安装首先要安装 Node.js， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。 用 npm 安装 Webpack：1$ npm install webpack -g 此时 Webpack 已经安装到了全局环境下，可以通过命令行 webpack -h 试试。 通常我们会将 Webpack 安装到项目的依赖中，这样就可以使用项目本地版本的 Webpack。1234# 进入项目目录# 确定已经有 package.json，没有就通过 npm init 创建# 安装 webpack 依赖$ npm install webpack --save-dev Webpack 目前有两个主版本，一个是在 master 主干的稳定版，一个是在 webpack-2 分支的测试版，测试版拥有一些实验性功能并且和稳定版不兼容，在正式项目中应该使用稳定版。12345# 查看 webpack 版本信息$ npm info webpack# 安装指定版本的 webpack$ npm install webpack@1.12.x --save-dev 如果需要使用 Webpack 开发工具，要单独安装：1$ npm install webpack-dev-server --save-dev 使用首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：123456789&lt;!-- index.html --&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12// entry.jsdocument.write('It works.') 然后编译 entry.js 并打包到 bundle.js：1$ webpack entry.js bundle.js 打包过程会显示日志：123456Hash: e964f90ec65eb2c29bb9Version: webpack 1.12.2Time: 54ms Asset Size Chunks Chunk Namesbundle.js 1.42 kB 0 [emitted] main [0] ./entry.js 27 bytes &#123;0&#125; [built] 用浏览器打开 index.html 将会看到 It works. 。 接下来添加一个模块 module.js 并修改入口 entry.js：12// module.jsmodule.exports = 'It works from module.js.' 123// entry.jsdocument.write('It works.')document.write(require('./module.js')) // 添加模块 重新打包 webpack entry.js bundle.js 后刷新页面看到变化 It works.It works from module.js.1234567Hash: 279c7601d5d08396e751Version: webpack 1.12.2Time: 63ms Asset Size Chunks Chunk Namesbundle.js 1.57 kB 0 [emitted] main [0] ./entry.js 66 bytes &#123;0&#125; [built] [1] ./module.js 43 bytes &#123;0&#125; [built] Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。 LoaderWebpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。 先来看看 loader 有哪些特性？ Loader 可以通过管道方式链式调用，每个 loader 可以把资源转换成任意格式并传递给下一个 loader ，但是最后一个 loader 必须返回 JavaScript。 Loader 可以同步或异步执行。 Loader 运行在 node.js 环境中，所以可以做任何可能的事情。 Loader 可以接受参数，以此来传递配置项给 loader。 Loader 可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。 Loader 可以通过 npm 发布和安装。 除了通过 package.json 的 main 指定，通常的模块也可以导出一个 loader 来使用。 Loader 可以访问配置。 插件可以让 loader 拥有更多特性。 Loader 可以分发出附加的任意文件。 Loader 本身也是运行在 node.js 环境中的 JavaScript 模块，它通常会返回一个函数。大多数情况下，我们通过 npm 来管理 loader，但是你也可以在项目中自己写 loader 模块。 按照惯例，而非必须，loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。 在引用 loader 的时候可以使用全名 json-loader，或者使用短名 json。这个命名规则和搜索优先级顺序在 webpack 的 resolveLoader.moduleTemplates api 中定义。1Default: [&quot;*-webpack-loader&quot;, &quot;*-web-loader&quot;, &quot;*-loader&quot;, &quot;*&quot;] Loader 可以在 require() 引用模块的时候添加，也可以在 webpack 全局配置中进行绑定，还可以通过命令行的方式使用。 接上一节的例子，我们要在页面中引入一个 CSS 文件 style.css，首页将 style.css 也看成是一个模块，然后用 css-loader 来读取它，再用 style-loader 把它插入到页面中。12/* style.css */body &#123; background: yellow; &#125; 修改 entry.js：123require(\"!style-loader!css-loader!./style.css\") // 载入 style.cssdocument.write('It works.')document.write(require('./module.js')) 安装 loader：1npm install css-loader style-loader 重新编译打包，刷新页面，就可以看到黄色的页面背景了。 如果每次 require CSS 文件的时候都要写 loader 前缀，是一件很繁琐的事情。我们可以根据模块类型（扩展名）来自动绑定需要的 loader。 将 entry.js 中的 require(&quot;!style!css!./style.css&quot;) 修改为 require(&quot;./style.css&quot;) ，然后执行：1234$ webpack entry.js bundle.js --module-bind 'css=style-loader!css-loader'# 有些环境下可能需要使用双引号$ webpack entry.js bundle.js --module-bind \"css=style-loader!css-loader\" 显然，这两种使用 loader 的方式，效果是一样的。 配置文件Webpack 在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的 webpack.config.js 文件，这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 –config 选项来指定配置文件。 继续我们的案例，在根目录创建 package.json 来添加 webpack 需要的依赖：12345678910111213141516171819&#123; \"name\": \"webpack-example\", \"version\": \"1.0.0\", \"description\": \"A simple webpack example.\", \"main\": \"bundle.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"webpack\" ], \"author\": \"zhaoda\", \"license\": \"MIT\", \"devDependencies\": &#123; \"css-loader\": \"^0.21.0\", \"style-loader\": \"^0.13.0\", \"webpack\": \"^1.12.2\" &#125;&#125; 123# 如果没有写入权限，请尝试如下代码更改权限chflags -R nouchg .sudo chmod 775 package.json 别忘了运行 npm install。 然后创建一个配置文件 webpack.config.js：1234567891011121314var webpack = require('webpack')module.exports = &#123; entry: './entry.js', output: &#123; path: \\_\\_dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;&#125; 同时简化 entry.js 中的 style.css 加载方式： require(‘./style.css’)最后运行 webpack，可以看到 webpack 通过配置文件执行的结果和上一章节通过命令行 webpack entry.js bundle.js --module-bind &#39;css=style-loader!css-loader&#39; 执行的结果是一样的。 插件插件可以完成更多 loader 不能完成的功能。 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。 Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件。 接下来，我们利用一个最简单的 BannerPlugin 内置插件来实践插件的配置和运行，这个插件的作用是给输出的文件头部添加注释信息。 修改 webpack.config.js，添加 plugins：1234567891011121314151617var webpack = require('webpack')module.exports = &#123; entry: './entry.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;, plugins: [ new webpack.BannerPlugin('This file is created by zhaoda') ]&#125; 然后运行 webpack，打开 bundle.js，可以看到文件头部出现了我们指定的注释信息：12345/*! This file is created by zhaoda *//******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;// 后面代码省略 开发环境当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。1$ webpack --progress --colors 如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。1$ webpack --progress --colors --watch 当然，使用 webpack-dev-server 开发服务是一个更好的选择。它将在 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开 http://localhost:8080/ 或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。12345# 安装$ npm install webpack-dev-server -g# 运行$ webpack-dev-server --progress --colors 故障处理Webpack 的配置比较复杂，很容出现错误，下面是一些通常的故障处理手段。 一般情况下，webpack 如果出问题，会打印一些简单的错误信息，比如模块没有找到。我们还可以通过参数 --display-error-details 来打印错误详情。12345678910111213141516171819202122232425262728$ webpack --display-error-detailsHash: a40fbc6d852c51fceadbVersion: webpack 1.12.2Time: 586ms Asset Size Chunks Chunk Namesbundle.js 12.1 kB 0 [emitted] main [0] ./entry.js 153 bytes &#123;0&#125; [built] [1 error] [5] ./module.js 43 bytes &#123;0&#125; [built] + 4 hidden modulesERROR in ./entry.jsModule not found: Error: Cannot resolve 'file' or 'directory' ./badpathmodule in /Users/zhaoda/data/projects/webpack-handbook/examplesresolve file /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json doesn't existresolve directory /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist (directory default file) /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule/package.json doesn't exist (directory description file)[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json] @ ./entry.js 3:0-26 Webpack 的配置提供了 resolve 和 resolveLoader 参数来设置模块解析的处理细节，resolve 用来配置应用层的模块（要被打包的模块）解析，resolveLoader 用来配置 loader 模块的解析。 当引入通过 npm 安装的 node.js 模块时，可能出现找不到依赖的错误。Node.js 模块的依赖解析算法很简单，是通过查看模块的每一层父目录中的 node_modules 文件夹来查询依赖的。当出现 Node.js 模块依赖查找失败的时候，可以尝试设置 resolve.fallback 和 resolveLoader.fallback 来解决问题。1234module.exports = &#123; resolve: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;, resolveLoader: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;&#125;; Webpack 中涉及路径配置最好使用绝对路径，建议通过 path.resolve(__dirname, &quot;app/folder&quot;) 或 path.join(__dirname, &quot;app&quot;, &quot;folder&quot;) 的方式来配置，以兼容 Windows 环境。 高级以下章节是进阶内容。 CommonJS 规范CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。 这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 ServerJS。 我在这里描述的并不是一个技术问题，而是一件重大的事情，让大家走到一起来做决定，迈出第一步，来建立一个更大更酷的东西。 —— Kevin Dangoor’s What Server Side JavaScript needs 2009年8月，这个项目改名为 CommonJS，以显示其 API 的更广泛实用性。CommonJS 是一套规范，它的创建和核准是开放的。这个规范已经有很多版本和具体实现。CommonJS 并不是属于 ECMAScript TC39 小组的工作，但 TC39 中的一些成员参与 CommonJS 的制定。2013年5月，Node.js 的包管理器 NPM 的作者 Isaac Z. Schlueter 说 CommonJS 已经过时，Node.js 的内核开发者已经废弃了该规范。 CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。 一个直观的例子：1234// moduleA.jsmodule.exports = function( value )&#123; return value * 2;&#125; 123// moduleB.jsvar multiplyBy2 = require('./moduleA');var result = multiplyBy2(4); CommonJS 是同步加载模块，但其实也有浏览器端的实现，其原理是现将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 的源码来理解其解析（resolve）的过程。 更多关于 CommonJS 规范的内容请查看 http://wiki.commonjs.org/wiki/CommonJS。 AMD 规范AMD（异步模块定义）是为浏览器环境设计的，因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件。 AMD 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。 模块通过 define 函数定义在闭包中，格式如下：1define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。1define(function(require, exports, module) &#123;&#125;） factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 一些用例： 定义一个名为 myModule 的模块，它依赖 jQuery 模块：123456define('myModule', ['jquery'], function($) &#123; // $ 是 jquery 模块的输出 $('body').text('hello world');&#125;);// 使用define(['myModule'], function(myModule) &#123;&#125;); 注意：在 webpack 中，模块名只有局部作用域，在 Require.js 中模块名是全局作用域，可以在全局引用。 定义一个没有 id 值的匿名模块，通常作为应用的启动函数：123define(['jquery'], function($) &#123; $('body').text('hello world');&#125;); 依赖多个模块的定义：1234define(['jquery', './math.js'], function($, math) &#123; // $ 和 math 一次传入 factory $('body').text('hello world');&#125;); 模块输出：123456789define(['jquery'], function($) &#123; var HelloWorldize = function(selector)&#123; $(selector).text('hello world'); &#125;; // HelloWorldize 是该模块输出的对外接口 return HelloWorldize;&#125;); 在模块定义内部引用依赖：1234define(function(require) &#123; var $ = require('jquery'); $('body').text('hello world');&#125;); 参考链接模块规范CommonJS 规范Asynchronous Module DefinitionCommon Module DefinitionCMD 模块定义规范Universal Module DefinitionECMAScript 6 Module什么是 AMD、 CommonJS、 UMD关于 CommonJS AMD CMD UMD为什么我推荐 requirejs 而不是 seajsAMD 和 CMD 的区别有哪些前端模块化开发的价值What Server Side JavaScript needs 模块系统RequireJScurlSea.jscoolieBrowserifymodules-webmakewreq WebpackWebpack 官方文档React Webpack cookbook 编译Babel","tags":[{"name":"webpack,打包工具","slug":"webpack-打包工具","permalink":"http://yoursite.com/tags/webpack-打包工具/"}]},{"title":"mongodb的安装、配置与基本使用","date":"2017-03-11T16:00:00.000Z","path":"2017/03/12/DataBase/mongodb/mongodb的安装、配置与基本使用/","text":"相关网址MongoDB官网:https://www.mongodb.com/下载地址:https://www.mongodb.com/download-center?jmp=nav#community菜鸟教程：http://www.runoob.com/mongodb/mongodb-tutorial.html 为什么选择MongoDB?1.只要会js/json就会mongodb(学习成本低)2.mongodb对js的兼容性最好3.mongodb存数据就是存json 安装与配置 MongoDB 数据库环境安装mongodb在官网下载，直接安装即可，默认下一步直到完成 验证安装成功：在cmd终端中输入： mongo --version 或是 mongod --version ,能看到版本好,说明安装成功如果终端中输入 mongo –version 提示找不到命令,一定要看看是不是没有配置mongodb的环境变量,并且配置环境变量之后一定要记得重启cmd 配置环境变量我的电脑右键–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量–&gt;path添加mongodb的安装目录的bin目录到最后即可 window7安装MongoDB存在的问题建议:升级到window10解决步骤: 将你的操作系统升级到window7最新版 安装 vc_redist.x64.exe 如果你的电脑是32位的,再安装32位的mongodb软件 mongodb-win32-i386-3.2.11-signed.msi mongodb配置创建数据目录(必须)我们在安装完成MongoDB后需要创建一个存放数据的目录。请注意，数据目录应该放在根目录下（(如： C:\\ 或者 D:\\ 等 ),数据目录的命名随意,比如我就命名 mongodb_datas 启动服务器(必须) 启动MongoDB服务器的方式一：通过终端指令去启动 首先在终端切换到你的MongoDB的安装目录的bin目录下(当然如果配置了环境变量在哪个目录下都可以了) 在终端执行: mongod.exe –dbpath c:\\mongodb_datas ,如果成功启动就表示一切都OK了 注意点: 32位版本使用下面的命令启动数据服务：1mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1 - 执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了， - 千万不要关闭，否则无法连接，如果对数据库的操作结束，可以打开该控制台通过 `Ctrl + C` 关闭。 启动MongoDB服务器的方式二:方式一的延续,把上面的指令做成一个批处理文件.bat 新建一个文本文件修改后缀为.bat，以记事本的方式打开，输入mongod.exe --dbpath c:\\mongodb_datas 启动MongoDB服务器的方式三:将MongoDB服务器作为Windows服务运行 以管理员的身份打开命令行输入下面的 1mongod.exe --bind_ip 127.0.0.1 --logpath \"C:/mongodb_datas/server_log/mongodb.log\" --logappend --dbpath \"c:/mongodb_datas\" --port 27017 --serviceName \"MongoDBServer\" --serviceDisplayName \"MongoDBServerDisplayName\" --install 补充:从Windows服务中卸载 MongoDB 服务 先停止要删除的服务(比如MongoDBServer) 以管理员身份运行cmd,在cmd中输入: sc delete 服务名称(比如MongoDBServer) 千万不要删错了，不然你的系统可能就挂了 注意点: mongodb.log 这个日志文件一定要先创建好,才能执行指令 必须要以管理员的身份打开cmd窗口,并运行 MongoDB 数据库存储结构 和Excel对比一下即可明 Excel MongoDB 创建工作簿 创建数据库 创建一个sheet(工作表单) 创建集合 确立表头,插入数据 插入文档(确立表头) 核心思想: 1. 分门别类的存储数据 2. mongodb是以`集合`的概念来区分不同数据的,比如用户集合,商品集合,订单集合等等,不同的数据要放在不同的集合中去统一管理 3. 集合里面存储的可以认为是一个数组 4. 数组中的每一个对象,可以认为就是JSON对象,在mongodb中我们称之为 `文档` 5. 文档的结构可以随意,但是必须统一,也就是说,同一个集合中,所有的文档一定要遵守相同的数据结构 其他: 集合的作用就是用来隔离数据,分门别类的存储数据 操作MongoDB的步骤1.创建数据库中数据的存储目录2.启动MongoDB的服务实例3.创建数据库4.创建集合5.创建文档 如何连接到MongoDB服务器并且操作它？注意：在进行连接之前请确保你的服务实例是开启状态的（不要关闭刚才开启的数据服务实例）。 可以使用两种方式来连接到MongoDB服务器并且操作它 连接方式1:使用MongoDB自带的MongoDB后台管理 Shell 在终端中输入 `mongo` 或是 `mongo --host 127.0.0.1 --port 27017` mongo 命令默认去连接本机上的 MongoDB 服务实例：`127.0.0.1:27017`，可以通过下面的命令 指定连接的主机名和端口号： 1mongo --host 127.0.0.1 --port 27017 如果看到类似于如下的字样说明连接成功： 123456789MongoDB shell version v3.4.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.2Server has startup warnings:2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten]2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten]&gt; 如果提示 “无法连接主机”，请检查你的 MongoDB 数据服务实例是否开启。 操作方式1:在终端中使用mongodb的指令进行操作 常见指令：见下一个知识点 连接及操作方式2:使用图形化客户端工具： robomongo(跨平台) : https://robomongo.org/download 基本操作命令可以参考: http://www.yiibai.com/mongodb/mongodb_create_collection.html http://www.runoob.com/mongodb/mongodb-tutorial.html show dbs 查看当前服务实例上所有的数据库 use 数据库名称 如果数据库不存在，则创建数据库，否则切换到指定数据库。 db.dropDatabase() 删除数据库,注意,要在切换的数据库中删除 db 查看当前所处的数据库 show collections 查看当前数据库中所有的集合 db.createCollection(&quot;集合名称&quot;) 创建集合 db.集合名称.drop() 删除集合 db.集合名称.insert({数据文档}) 插入的每一条文档会自动帮我们生成一个_id字段,它是mongodb自动维护的,不需要我们关心 db.集合名称.find() 查询指定集合中所有的数据 可以通过 db.集合名称.find().pretty() 美化输出格式 默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据 模糊查询的条件 {要查询的字段:{$regex: ‘关键字’}} db.集合名称.update({更新条件}, {要更新的字段}) 更新指定集合数据,注意点,要更新的字段一定要这样写 {$set:{字段的名称:字段的值}}, db.集合名称.remove({删除条件}) 删除指定集合中的数据 exit 退出当前操作 cls 清屏 注意点：更新和删除时一般都需要带条件，除非是全部更新与全部删除，不过全部更新与全部删除这样很危险,实际操作过程中很少 使用 Node 操作 MongoDB安装 MongoDB 官方提供的驱动包：1npm install --save mongodb 具体操作方式请参考官方文档：https://www.npmjs.com/package/mongodb","tags":[{"name":"mongodb,数据库","slug":"mongodb-数据库","permalink":"http://yoursite.com/tags/mongodb-数据库/"}]},{"title":"nodejs","date":"2017-03-06T16:00:00.000Z","path":"2017/03/07/Framework/Node/node/","text":"##","tags":[{"name":"nodejs,node,javascript","slug":"nodejs-node-javascript","permalink":"http://yoursite.com/tags/nodejs-node-javascript/"}]},{"title":"express的基本使用","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/Framework/Express/express的基本使用/","text":"安装首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。12$ mkdir myapp$ cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。1$ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外：1entry point: (index.js) 键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。 接下来安装 Express 并将其保存到依赖列表中：1$ npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可：1$ npm install express 安装 Node 模块时，如果指定了 –save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。 路由路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。 路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback…], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。 下面是一个基本的路由示例：123456789101112var express = require('express');var app = express();// 当以GET方法请求根路径，服务器返回hello worldapp.get('/', function(req, res) &#123; res.send('hello world');&#125;);app.listen(3000, '127.0.0.1', function(err)&#123; if (err) return console.error(err) console.log('start ok!!!')&#125;); //开启服务器，监听3000端口，网址和回调函数可以省略 路由方法123456789// GET method routeapp.get('/', function (req, res) &#123; res.send('GET request to the homepage');&#125;);// POST method routeapp.post('/', function (req, res) &#123; res.send('POST request to the homepage');&#125;); Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。 有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如： app[‘m-search’](‘/‘, function … app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 在下面的例子中，来自 “/secret” 的请求，不管使用 GET、POST、PUT、DELETE 或其他任何 http 模块支持的 HTTP 请求，句柄都会得到执行。1234app.all('/secret', function (req, res, next) &#123; console.log('Accessing the secret section ...'); next(); // pass control to the next handler&#125;); 查询字符串的处理 get请求：express的req.query可以获取到查询字符串，并且默认就是对象的形式 1234567// http://localhost:3000/login?username=zhangsan&amp;password=123app.get('/login', (req, res, next) =&gt; &#123; console.log(req.query) //&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;) post请求：需要使用body-parser第三方插件 12345678910111213141516const bodyParser = require('body-parser')app.use(bodyParser.urlencoded(&#123;extended: false&#125;))app.post('/login', (req, res, next) =&gt; &#123; console.log(`req.body`)//&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;)// 或者下面这种凡事方式const bodyParser = require('body-parser')app.post('/login', bodyParser.urlencoded(&#123;extended: false&#125;), (req, res, next) =&gt; &#123; console.log(`req.body`)//&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;) 路由路径路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。 Express 使用 path-to-regexp 匹配路由路径，请参考文档查阅所有定义路由路径的方法。 Express Route Tester 是测试基本 Express 路径的好工具，但不支持模式匹配。查询字符串不是路由路径的一部分。 使用字符串的路由路径示例： 1234567891011121314// 匹配根路径的请求app.get('/', function (req, res) &#123; res.send('root');&#125;);// 匹配 /about 路径的请求app.get('/about', function (req, res) &#123; res.send('about');&#125;);// 匹配 /random.text 路径的请求app.get('/random.text', function (req, res) &#123; res.send('random.text');&#125;); 使用字符串模式的路由路径示例： 12345678910111213141516171819// 匹配 acd 和 abcdapp.get('/ab?cd', function(req, res) &#123; res.send('ab?cd');&#125;);// 匹配 abcd、abbcd、abbbcd等app.get('/ab+cd', function(req, res) &#123; res.send('ab+cd');&#125;);// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等app.get('/ab*cd', function(req, res) &#123; res.send('ab*cd');&#125;);// 匹配 /abe 和 /abcdeapp.get('/ab(cd)?e', function(req, res) &#123; res.send('ab(cd)?e');&#125;); 字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。 使用正则表达式的路由路径示例：123456789// 匹配任何路径中含有 a 的路径：app.get(/a/, function(req, res) &#123; res.send('/a/');&#125;);// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res) &#123; res.send('/.*fly$/');&#125;); 路由句柄可以为请求处理提供多个回调函数，其行为类似 中间件。唯一的区别是这些回调函数有可能调用 next(‘route’) 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。 路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合，如下所示. 使用一个回调函数处理路由： 123app.get('/example/a', function (req, res) &#123; res.send('Hello from A!');&#125;); 使用多个回调函数处理路由（记得指定 next 对象）： 123456app.get('/example/b', function (req, res, next) &#123; console.log('response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from B!');&#125;); 使用回调函数数组处理路由： 123456789101112131415var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/example/c', [cb0, cb1, cb2]); 混合使用函数和函数数组处理路由： 12345678910111213141516var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;app.get('/example/d', [cb0, cb1], function (req, res, next) &#123; console.log('response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from D!');&#125;); 相应方法下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。 方法 描述 res.download() 提示下载文件。 res.end() 终结响应处理流程。 res.json() 发送一个 JSON 格式的响应。 res.jsonp() 发送一个支持 JSONP 的 JSON 格式的响应。 res.redirect() 重定向请求。 res.render() 渲染视图模板。 res.send() 发送各种类型的响应。 res.sendFile 以八位字节流的形式发送文件。 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 app.route()可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。请参考 Router() 文档 了解更多有关路由的信息。 下面这个示例程序使用 app.route() 定义了链式路由句柄。12345678910app.route('/book') .get(function(req, res) &#123; res.send('Get a random book'); &#125;) .post(function(req, res) &#123; res.send('Add a book'); &#125;) .put(function(req, res) &#123; res.send('Update the book'); &#125;); express.Router可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。 下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。 在 app 目录下创建名为 birds.js 的文件，内容如下：123456789101112131415161718var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 然后在应用中加载路由模块：123var birds = require('./birds');...app.use('/birds', birds); 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。 使用中间件Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。中间件的功能包括： 执行任何代码。 修改请求和响应对象。 终结请求-响应循环。 调用堆栈中的下一个中间件。 如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。Express 应用可使用如下几种中间件： 应用级中间件] 路由级中间件 错误处理中间件 内置中间件 第三方中间件 使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。 应用级中间件应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如：123456789101112131415161718var app = express();// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use('/user/:id', function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; res.send('USER');&#125;); 下面这个例子展示了在一个挂载点装载一组中间件。12345678// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息app.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;); 作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。123456789101112// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; console.log('ID:', req.params.id); next();&#125;, function (req, res, next) &#123; res.send('User Info'); // 终止了请求-响应循环&#125;);// 处理 /user/:id， 打印出用户 id，该路由永远不会被执行app.get('/user/:id', function (req, res, next) &#123; res.end(req.params.id);&#125;); 如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由。 注意： next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效。123456789101112131415// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 否则将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面app.get('/user/:id', function (req, res, next) &#123; res.render('special');&#125;); 路由级中间件路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。1var router = express.Router(); 路由级使用 router.use() 或 router.VERB() 加载。上述在应用级创建的中间件系统，可通过如下代码改写为路由级：12345678910111213141516171819202122232425262728293031323334353637var app = express();var router = express.Router();// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 负责将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面router.get('/user/:id', function (req, res, next) &#123; console.log(req.params.id); res.render('special');&#125;);// 将路由挂载至应用app.use('/', router); 错误处理中间件 错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 请参考 错误处理 一章了解更多关于错误处理中间件的内容。 内置中间件从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。 express.static(root, [options])express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。 参数 root 指提供静态资源的根目录。 可选的 options 参数拥有如下属性。 属性 描述 类型 缺省值 dotfiles 是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore” String “ignore” etag 是否启用 etag 生成 Boolean true extensions 设置文件扩展名备份选项 Array [] index 发送目录索引文件，设置为 false 禁用目录索引。 Mixed “index.html” lastModified 设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false。 Boolean true maxAge 以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性。 Number 0 redirect 当路径为目录时，重定向至 “/”。 Boolean true setHeaders 设置 HTTP 头以提供文件的函数。 Function 下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。12345678910111213var options = &#123; dotfiles: 'ignore', etag: false, extensions: ['htm', 'html'], index: false, maxAge: '1d', redirect: false, setHeaders: function (res, path, stat) &#123; res.set('x-timestamp', Date.now()); &#125;&#125;app.use(express.static('public', options)); 每个应用可有多个静态目录。123app.use(express.static('public'));app.use(express.static('uploads'));app.use(express.static('files')); 更多关于 serve-static 和其参数的信息，请参考 serve-static 文档。 第三方中间件通过使用第三方中间件从而为 Express 应用增加更多功能。安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser1$ npm install cookie-parser 123456var express = require('express');var app = express();var cookieParser = require('cookie-parser');// 加载用于解析 cookie 的中间件app.use(cookieParser()); 请参考 第三方中间件 获取 Express 中经常用到的第三方中间件列表。 在 Express 中使用模板引擎需要在应用中进行如下设置才能让 Express 渲染模板文件： views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’) view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’)然后安装相应的模板引擎 npm 软件1$ npm install jade --save 和 Express 兼容的模板引擎，比如 Jade，通过 res.render() 调用其导出方法 __express(filePath, options, callback) 渲染模板。 有一些模板引擎不遵循这种约定，Consolidate.js 能将 Node 中所有流行的模板引擎映射为这种约定，这样就可以和 Express 无缝衔接。 一旦 view engine 设置成功，就不需要显式指定引擎，或者在应用中加载模板引擎模块，Express 已经在内部加载，如下所示。1app.set('view engine', 'jade'); 在 views 目录下生成名为 index.jade 的 Jade 模板文件，内容如下：12345html head title!= title body h1!= message 然后创建一个路由渲染 index.jade 文件。如果没有设置 view engine，您需要指明视图文件的后缀，否则就会遗漏它。123app.get('/', function (req, res) &#123; res.render('index', &#123; title: 'Hey', message: 'Hello there!'&#125;);&#125;); 此时向主页发送请求，“index.jade” 会被渲染为 HTML。 请阅读 “为 Express 开发模板引擎” 了解模板引擎在 Express 中是如何工作的。 错误处理定义错误处理中间件和定义其他中间件一样，除了需要 4 个参数，而不是 3 个，其格式如下 (err, req, res, next)。例如：1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 在其他 app.use() 和路由调用后，最后定义错误处理中间件，比如：12345678var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑&#125;); 中间件返回的响应是随意的，可以响应一个 HTML 错误页面、一句简单的话、一个 JSON 字符串，或者其他任何您想要的东西。 为了便于组织（更高级的框架），您可能会像定义常规中间件一样，定义多个错误处理中间件。比如您想为使用 XHR 的请求定义一个，还想为没有使用的定义一个，那么：12345678var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(logErrors);app.use(clientErrorHandler);app.use(errorHandler); logErrors 将请求和错误信息写入标准错误输出、日志或类似服务：1234function logErrors(err, req, res, next) &#123; console.error(err.stack); next(err);&#125; clientErrorHandler 的定义如下（注意这里将错误直接传给了 next）：1234567function clientErrorHandler(err, req, res, next) &#123; if (req.xhr) &#123; res.status(500).send(&#123; error: 'Something blew up!' &#125;); &#125; else &#123; next(err); &#125;&#125; errorHandler 能捕获所有错误，其定义如下：1234function errorHandler(err, req, res, next) &#123; res.status(500); res.render('error', &#123; error: err &#125;);&#125; 如果向 next() 传入参数（除了 ‘route’ 字符串），Express 会认为当前请求有错误的输出，因此跳过后续其他非错误处理和路由/中间件函数。如果需做特殊处理，需要创建新的错误处理路由，如下节所示。 如果路由句柄有多个回调函数，可使用 ‘route’ 参数跳到下一个路由句柄。比如：12345678910111213app.get('/a_route_behind_paywall', function checkIfPaidSubscriber(req, res, next) &#123; if(!req.user.hasPaid) &#123; // 继续处理该请求 next('route'); &#125; &#125;, function getPaidContent(req, res, next) &#123; PaidContent.find(function(err, doc) &#123; if(err) return next(err); res.json(doc); &#125;); &#125;); 在这个例子中，句柄 getPaidContent 会被跳过，但 app 中为 /a_route_behind_paywall 定义的其他句柄则会继续执行。 next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄。 缺省错误处理句柄Express 内置了一个错误处理句柄，它可以捕获应用中可能出现的任意错误。这个缺省的错误处理中间件将被添加到中间件堆栈的底部。 如果你向 next() 传递了一个 error ，而你并没有在错误处理句柄中处理这个 error，Express 内置的缺省错误处理句柄就是最后兜底的。最后错误将被连同堆栈追踪信息一同反馈到客户端。堆栈追踪信息并不会在生产环境中反馈到客户端。 设置环境变量 NODE_ENV 为 “production” 就可以让应用运行在生产环境模式下。 如果你已经开始向 response 输出数据了，这时才调用 next() 并传递了一个 error，比如你在将向客户端输出数据流时遇到一个错误，Express 内置的缺省错误处理句柄将帮你关闭连接并告知 request 请求失败。 因此，当你添加了一个自定义的错误处理句柄后，如果已经向客户端发送包头信息了，你还可以将错误处理交给 Express 内置的错误处理机制。1234567function errorHandler(err, req, res, next) &#123; if (res.headersSent) &#123; return next(err); &#125; res.status(500); res.render('error', &#123; error: err &#125;);&#125;","tags":[{"name":"express,node","slug":"express-node","permalink":"http://yoursite.com/tags/express-node/"}]},{"title":"gulp插件的使用","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/Framework/Gulp/gulp插件的使用/","text":"常用插件列表 插件名称 作用 del 删除文件或文件夹 gulp-less 编译LESS文件 gulp-rname 重命名文件 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 js 文件 gulp-concat-css 合并 css 文件 gulp-cssnano 压缩 css gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-load-plugins 依赖自动加载 gulp-useref 自动合并打包处理 gulp-wrap 包装内容 gulp-angular-templatecache AngularJS 模板缓存 browser-sync 和 gulp 配合使用实现文件改变执行某个任务后自动刷新 yargs 获取命令行参数 gulp-if 根据判断执行某个插件 gulp-angular-templatecache安装插件1npm install --save-dev gulp-angular-templatecache 基本使用ulpfile.js 连接模板目录中所有.html文件的内容，并保存到public / templates.js（默认文件名）。1234567var gulp = require('gulp');var templateCache = require('gulp-angular-templatecache');gulp.task('default', function () &#123; return gulp.src('templates/**/*.html') .pipe(templateCache()) .pipe(gulp.dest('public'));&#125;); 结果(public/templates.js) 输出样式（预处理）。1234567891011angular.module(\"templates\").run([$templateCache, function($templateCache) &#123; $templateCache.put(\"template1.html\", // template1.html content (escaped) ); $templateCache.put(\"template2.html\", // template2.html content (escaped) ); // etc. &#125;]); 将此文件包含在您的应用程序中，AngularJS将使用$ templateCache（如果可用）。注意：这个插件不会默认创建一个新的AngularJS模块，但需要调用templates模块。如果想要创建新模块，请将 options.standalone 设置为true。 注意：如果在Windows上使用Visual Studio，您可能会遇到此错误消息：ASPNETCOMPILER : error ASPRUNTIME: The specified path, file name, or both are too long. The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters.这很可能是由于路径名太长，可以通过在 lodash.bindpackage.json 中添加一个 dev dependecy 来修复。无论如何，如果你遇到这个错误，请在＃62中删除一个注释，我们可以合并＃63。 APIgulp-angular-templatecache(filename, options) filename - {string} [filename=’templates.js’] Name to use when concatenating. options root - {string} Prefix for template URLs. module - {string} [module=’templates’] Name of AngularJS module. standalone - {boolean} [standalone=false] Create a new AngularJS module, instead of using an existing. base {string | function} [base=file.base] Override file base path. moduleSystem {string} Wrap the templateCache in a module system. Currently supported systems: RequireJS, Browserify, ES6 and IIFE (Immediately-Invoked Function Expression). transformUrl {function} Transform the generated URL before it’s put into $templateCache. 123transformUrl: function(url) &#123; return url.replace(/\\.tpl\\.html$/, '.html')&#125; templateHeader {string} [templateHeader=see below] Override template header. 1var TEMPLATE_HEADER = 'angular.module(\"&lt;%= module %&gt;\"&lt;%= standalone %&gt;).run([\"$templateCache\", function($templateCache) &#123;'; templateBody {string} [templateBody=see below] Override template body. 1var TEMPLATE_BODY = '$templateCache.put(\"&lt;%= url %&gt;\",\"&lt;%= contents %&gt;\");'; templateFooter {string} [templateFooter=see below] Override template footer. 1var TEMPLATE_FOOTER = '&#125;]);';","tags":[{"name":"gulp，","slug":"gulp，","permalink":"http://yoursite.com/tags/gulp，/"}]},{"title":"Gulp构建工具的使用","date":"2017-03-04T13:50:52.000Z","path":"2017/03/04/Framework/Gulp/Gulp构建工具的使用/","text":"Automate and enhance your workflowgulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something. 简介本文主要是根据gulp中文网文档和gulp教程之gulp中文API的内容综合而成，方便自己理解与学习gulp自动化工具的基本使用 工具介绍 Gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。 常见处理任包括以下几方面： 模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。 使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件； 对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能； 以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack 等。 Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，其以简洁的配置和卓越的性能成为目前主流的构建工具。 相关链接 官方：http://gulpjs.com/中文官网：http://www.gulpjs.com.cn/npm：https://www.npmjs.com/package/gulpGithub：https://github.com/gulpjs/gulpGitbook：https://wizardforcel.gitbooks.io/gulp-doc/content/2.html 安装 首先要全局安装gulp-cli工具 1npm install --global gulp-cli 安装全局gulp 1npm install --global gulp 作为项目的开发依赖（devDependencies）安装 1npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 1234var gulp = require(&apos;gulp&apos;); // 引入gulp这个第三方包gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp 123gulp# 默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。# 想要单独执行特定的任务（task），请输入 gulp &lt;task&gt; &lt;othertask&gt;。 API文档 官方文档：https://github.com/gulpjs/gulp/blob/master/docs/API.md中文文档：http://www.gulpjs.com.cn/docs/gulp教程之gulp中文API：http://www.ydcss.com/archives/424 gulp.src(globs[,options])指定需要处理的源文件的路径，gulp借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，gulp.src返回当前文件流至可用插件；12345// 通过gulp.src()读取文件，经过pipe管道流到gulp.dest()指定的文件中gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) .pipe(gulp.dest('build/minified_templates')); globs类型： String 或StringArray需要处理的源文件匹配符路径，字符串或者数组通配符路径匹配示例： “src/a.js”：指定具体文件；“*“：匹配所有文件 例：src/*.js(包含src下的所有js文件)；“**“：匹配0个或多个子文件夹 例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；“{}“：匹配多个属性 例：src/{a,b}.js(包含a.js和b.js文件) src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；“!”：排除文件 例：!src/a.js(不包含src下的a.js文件)； 1234567891011var gulp = require('gulp'); // 导入第三方gulp插件var less = require('gulp-less'); // 导入第三方gulp-less插件 gulp.task('testLess', function () &#123; // 创建一个testLess任务 // 匹配单个文件 gulp.src('less/test/style.less') // 匹配多个文件（数组） gulp.src(['less/**/*.less','!less/&#123;extend,page&#125;/*.less']) // 匹配less文件夹下的所有.less文件，包括子文件夹下的.less，但是不包括less下的extend和page下的.less文件 .pipe(less()) // 使用gulp-less插件编译less文件 .pipe(gulp.dest('./css')); // 将编译后的css文件存放到当前目录的css文件夹下&#125;); options类型（可选）： Object options.buffer类型： Boolean 默认值： true如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。注意：插件可能并不会实现对 stream 的支持。 options.read类型： Boolean 默认值： true如果该项被设置为 false 那么 file.contents 会返回空值（null），也就是并不会去读取文件。 options.base类型String 默认值：’ ‘设置输出路径以某个路径的某个组成部分为基础向后拼接，将会加在 glob 之前如：请想像一下在一个路径为 client/js/somedir 的目录中，有一个文件叫 somefile.js 12345678// 没有设置base属性gulp.src('client/js/**/*.js') // 匹配 'client/js/somedir/somefile.js' .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/somedir/somefile.js' // 设置 base属性gulp.src('client/js/**/*.js', &#123; base: 'client' &#125;)//设置输出路径为client的js文件夹中，最终变成 'build/js' .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/js/somedir/somefile.js' gulp.dest(path[,options])指定处理后的文件的输出路径。如果某文件夹不存在，将会自动创建它。12345gulp.src('./client/templates/*.jade') .pipe(jade()) .pipe(gulp.dest('./build/templates')) // 将处理后的文件存放到当前文件夹下'build/templates'文件夹中 .pipe(minify()) // 使用gulp-minify插件对文件进行压缩 .pipe(gulp.dest('./build/minified_templates')); // 将处理后的文件存放到当前文件夹下'build/templates'文件夹中 文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。 请查看上述的 gulp.src 来了解更多信息。 path类型（必填）： String 或 Function指定文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。 options类型（可选）： Object options.cwd类型： String 默认值： process.cwd()输出目录的 cwd 参数（前脚本的工作路径），当输出目录是相对路径时候有效。 options.mode类型： String 默认值： 0777八进制权限字符，用以定义在输出目录中所创建的目录的权限。 gulp.task(name[, deps], fn)定义一个使用 Orchestrator 实现的任务（task）。123gulp.task('taskname', function() &#123; // 做一些事&#125;); name类型（必填）：String指定任务的名称，名称中不能包含空格 deps类型（可选）：StringArray指定该任务所依赖的其他任务（注意：被依赖的任务需要返回当前任务的事件流，从而保证任务的执行顺序，请参考如下示例）123456789101112gulp.task('testLess', function () &#123; // 返回事件流，确保该任务执行后才执行minicss任务 return gulp.src(['less/style.less']) .pipe(less()) .pipe(gulp.dest('./css'));&#125;);// minicss任务依赖testLess任务gulp.task('minicss', ['testLess'], function () &#123; //执行完testLess任务后再执行minicss任务 gulp.src(['css/*.css']) .pipe(minifyCss()) .pipe(gulp.dest('./dist/css'));&#125;); fn类型（必填）：Function该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。异步任务支持：任务可以异步执行，如果 fn 能做到以下其中一点 接受一个callback函数 123456789// 在 shell 中执行一个命令var exec = require('child_process').exec;gulp.task('jekyll', function(cb) &#123; // 编译 Jekyll exec('jekyll build', function(err) &#123; if (err) return cb(err); // 返回 error cb(); // 完成 task &#125;);&#125;); 返回一个 stream（事件流） 123456gulp.task('somename', function() &#123; var stream = gulp.src('client/**/*.js') .pipe(minify()) .pipe(gulp.dest('build')); return stream;&#125;); 返回一个 promise 123456789var Q = require('q');gulp.task('somename', function() &#123; var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 1); return deferred.promise;&#125;); 注意： 默认的，task 将以最大的并发数执行，也就是说，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，你需要做两件事： 给出一个提示，来告知 task 什么时候执行完毕， 并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。 对于这个例子，让我们先假定你有两个 task，”one”和 “two”，并且你希望它们按照这个顺序执行： 在 “one” 中，你加入一个提示，来告知什么时候它会完成：可以再完成时候返回一个 callback，或者返回一个 promise 或 stream，这样系统会去等待它完成。 在 “two” 中，你需要添加一个提示来告诉系统它需要依赖第一个 task 完成。 因此，这个例子的实际代码将会是这样：1234567891011var gulp = require('gulp');// 返回一个 callback，因此系统可以知道它什么时候完成gulp.task('one', function(cb) &#123; // 做一些事 -- 异步的或者其他的 cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了&#125;);// 定义一个所依赖的 task 必须在这个 task 执行之后完成gulp.task('two', ['one'], function() &#123; // task 'one' 完成后才执行这里的代码&#125;);gulp.task('default', ['one', 'two']); gulp.watch(glob[, opts], tasks) 与 gulp.watch(glob[, opts, cb])监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。 glob类型（必填）： String 或 StringArray指定需要处理的一个或多个源文件的一个路径匹配符或路径匹配符数组 opts类型（可选）：Object传给 gaze 的参数 ，具体参看 https://github.com/shama/gaze tasks类型(必填)：StringArray需要执行的任务的名称数组 cb(event)类型(可选)：Function每个文件变化执行的回调函数 12345678910111213141516var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); // gulp.watch(glob[, opts], tasks)gulp.task('watch1', function () &#123; gulp.watch('less/**/*.less', ['testLess']);&#125;);// gulp.watch(glob[, opts, cb])gulp.task('watch2', function () &#123; gulp.watch('js/**/*.js', function (event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...'); &#125;);&#125;); 常用插件 插件名称 作用 del 删除文件或文件夹 gulp-less 编译LESS文件 gulp-rname 重命名文件 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 js 文件 gulp-concat-css 合并 css 文件 gulp-cssnano 压缩 css gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-load-plugins 依赖自动加载 gulp-useref 自动合并打包处理 gulp-wrap 包装内容 gulp-angular-templatecache AngularJS 模板缓存 browser-sync 和 gulp 配合使用实现文件改变执行某个任务后自动刷新 yargs 获取命令行参数 gulp-if 根据判断执行某个插件","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"angular 容易遇到的坑","date":"2017-02-11T16:00:00.000Z","path":"2017/02/12/Framework/AngularJS/angular容易遇到的坑/","text":"angular 容易遇到的坑进行遍历ng-repeat的时候要注意是否有重复数据F：我们在进行ng-repeat遍历数组的时候当我们的数据有重复的时候，我们的NG会报错， Q：处理办法是，在我们的要进行数据遍历的地方加入 track by $index 我们在进行事件广播的时候一定要切记的事项我们在进行数据广播的时候，要注意的是我们要进行调用的事件是否已经初始化完毕， 一般处理办法，是进行一个延时广播的操作，这样子就可以就可以避免这个问题了 还有就是我们在进行事件广播的时候一定要避免的是我们的emit和我们的broadcast的事件名称不能相同，不然的话，我们的事件广播会进入一个死循环 还有就是切记不要在我们的controller中操作我们的dom如果必须要进行操作dom的话，我们也要在我们的指令directive 中进行操作，我们在操作过dom之后要进行$scope.$digest()的调用，这样子就可以同步我们的视图和数据了，简单来说，当我们的双向数据绑定发生失效的时候，我们就要调用我们的$scope.$digest()函数，进行数据和视图之间的同步 $scope.$digest()一般情况下，调用这个函数会报错的 为什么不能直接在我们的controller中直接操作我们的dom呢， 因为我们的dom被我们直接操作以后，很容易与我们的NG产生冲突，这样子的话，可能是我们的整个NG模块出现不可预知的问题 当我们的自己调用我们自己写的jsonp的时候，我们的怎么进行数据的刷新$scope. $apply $timeout和我们js的timeout用法基本一致 只是我们在把时间设为0之后，并不会立即执行，只是把我们的匿名函数，放在我们队列的最后面（因为我们的js语言的原理所导致的，因为我们的js是单线程的） 在使用directive（指令）的时候，当我们对外界暴露一个接口的注意事项我们不可以直接在我们的当我们要给我们的接口直接赋值的情况下我们的不要直接给接口一个等于，而是间接地给一个@ 因为我们的如果直接给它赋值的话，如果不加单引号的情况下，会直接报错 例如下面这个指令 appHeadBar.js 123456789101112131415161718192021222324//这儿是我们定义的指令\"use strict\";angular.module(\"app\").directive(\"appHeadBar\",function()&#123; return&#123; restrict:\"A\", replace:true, templateUrl:\"views/template/headBar.html\", //当我们使用这种写法的时候，我们只需要使用下面的第一种写法进行引用即可 scope:&#123; text:\"@\" &#125;, //当我们使用这种写法的时候，我们要使用第二种写法，不然的话，会在浏览器中报错 scope:&#123; text:\"@\" &#125;, link:function($scope)&#123; $scope.back=function()&#123; //这儿window一定要小写 window.history.back(); &#125;; &#125; &#125;;&#125;); post.html 12345&lt;!--写法一--&gt; &lt;div app-head-bar text=\"我的收藏\"&gt;&lt;/div&gt;&lt;!--写法二--&gt;&lt;div app-head-bar text=\"'我的收藏'\"&gt;&lt;/div&gt; ERROR 1Error: [$parse:lexerr] Lexer Error: Unexpected next character at columns 0-0 [我] in expression [我的收藏].","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"gulp搭建静态项目结构","date":"2017-01-10T13:03:08.000Z","path":"2017/01/10/Framework/Gulp/gulp搭建静态项目结构/","text":"基本文件结构123456789├─dist├─node_modules└─src ├─app │ ├─login │ └─register ├─fonts ├─img └─less 安装相关的依赖包12npm install --save angularnpm install --save angular-route gulp del gulp-concat gulp-uglify gulp-yargs gulp-if gulp-less gulp-cssnano gulp-angular-templatecache browser-sync 扩展12# 当根据package.json文件下载安装依赖的时候，如果只想安装生产依赖npm install --production 对文件进行打包操作当写项目的时候需要对项目进行实时打包，合并成单个文件 将静态文件打包到dis中，并保存目录结构 123456789101112131415161718/** * 每次构建dist目录时先删除dist文件 */gulp.task('clear', function(callback) &#123; del(paths.dist) .then(function() &#123; callback() // 保证任务的执行顺序 &#125;)&#125;);/** * 拷贝静态文件到指定目录，每次拷贝前先删除dist文件夹中的内容 */gulp.task('static', ['clear'], function() &#123; return gulp.src(paths.staticPath, &#123; base: './src' //拷贝时，保留src下的目录结构不变 &#125;) .pipe(gulp.dest(paths.dist))&#125;); 将引入的css都打包成一个文件，如： app.css 123456789/** * 编译main.less文件 */gulp.task('less', function() &#123; return gulp.src(paths.lessPath) // lessPath: './src/less/main.less' .pipe(less()) .pipe(gulpif(argv.deploy, css())) .pipe(gulp.dest(paths.lessDist)) // lessPath: './src/less/main.less'&#125;); 将第三方的js文件打包合并成一个 vender.js 文件 123456789/** * 压缩合并第三方依赖的JS文件到指定目录 */gulp.task('vender', function() &#123; return gulp.src(paths.venders) // venders: ['./node_modules/angular/angular.js', './node_modules/angular-route/angular-route.js'], .pipe(concat('vender.js')) // 合并JS代码并取名为vender.js .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.venderDist)) // venderDist: './dist/js'&#125;); 将自己的js文件打包合并成一个 bundle.js 文件 123456789101112131415161718192021222324252627282930313233// html文件中的外部文件路径的引入问题// 使用angular的$templateCache将所有html文件读取出来生成一段js代码/** * 读取app文件夹中所有的html文件自动生成模板字符串缓存 * templatecache参数 * 参数一：fileName默认是templates.js * 参数二：options * root: 生成的路径名 * module：angularjs模块名，默认是templates，然后在主模块中引入该模块 * standalong：创建一个独立的模块 * transformUrl：(类型：function)转换路径，修改原有的生成规则，返回新的路径 * 利用node的内置模块==&gt;node.basename(path) */gulp.task('template', function() &#123; return gulp.src(paths.template) .pipe(templatecache(&#123; module: 'templates', standalong: true, transformUrl: function(url) &#123; return './' + path.basename(url) &#125; &#125;)) //将读取到的html文件生成一段js代码，以字符串的形式存储到缓存中 .pipe(gulpif.dest('./')) //将构建出来的文件存放到&#125;);/** * 压缩合并自己的JS文件到指定目录，包括templates.js文件 */gulp.task('script', ['template'], function() &#123; return gulp.src(paths.scripts) .pipe(concat('bundle.js')) // 合并JS代码 .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.scriptDist))&#125;); 开启服务监视文件改动自动刷新浏览器 123456789101112131415161718192021/** * 监视js文件的变动 */gulp.task('js-watch', function(done) &#123; browserSync.reload() done()&#125;);/** * 开启服务 */gulp.task('server', function() &#123; browserSync.init(&#123; server: &#123; baseDir: path.dist &#125; &#125;) gulp.watch(['./src/app/**/*.js', './src/app/**/*.less', './src/**/*.html' ], ['js-watch'])&#125;); 最终的gulpfile.js这里的代码任务之间的依赖性太强，有很大的优化空间，代码仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * 1. 拷贝静态资源 * 2. 压缩合并第三方JS文件 * 3. 压缩合并自己的JS文件 * 4. 编译压缩less文件 */var gulp = require('gulp')var del = require('del') // 删除文件var concat = require('gulp-concat') // 合并JS文件var uglify = require('gulp-uglify') // 压缩JS文件var argv = require('yargs').argv // 获取命令行参数var gulpif = require('gulp-if') // 根据判断执行某个插件var less = require('gulp-less') // 编译less文件var css = require('gulp-cssnano') // 压缩 cssvar templatecache = require('gulp-angular-templatecache') // 压缩 cssvar path = require('path') // 加载node内置的path方法，解析路径var browserSync = require('browser-sync').create() // 开启服务并和 gulp 配合使用实现文件改变执行某个任务后自动刷新var paths = &#123; staticPath: [ './src/index.html', './src/img/**/*.*', './src/fonts/**/*.*' ], dist: './dist' venders: [ './node_modules/angular/angular.js', './node_modules/angular-route/angular-route.js' ], venderDist: './dist/js', scripts: [ '/templates.js', // 放在前面，保证在合成的时候也是在文件内容的最上面 './src/app/**/*.js' ], scriptDist: './dist/js', lessPath: './src/less/main.less', //其他less文件都引入main.css文件中，最后编译成一个main.css文件 lessDist: './dist/css', template: './src/app/**/*.html'&#125;/** * 每次构建dist目录时先删除dist文件 */gulp.task('clear', function(callback) &#123; del(paths.dist) .then(function() &#123; callback() // 保证任务的执行顺序 &#125;)&#125;);/** * 拷贝静态文件到指定目录 */gulp.task('static', ['clear'], function() &#123; return gulp.src(paths.staticPath, &#123; base: './src' //拷贝时，保留src下的目录结构不变 &#125;) .pipe(gulp.dest(paths.dist))&#125;);/** * 压缩合并第三方依赖的JS文件到指定目录 */gulp.task('vender', ['less'], function() &#123; return gulp.src(paths.venders) .pipe(concat('vender.js')) // 合并JS代码并取名为vender.js .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.venderDist))&#125;);/** * 压缩合并自己的JS文件到指定目录，包括templates.js文件 */gulp.task('script', ['template'], function() &#123; return gulp.src(paths.scripts) .pipe(concat('bundle.js')) // 合并JS代码 .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.scriptDist))&#125;);/** * 编译main.less文件 */gulp.task('less', ['static'], function() &#123; return gulp.src(paths.lessPath) .pipe(less()) .pipe(gulpif(argv.deploy, css())) .pipe(gulp.dest(paths.lessDist))&#125;);// html文件中的外部文件路径的引入问题// 使用angular的$templateCache将所有html文件读取出来生成一段js代码/** * 读取app文件夹中所有的html文件自动生成模板字符串缓存 * templatecache参数 * 参数一：fileName默认是templates.js * 参数二：options * root: 生成的路径名 * module：angularjs模块名，默认是templates，然后在主模块中引入该模块 * standalong：创建一个独立的模块 * transformUrl：(类型：function)转换路径，修改原有的生成规则，返回新的路径 * 利用node的内置模块==&gt;node.basename(path) */gulp.task('template', ['vender'], function() &#123; return gulp.src(paths.template) .pipe(templatecache(&#123; module: 'templates', standalong: true, transformUrl: function(url) &#123; return './' + path.basename(url) &#125; &#125;)) //将读取到的html文件生成一段js代码，以字符串的形式存储到缓存中 .pipe(gulpif.dest('./')) //将构建出来的文件存放到&#125;);/** * 监视js文件的变动 */gulp.task('js-watch', ['script'], function(done) &#123; browserSync.reload() done()&#125;);/** * 开启服务 */gulp.task('server', ['script'], function() &#123; browserSync.init(&#123; server: &#123; baseDir: path.dist &#125; &#125;) gulp.watch(['./src/app/**/*.js', './src/app/**/*.less', './src/**/*.html' ], ['js-watch'])&#125;);","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"windows 免费升级win10","date":"2016-11-11T16:00:00.000Z","path":"2016/11/12/Others/免费更新win10/","text":"windows 免费升级win10 下载win10安装软件 正常来说去年win10已经停止了免费更新，氮素！还是留了个后门的，就是— 面向使用辅助技术的客户的 Windows 10 免费升级优惠 （反正就是给不是正常人使用的，但是跟正常系统是一样的）； 点击【立即升级】按钮即可，官方版本不用担心有乱七八糟的东西； 然而有些电脑是需要激活才能升win10的，我是试过好多的激活码都不管用，当然网上还有一些其他激活的教程，我是选择了最简单的，下软件,用的是 oem7小马激活工具 一键傻瓜式操作； 后面就简单了，用前面下的win10工具下载呗，建议网速好的情况，最好是晚上下，差不多3g？下载完成后，也会自动安装的； 如果电脑内存不大，略卡的情况可以度娘一下，进行各种优化；实在卡的不行，也可以选择恢复的，在安装时已经帮你自动保存了以前的版本； PS：如果电脑原来是32bit的，升级了也还是32bit，想升64bit好像只能重装？反正直接升win10是不行的；","tags":[{"name":"windows,windows 10","slug":"windows-windows-10","permalink":"http://yoursite.com/tags/windows-windows-10/"}]},{"title":"Directive的基本使用","date":"2016-10-03T13:50:52.000Z","path":"2016/10/03/Framework/AngularJS/directive/","text":"angular directive什么是指令呢？我们先看官方的说法 What are Directives?At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS’s HTML compiler ($compile) to attach a specified behavior to that DOM element (e.g. via event listeners), or even to transform the DOM element and its children. AngularJS comes with a set of these directives built-in, like ngBind, ngModel, and ngClass. Much like you create controllers and services, you can create your own directives for AngularJS to use. When AngularJS bootstraps your application, the HTML compiler traverses the DOM matching directives against the DOM elements. 在高的层面上讲，指令是DOM元素中的标记(例如一个属性，一个节点名，注释或者CSS类)，它告诉angularjs编译器去给这个元素附加一个指令的行为或者转换DOM元素和它的子元素。 Angularjs拥有一些内建的指令，像ngBind、ngModel和ngClass。非常类似于你创建自己的controller和service，你可以创建你自己的指令个angularjs使用，当angular初始化启动你的应用程序，html编译器将遍历你的DOM元素并且去匹配指令。 实例解析expander 实例解析accordion 指令的运行原理 compile和link restrict匹配模式 A 属性 &lt;div hello&gt;&lt;/div&gt; E element 元素 &lt;hello&gt;&lt;/hello&gt; M 注释 &lt;!-- directive:hello --&gt; 要加空格 &lt;div&gt;&lt;/div&gt; C 样式类 &lt;div class=&quot;hello&quot;&gt;&lt;/div&gt; 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt;&lt;/hello&gt; &lt;div hello&gt;&lt;/div&gt; &lt;div class=\"hello\"&gt;&lt;/div&gt; &lt;!-- directive:hello --&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"HelloAngular_Directive.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict: 'AEMC', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', replace: true &#125;&#125;); templateUrl:模板 12345678910111213141516var myModule = angular.module(\"MyModule\", []);//注射器加载完所有模块时，此方法执行一次myModule.run(function($templateCache)&#123; //把内容缓存起来 $templateCache.put(\"hello.html\",\"&lt;div&gt;Hello everyone!!!!!!&lt;/div&gt;\");&#125;);myModule.directive(\"hello\", function($templateCache) &#123; return &#123; restrict: 'AECM', //把缓存取出来 template: $templateCache.get(\"hello.html\"), replace: true &#125;&#125;); replace开启的话，就会把我们模板里面的内容替换掉 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt; //当我们的页面启动后就会把这段内容替换掉 &lt;div&gt;这里是指令内部的内容。&lt;/div&gt; &lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"replace.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict:\"AE\", template:\"&lt;div&gt;Hello everyone!&lt;/div&gt;\", replace:true &#125; &#125;); ng-transclude只有这个指令可以使用多个多个指令之前多层嵌套，所以很重要 12345678910111213&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt; &lt;div&gt;这里是指令内部的内容。&lt;/div&gt; &lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"transclude.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict:\"AE\", transclude:true, // ng-transclude告诉angular被替换的内容填充到哪里去 template:\"&lt;div&gt;Hello everyone!&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;\" &#125; &#125;); link取属性的方式添加监听事件，以及实现指令与多个控制器之间进行交互 1234567891011121314151617&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; &lt;loader howToLoad=\"loadData()\"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;div ng-controller=\"MyCtrl2\"&gt; //定义属性这样让我们的directive去调用 &lt;loader howToLoad=\"loadData2()\"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Directive&amp;Controller.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.loadData=function()&#123; console.log(\"加载数据中...\"); &#125;&#125;]);myModule.controller('MyCtrl2', ['$scope', function($scope)&#123; $scope.loadData2=function()&#123; console.log(\"加载数据中...22222\"); &#125;&#125;]);myModule.directive(\"loader\", function() &#123; return &#123; restrict:\"AE\", link:function(scope,element,attrs)&#123; //这里和jquery一样，给这个loader directive元素添加一个mouseenter事件，然后去调用上面的函数 element.bind('mouseenter', function(event) &#123; //scope.loadData(); //强制刷新以及调用上面的函数 // scope.$apply(\"loadData()\"); // 注意这里的坑，howToLoad会被转换成小写的howtoload //给我们的页面上的指令加了属性，然后通过不同的属性来调用不同函数，这样子也实现了指令的 //复用，指令就是为了复用，就可以在不同的控制器中去复用指令，以及实现数据交互 scope.$apply(attrs.howtoload); &#125;); &#125; &#125; &#125;); link实现多个指令之间的通信1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Directive&amp;Directive.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength&gt;动感超人---力量&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength speed&gt;动感超人2---力量+敏捷&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength speed light&gt;动感超人3---力量+敏捷+发光&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var myModule = angular.module(\"MyModule\", []);myModule.directive(\"superman\", function() &#123; return &#123; //创建独立作用域，下面一个例子会讲解独立scope scope: &#123;&#125;, restrict: 'AE', //指令内部的controller，作用是我们的指令暴露出public方法供外部使用 controller: function($scope) &#123; $scope.abilities = []; this.addStrength = function() &#123; $scope.abilities.push(\"strength\"); &#125;; this.addSpeed = function() &#123; $scope.abilities.push(\"speed\"); &#125;; this.addLight = function() &#123; $scope.abilities.push(\"light\"); &#125;; &#125;, //link是指令内部的一些方法 link: function(scope, element, attrs) &#123; //给我们的元素增加classname element.addClass('btn btn-primary'); //绑定事件 element.bind(\"mouseenter\", function() &#123; console.log(scope.abilities); &#125;); &#125; &#125;&#125;);myModule.directive(\"strength\", function() &#123; return &#123; //require是说strength指令依赖于superman这个指令 require: '^superman', //当有了依赖之后，我们就可以注入第四个参数了，这样子我们就可以访问到supermanCtrl里面暴露出来的公用方法了 link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addStrength(); &#125; &#125;&#125;);myModule.directive(\"speed\", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addSpeed(); &#125; &#125;&#125;);myModule.directive(\"light\", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addLight(); &#125; &#125;&#125;); 独立scpe123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"IsolateScope.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict: 'AE', // scope:&#123;&#125;,// 如果不加这个参数的话，我们页面中所有的指令都会同时发生改变互相影响，这显然是不是我们想要的 template: '&lt;div&gt;&lt;input type=\"text\" ng-model=\"userName\"/&gt;&#123;&#123;userName&#125;&#125;&lt;/div&gt;', replace: true &#125;&#125;); scope绑定策略 @绑定 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; //需要注意的是@绑定传递的是字符串，而不是对象 &lt;drink flavor=\"&#123;&#123;ctrlFlavor&#125;&#125;\"&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeAt.js\"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314151617181920var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; //控制器上面加个一个属性 $scope.ctrlFlavor=\"百威\";&#125;])myModule.directive(\"drink\", function() &#123; return &#123; restrict:'AE', scope:&#123; //而这种方式angular则会帮我们自动绑定数据 flavor:'@' &#125;, template:\"&lt;div&gt;&#123;&#123;flavor&#125;&#125;&lt;/div&gt;\" // , //下面这种方式指定我们的flavor的数据是我们的控制器中的数据 // link:function(scope,element,attrs)&#123; // scope.flavor=attrs.flavor; // &#125; &#125;&#125;); ScopeEqual绑定 进行双向数据绑定，也就是我们控制器与指令之间进行双向的数据绑定 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; Ctrl: &lt;br&gt; //这儿是我们控制器中的ctrlFlavor &lt;input type=\"text\" ng-model=\"ctrlFlavor\"&gt; &lt;br&gt; Directive: &lt;br&gt; //这儿展示我们指令中的flavor &lt;drink flavor=\"ctrlFlavor\"&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeEqual.js\"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.ctrlFlavor=\"百威\";&#125;])myModule.directive(\"drink\", function() &#123; return &#123; restrict:'AE', scope:&#123; //用=绑定就可以只要改变我们指令中的flavor就可以改变我们的控制器中的ctrlFlavor，反之我们改变控制器中的也可以改变指令中的 flavor:'=' &#125;, template:'&lt;input type=\"text\" ng-model=\"flavor\"/&gt;' &#125;&#125;); &amp;scope 实现控制器与指令之间的交互，比link要方便,传递一个来自父scope的函数，稍后调用 1234567891011121314151617&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; //这里我们传递的参数是对象，跟上面说的@scope不同 &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeAnd.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819var myModule = angular.module(\"MyModule\", [] ;myModule.controller('MyCtrl', ['$scope', function($scope)&#123; //暴露出一个方法就可以被我们的指令进行调用 $scope.sayHello=function(name)&#123; alert(\"Hello \"+name); &#125;&#125;])myModule.directive(\"greeting\", function() &#123; return &#123; restrict:'AE', scope:&#123; greet:'&amp;' &#125;, //在下面我们添加一个方法进行调用我们上面的控制器暴露出来的sayHello方法 //传递参数的形式是对象的形式 template:'&lt;input type=\"text\" ng-model=\"userName\" /&gt;&lt;br/&gt;'+ '&lt;button class=\"btn btn-default\" ng-click=\"greet(&#123;name:userName&#125;)\"&gt;Greeting&lt;/button&gt;&lt;br/&gt;' &#125;&#125;); angular内置指令在我用的1.3.11中共计63个 form指令 FormBasic 12345678910111213141516&lt;html ng-app='TestFormModule'&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormBasic.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form name=\"myForm\" ng-submit=\"save()\" ng-controller=\"TestFormModule\"&gt; //required属性就是我们的angular帮我们自动校验 &lt;input name=\"userName\" type=\"text\" ng-model=\"user.userName\" required/&gt; &lt;input name=\"password\" type=\"password\" ng-model=\"user.password\" required/&gt; //ng-disabled把它绑定到myForm.$invalid上就可以判断我们的按钮是否可用的状态 &lt;input type=\"submit\" ng-disabled=\"myForm.$invalid\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345678910var appModule = angular.module('TestFormModule', []);appModule.controller(\"TestFormModule\",function($scope)&#123; $scope.user=&#123; userName:'damoqiongqiu', password:'' &#125;; $scope.save=function()&#123; alert(\"保存数据!\"); &#125;&#125;); formadv1 下面是复杂一点的表单 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html ng-app&gt; &lt;head&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormAdv1.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"Controller\"&gt; &lt;form name=\"form\" class=\"css-form\" novalidate&gt; Name: &lt;input type=\"text\" ng-model=\"user.name\" name=\"uName\" required /&gt;&lt;br/&gt; E-mail: &lt;input type=\"email\" ng-model=\"user.email\" name=\"uEmail\" required /&gt;&lt;br/&gt; //校验我们的Email是否合法form.uEmail.$dirty &amp;&amp; form.uEmail.$invalid &lt;div ng-show=\"form.uEmail.$dirty &amp;&amp; form.uEmail.$invalid\"&gt; Invalid: &lt;span ng-show=\"form.uEmail.$error.required\"&gt;Tell us your email.&lt;/span&gt; &lt;span ng-show=\"form.uEmail.$error.email\"&gt;This is not a valid email.&lt;/span&gt; &lt;/div&gt; Gender:&lt;br/&gt; &lt;input type=\"radio\" ng-model=\"user.gender\" value=\"male\" /&gt; male &lt;input type=\"radio\" ng-model=\"user.gender\" value=\"female\" /&gt; female&lt;br/&gt; &lt;input type=\"checkbox\" ng-model=\"user.agree\" name=\"userAgree\" required /&gt; I agree: &lt;input ng-show=\"user.agree\" type=\"text\" ng-model=\"user.agreeSign\" required /&gt; &lt;div ng-show=\"!user.agree || !user.agreeSign\"&gt; Please agree and sign. &lt;/div&gt; &lt;br/&gt; &lt;button ng-click=\"reset()\" ng-disabled=\"isUnchanged(user)\"&gt; RESET &lt;/button&gt; &lt;button ng-click=\"update(user)\" ng-disabled=\"form.$invalid || isUnchanged(user)\"&gt; SAVE &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617function Controller($scope) &#123; $scope.master = &#123;&#125;; $scope.update = function(user) &#123; $scope.master = angular.copy(user); &#125;; $scope.reset = function() &#123; $scope.user = angular.copy($scope.master); &#125;; $scope.isUnchanged = function(user) &#123; return angular.equals(user, $scope.master); &#125;; $scope.reset();&#125; 下面说一个比较酷的功能 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html ng-app=\"form-example2\"&gt; &lt;head&gt; &lt;link href=\"../bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\" media=\"screen\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormCustom.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div[contentEditable] &#123; cursor: pointer; background-color: #D0D0D0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; //开启contentEditable可以让我们的div有input的功能 &lt;div contentEditable=\"true\" ng-model=\"content\" title=\"Click to edit\"&gt;Some&lt;/div&gt; &lt;pre&gt;model = &#123;&#123;content&#125;&#125;&lt;/pre&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021angular.module('form-example2', []).directive('contenteditable', function() &#123; return &#123; require : 'ngModel', link : function(scope, elm, attrs, ctrl) &#123; // view -&gt; model elm.bind('keyup', function() &#123; scope.$apply(function() &#123; ctrl.$setViewValue(elm.text()); &#125;); &#125;); // model -&gt; view ctrl.$render = function() &#123; elm.html(ctrl.$viewValue); &#125;; // load init value from DOM ctrl.$setViewValue(elm.html()); &#125; &#125;;&#125;); 自定义指令 123456789101112131415&lt;html ng-app='expanderModule'&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"ExpanderSimple.css\"/&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ExpanderSimple.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller='SomeController'&gt; &lt;expander class='expander' expander-title='title'&gt; &#123;&#123;text&#125;&#125; &lt;/expander&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031var expanderModule=angular.module('expanderModule', []);expanderModule.directive('expander', function() &#123; return &#123; //这里我们的匹配模式定义的是也可以用元素也可以用属性 restrict : 'EA', // 替换 replace : true, //内部的内容是可以变换的 transclude : true, scope : &#123; //用=号进行scope双向数据绑定 title : '=expanderTitle' &#125;, //ng-click=\"toggle()这里的click只能调用我们内部的toggle template : '&lt;div&gt;' + '&lt;div class=\"title\" ng-click=\"toggle()\"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' + '&lt;div class=\"body\" ng-show=\"showMe\" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', link : function(scope, element, attrs) &#123; scope.showMe = false; //这里我们定义的toggle只能在指令内部进行调用 scope.toggle = function() &#123; scope.showMe = !scope.showMe; &#125; &#125; &#125;&#125;);expanderModule.controller('SomeController',function($scope) &#123; $scope.title = '点击展开'; $scope.text = '这里是内部的内容。';&#125;); 123456789101112131415.expander &#123; border: 1px solid black; width: 250px;&#125;.expander&gt;.title &#123; background-color: black; color: white; padding: .1em .3em; cursor: pointer;&#125;.expander&gt;.body &#123; padding: .1em .3em;&#125; 再来一个 123456789101112131415&lt;html ng-app=\"expanderModule\"&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"Accordion.css\"/&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Accordion.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-controller='SomeController' &gt; &lt;accordion&gt; &lt;expander class='expander' ng-repeat='expander in expanders' expander-title='expander.title'&gt; &#123;&#123;expander.text&#125;&#125; &lt;/expander&gt; &lt;/accordion&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var expModule=angular.module('expanderModule',[])expModule.directive('accordion', function() &#123; return &#123; restrict : 'EA', replace : true, transclude : true, template : '&lt;div ng-transclude&gt;&lt;/div&gt;', //对外暴露方法 controller : function() &#123; var expanders = []; this.gotOpened = function(selectedExpander) &#123; angular.forEach(expanders, function(expander) &#123; if (selectedExpander != expander) &#123; expander.showMe = false; &#125; &#125;); &#125; this.addExpander = function(expander) &#123; expanders.push(expander); &#125; &#125; &#125;&#125;);expModule.directive('expander', function() &#123; return &#123; restrict : 'EA', replace : true, transclude : true, //依赖于accordion指令 require : '^?accordion', scope : &#123; title : '=expanderTitle' &#125;, template : '&lt;div&gt;' + '&lt;div class=\"title\" ng-click=\"toggle()\"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' + '&lt;div class=\"body\" ng-show=\"showMe\" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', link : function(scope, element, attrs, accordionController) &#123; scope.showMe = false; accordionController.addExpander(scope); scope.toggle = function toggle() &#123; scope.showMe = !scope.showMe; accordionController.gotOpened(scope); &#125; &#125; &#125;&#125;);expModule.controller(\"SomeController\",function($scope) &#123; $scope.expanders = [&#123; title : 'Click me to expand', text : 'Hi there folks, I am the content that was hidden but is now shown.' &#125;, &#123; title : 'Click this', text : 'I am even better text than you have seen previously' &#125;, &#123; title : 'Test', text : 'test' &#125;];&#125;); 123456789101112131415.expander &#123; border: 1px solid black; width: 250px;&#125;.expander&gt;.title &#123; background-color: black; color: white; padding: .1em .3em; cursor: pointer;&#125;.expander&gt;.body &#123; padding: .1em .3em;&#125; 看到没，其实编写自定义指令还是比较困难的，所以我们可以去引入一些第三方的指令库 这样子，就可以极大地方便实现我们想要的功能了 再来个难一点的自定义指令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"framework/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;link rel=\"stylesheet\" href=\"common.css\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"framework/ui-bootstrap-tpls-0.11.0.js\"&gt;&lt;/script&gt; &lt;script src=\"Accordion-ngui.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;div ng-controller=\"AccordionDemoCtrl\"&gt; &lt;p&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"status.open = !status.open\"&gt;Toggle last panel&lt;/button&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"status.isFirstDisabled = ! status.isFirstDisabled\"&gt;Enable / Disable first panel&lt;/button&gt; &lt;/p&gt; &lt;label class=\"checkbox\"&gt; &lt;input type=\"checkbox\" ng-model=\"oneAtATime\"&gt;Open only one at a time &lt;/label&gt; &lt;accordion close-others=\"oneAtATime\"&gt; &lt;accordion-group heading=\"Static Header, initially expanded\" is-open=\"status.isFirstOpen\" is-disabled=\"status.isFirstDisabled\"&gt; This content is straight in the template. &lt;/accordion-group&gt; &lt;accordion-group heading=\"&#123;&#123;group.title&#125;&#125;\" ng-repeat=\"group in groups\"&gt; &#123;&#123;group.content&#125;&#125; &lt;/accordion-group&gt; &lt;accordion-group heading=\"Dynamic Body Content\"&gt; &lt;p&gt;The body of the accordion group grows to fit the contents&lt;/p&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"addItem()\"&gt;Add Item&lt;/button&gt; &lt;div ng-repeat=\"item in items\"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/accordion-group&gt; &lt;accordion-group is-open=\"status.open\"&gt; &lt;accordion-heading&gt; I can have markup, too! &lt;i class=\"pull-right glyphicon\" ng-class=\"&#123;'glyphicon-chevron-down': status.open, 'glyphicon-chevron-right': !status.open&#125;\"&gt;&lt;/i&gt; &lt;/accordion-heading&gt; This is just some content to illustrate fancy headings. &lt;/accordion-group&gt; &lt;/accordion&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627var myModule = angular.module('MyModule', ['ui.bootstrap']);myModule.controller('AccordionDemoCtrl', ['$scope', function($scope) &#123; $scope.oneAtATime = true; $scope.groups = [&#123; title: 'Dynamic Group Header - 1', content: 'Dynamic Group Body - 1' &#125;, &#123; title: 'Dynamic Group Header - 2', content: 'Dynamic Group Body - 2' &#125;]; $scope.items = ['Item 1', 'Item 2', 'Item 3']; $scope.addItem = function() &#123; var newItemNo = $scope.items.length + 1; $scope.items.push('Item ' + newItemNo); &#125;; $scope.status = &#123; isFirstOpen: true, isFirstDisabled: false &#125;; &#125;])","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"node的安装和npm的简单介绍","date":"2016-03-05T16:00:00.000Z","path":"2016/03/06/Framework/Node/node的安装和npm的简单介绍/","text":"下载nodejs打开nodejs官网，你会看到两个绿色的按钮，一个是目前大多数人在用的，一个是目前最新的版本，的需要下载即可，它会根据系统信息选择对应版本（.msi文件）。然后像安装QQ一样安装它就可以了（安装路径随意） 检测nodejs是否安装上了打开命令提示符执行下列命令（打开方式：window + r 输入cmd回车）： node -v查看安装的nodejs版本，出现版本号，说明刚刚已正确安装nodejs。 npm -v查看npm的版本号，npm是在安装nodejs时一同安装的nodejs包管理器。 如果输入命令后告诉你node不是内部命令，那么请看下步配置环境变量 如果上述都能正常执行，恭喜你，安装成功了 配置环境变量 找到nodejs的安装目录，拷贝路径地址，默认是（C:\\Program Files\\nodejs） 找到桌面我的电脑图标，右键点击属性菜单弹出系统面板 点击系统面板的高级系统设置，弹出系统属性面板 点击属性面板的环境变量按钮，弹出环境变量面板 找到系统变量的path，双击，将nodejs的bin目录url添加到后面即可注意：在添加的时候确保前面有一个英文的分号 配置完之后继续输入命令，查看node和npm的版本npm介绍npm官网 说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）； 使用npm安装插件：命令提示符执行npm install &lt;name&gt; [-g] [--save-dev]； &lt;name&gt;：node插件名称。例：npm install gulp-less --save-dev -g：全局安装。将会安装C:\\Users\\Administrator\\AppData\\Roaming\\npm，并且写入系统环境变量； 非全局安装：将会安装在当前定位目录； 全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用； --save：将保存配置信息至package.json（package.json是nodejs项目配置文件）； -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；一般保存在dependencies的像这些express/ejs/body-parser等等。 为什么要保存至package.json？因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install --production 只下载dependencies节点的包）。 使用npm卸载插件：npm uninstall &lt;name&gt; [-g] [--save-dev] PS：不要直接删除本地插件包 删除全部插件：npm uninstall gulp-less gulp-uglify gulp-concat ……???太麻烦，请看下一个 借助rimraf：npm install rimraf -g 用法：rimraf node_modules 使用npm更新插件：npm update &lt;name&gt; [-g] [--save-dev] 更新全部插件：npm update [--save-dev] 查看npm帮助：npm help 当前目录已安装插件：npm listPS：npm安装插件过程：从 http://registry.npmjs.org 下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法往下看↓↓↓↓↓↓。 选装cnpm 说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。32个赞！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”； 官方网址：http://npm.taobao.org； 安装：命令提示符执行npm install cnpm -g --registry=https://registry.npm.taobao.org； 注意：安装完后最好查看其版本号 cnpm -v 或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"hexo图片链接问题","date":"2015-03-14T13:03:08.000Z","path":"2015/03/14/Hexo/hexo图片链接问题/","text":"文章转载自 http://www.tuicool.com/articles/umEBVfI 1. 起因在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。 这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。 hexo 下插入图片现在大概有几个方案 1.1 放在根目录早期大部分的方案是把图片放在 source/img 下，然后在 markdown 里写 ![img](/source/img/img.png) 。显然这样在本地的编辑器里完全不能正确识别图片的位置。 1.2 asset-image在 hexo 2.x 时出现的插件，后来被吸纳进 hexo 3 core ，用法的介绍见 资源文件夹 | Hexo 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 的语法。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。 2. 解决方案CodeFalling/hexo-asset-image 2.1 使用首先确认_config.yml 中有 post_asset_folder:true 。 在 hexo 目录，执行1npm install https://github.com/CodeFalling/hexo-asset-image --save 假设在 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg) 就可以插入图片。 生成的结构为12345public/2015/10/18/MacGesture2-Publish├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是1&lt;img src=\"/2015/10/18/MacGesture2-Publish/logo.jpg\" alt=\"logo\"&gt; 而不是愚蠢的1&lt;img src=\"MacGesture2-Publish/logo.jpg\" alt=\"logo\"&gt; 值得一提的是，这个插件对于 CodeFalling/hexo-renderer-org 同样有效。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"javascript之变量","date":"2015-03-10T13:40:20.000Z","path":"2015/03/10/JavaScript/javascript之变量/","text":"变量的定义在javascript中定义变脸是通过关键字 var、function 定义的，在ES6中还可以用let、const 的方式定义变量123456var str = &quot;hello world&quot;; // 定义了一个值为“hello world”的String类型变量var num = 10; // 定义了一个值为10的Number类型变量var boolean = true; // 定义了一个值为true的Boolean类型变量function ()&#123; // 定义一个Function类型，名为fn的函数 // 函数体&#125; javascript变量命名规范 规则（必须遵守） 由字母、数字、下划线、$组成 不能是关键字和保留字 区分大小写 规范（建议遵守） 变量的名称要有意义 变量的命名遵守驼峰命名法，首字母小写，第二个单词的首字母大写（eg：userName） 变量类型基本数据类型Number类型 整数 十进制 八进制 1) 如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当做十进制数值解析 十六进制 浮点数 小数 科学计数法 浮点数的最高精度是17位小数，但在进行算数计算时其精度远远不如整数 var result = 0.1 + 0.2;//结果不等于0.3，而是0.300000000000000004 永远不要测试某个特定的浮点数值（不要判断两个浮点数是否相等） 数值范围 最小值：Number.MIN_VALUE，这个值为：5e-324 最大值：Number.MAX_VALUE，这个值为：1.7976931348623157e+308 无穷大：Infinity 无穷小：-infinity 数值检测 NaN非数值（Not a Number） NaN与任何值都不相等，包括自身 isNaN( 值 )：任何不能被转换为数值的值都会导致这个函数返回true String类型 字符串字面量 字符串要用引号引起，单引号和双引号的作用是等效的 字符串是由一个个字符组成的，获取一个字符串的长度可以使用length属性 转义符 字符串的不可变—-&gt;其他类型重新赋值直接在内存上修改，字符串的修改要重新申请内存 ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变 要改变某个变量保存的字符串，需要重新开辟内存空间，然后修改变量的地址指向，之前的地址会被javascript垃圾回收机制不定时回收 如果两个字符串变量值相同，则指向相同的内存地址 123var a = \"hello\";var b = \"hello\";console.log(a === b); //true 把字符串当做数组看的话，修改字符串的某个字符（按下标访问），并不能够修改该字符串，说明字符串不可变 字符串类型是存储在堆内存中的 字符串拼接，字符串变量相加会把变量的值连接起来 Boolean类型 false、true 区分大小写 虽然只有两个值，但是所有类型中都有有着两个值等价的值 其他类型转换为布尔值 Undefined类型 表示变量未赋值 只有一种值就是undefined undefined是Undefined类型的字面量 类型转换 目标：掌握三种类型的转换 转换成字符串类型 转换成数值类型 转换成布尔类型 转换成字符串类型 toString()方法——变量.toString() 变量.toString()，转换成字符串 数值类型的toString(进制数)—&gt;将数值类型转换成几进制数值字符串 null和undefined没有toString()方法 String()方法——String（变量）- 存在的意义：有些值没有toString()方法，这个时候可以用String()方法，比如undefined和null 字符串拼接—&gt; + 转换成数值类型 Number()：可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN 可以把true和false转换成 1和0 如果是空字符串，会转换成0 parseInt()：把字符串转换成整数 会忽略前面的空格，直到找到第一个字符串为止，还会将后面的非数字字符串去掉 “ 123abc”会转换成123， 如果第一个字符不是数字或者正负号，返回NaN “abc123”会转换成NaN “-123”会转换为-123-“+123”会转换为123 可以传递两个参数 要转换的字符串 第二个是要转换的数原先为几进制数，在2到36之间，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 parseFloat()：把字符串转换成浮点数 转换方式与parseInt一样 parseInt()和parseFloat()的区别 parseFloat()会解析第一个，遇到第二个或者非数字结束 parseFloat()不支持第二个参数，只能解析10进制数 parseFloat()如果解析的内容里只有整数，解析成整数 10.00会被解析成10 转换成布尔类型——Boolean（变量） Boolean()方法 流程控制语句会把后面的值隐式转换成布尔类型 “ ！ ”运算符 转换成为false的值：false、””、0、和NaN、null、undefined 隐式转换 转number +、-、*、/、%都会把变量转换成number类型 +号的隐式转换必须写在变量的前面：eg: +”a” 、 +”undefined”、+”NaN” 转string var a = 123; a = a + “”; 转boolean var a = 123; a = !a; 复杂数据类型ObjectFunction####","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript之基本介绍","date":"2015-03-05T13:23:08.000Z","path":"2015/03/05/JavaScript/javascript之基本介绍/","text":"javascript语言特点 javascript是一门弱类型、动态类型、解析型的脚本语言 弱类型：定义变量不需要指定变量类型 动态类型： 执行时才知道变量到底是什么类型 对象想要有属性或方法，直接 . 或者[“属性名”]就可以 解析型：一行一行解析，解析一行执行一行 脚本语言：不需要编译，直接运行时边解析边执行的语言 编译：一次性把代码转换成cpu可以看懂的语言，一行一行执行，执行速度快 解释：一行一行解析，解析一行执行一行，执行速度慢 javascript是一种客户端的脚本语言 浏览器的工作原理 浏览器基本组成 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的你请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。 渲染引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码，比如chrome的javascript解释器是V8。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5)定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 详细文章请移步 javascript组成部分 ECMAScript： javascript的语法规范 DOM： javascript操作网页上元素的API BOM： javascript操作浏览器部分功能的API javascript的使用方式 内嵌式（html页面编写javascript代码） 123&lt;script type=\"text/javascript\"&gt; // 你的javascript代码&lt;/script&gt; 外联式（在js文件中编写javascript代码，在html页面中引入js文件） src：引入文件的地址 type：引入的文件类型 写法一：type=”text/javascript” 写法二：language=”javascript” async：异步 交给浏览器去异步下载，不会阻塞程序的执行 js文件下载完就可以立马执行 sync：同步 只能一个任务一个任务的执行会阻塞程序的执行 defer： 等html文档加载并显示完之后才执行下载完的js代码 只有外部脚本才可以使用 1&lt;script src=\"/javascripts/application.js\" type=\"text/javascript\" charset=\"utf-8\" async defer&gt;&lt;/script&gt; 内联式（在html标签中编写javascript代码）1&lt;input type=\"buttom\" onclick=\"function()&#123;&#125;\"&gt; javascript注释注释的应用 - 一般用于解释某些复杂代码的逻辑，方便后期的维护与开发 - 用于对整个模块进行分割划分，方便于代码查找和维护 - 用于：模块、函数、复杂逻辑注释、文件注解、维护记录等 12345//单行注释/*多行注释*//** * 注解内容 */ 好了，现在你可以开始编写你的javascript代码了","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"Hello World","date":"2015-03-01T13:50:52.000Z","path":"2015/03/01/Hexo/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]