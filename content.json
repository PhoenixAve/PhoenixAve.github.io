[{"title":"vuex核心概念","date":"2017-04-06T09:04:19.000Z","path":"2017/04/06/Framework/Vue/vuex核心概念/","text":"[toc] 这几天一直在学习vuex的使用，自己也做了一个小Demo，基本算是会用了，现在就把如何使用vuex整理一下，方便理解以及以后的使用方便，本文需要有一定的 ES6 的基础，比如结构赋值，箭头函数等，如果你不懂这些的话，建议先去看看阮一峰的ECMAScript 6 入门 vuex的使用有两种方式 局部使用 全局注册局部注册需要在每个组建中注册，比较麻烦，因此推荐使用全局注册的方式，如果想学习局部注册，请看vuex官方文档 State 保存状态的属性在 Vue 组件中获得 Vuex 状态由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态 12345678910111213141516import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 全局vue组件const app = new Vue(&#123; el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件，且子组件能通过 this.$store 访问到 store, components: &#123; Counter &#125;, template: ` &lt;div class=\"app\"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现 123456789// 子组件Counterconst Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count // 通过 this.$store 访问store中存储的内容 &#125; &#125;&#125; mapState 辅助函数每次都使用 this.$store.state 获取状态是不是很麻烦呢，所以官方给我们提供了 mapState 辅助函数，由于该函数返回的是一个对象，而计算属性 computed 也是一个对象，因此可以直接将函数的返回值赋给计算属性 computed，所以才有了以下的写法 使用 mapState 时， mapState 内部的函数会接收一个 state 参数，在函数中可以直接通过 state 去访问store.state的中的属性 123456789101112131415161718// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练，但是修改了this指向 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', //暂时还没明白是什么意思 // 为了能够使用 `this` 获取局部组件的状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 当 mapState 映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 1234computed: mapState([ // 映射 this.count 为 this.$store.state.count，可以直接使用this.count，代替 'count']) 当我们需要编写自己的计算属性时，上面的写法就不能满足了，因此可以使用对象展开运算符 1234567computed: &#123; localComputed () &#123; /* ... */ &#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState(&#123; // ... &#125;)&#125; Getters 比作 store 的计算属性有时候我们需要对 store 中的一些状态进行计算，如果只有一个组件的话还好，可是有多个组件同时需要用到这种计算呢，此时我们就可以使用 getters 了 因为 Getters 只是提供了计算功能，因此我们需要在计算属性中去使用 Getters ，从而达到状态更新时，得到的结果也能一起更新Getters 会暴露为 store.getters 对象：可以在子组件中通过 this.$store.getters 调用 getters 的方法getters 中的函数接收的第一个参数是 state， 第二个参数是其他的 getters，第二个参数也可以不写 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 在子组件中调用 getters 中的函数 12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; Getters 接受其他 getters 作为第二个参数的用法 123456getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125; mapGetters 辅助函数又是同样的套路，为了不用重复写 this.$store.getters ，官方又提供了 mapGetters 辅助函数 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getters 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 如果你想将一个getter 属性另取一个名字，使用对象形式： 1234mapGetters(&#123; // 映射 this.doneCount 为 store.getters.doneTodosCount doneCount: 'doneTodosCount'&#125;) Mutations 提交状态更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 子组件想要提交状态的更改需要使用 store.commit 方法 1this.$store.commit('increment') 提交载荷（Payload）你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）： 传递普通类型的参数 123456// ...mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125; 1this.$store.commit('increment', 10) 传递一个对象在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读 123456// ...mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; 123this.$store.commit('increment', &#123; amount: 10&#125;) 对象风格的提交方式提交 mutation 的另一种方式是直接使用包含 type 属性的对象 1234this.$store.commit(&#123; type: 'increment', amount: 10&#125;) 当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变： 12345mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; Mutations 需遵守 Vue 的响应规则既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, &#39;newProp&#39;, 123), 或者 - 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写： 1state.obj = &#123; ...state.obj, newProp: 123 &#125; 使用常量替代 Mutation 事件类型使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： 12// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION' 12345678910111213// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) 用不用常量取决于你 —— 在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。 mutation 必须是同步函数一条重要的原则就是要记住 mutation 必须是同步函数。如果想要执行异步函数，请使用 Actions 在组件中提交 Mutations你可以在组件中使用 this.$store.commit(&#39;xxx&#39;) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。 12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // 映射 this.increment() 为 this.$store.commit('increment') ]), ...mapMutations(&#123; add: 'increment' // 映射 this.add() 为 this.$store.commit('increment') &#125;) &#125;&#125; Actions 执行异步操作的地方 Action 之间也能够互相触发异步执行，使用 stroe 的 dispatch 属性配合 Promise Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 让我们来注册一个简单的 action： 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。 实践中，我们会经常会用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）： 12345actions: &#123; increment (&#123; commit &#125;) &#123; commit('increment') &#125;&#125; 分发 ActionAction 在组件中通过 store.dispatch 方法触发 1this.$store.dispatch('increment') 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作： 1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; Actions 支持同样的载荷方式和对象方式进行分发： 12345678910// 以载荷形式分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 来看一个更加实际的购物车示例，涉及到调用异步 API 和 分发多重 mutations： 12345678910111213141516actions: &#123; checkout (&#123; commit, state &#125;, products) &#123; // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =&gt; commit(types.CHECKOUT_SUCCESS), // 失败操作 () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) &#125;&#125; 注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。 在组件中分发 Action你在组件中使用 this.$store.dispatch(&#39;xxx&#39;) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： 12345678910111213import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment' // 映射 this.increment() 为 this.$store.dispatch('increment') ]), ...mapActions(&#123; add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment') &#125;) &#125;&#125; 组合 ActionsAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的回调函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： 12345678910actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125; 现在在子组件中你可以： 123this.$store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) 在另外一个 action 中也可以： 12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 最后，如果我们利用 async / await 这个 JavaScript 即将到来的新特性，我们可以像这样组合 action： 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 Modules使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。 为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割： 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态。 123456789101112131415const moduleA = &#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; // state 模块的局部状态 state.count++ &#125; &#125;, getters: &#123; doubleCount (state) &#123; return state.count * 2 &#125; &#125;&#125; 同样，对于模块内部的 action，context.state 是局部状态，根节点的状态是 context.rootState: 12345678910const moduleA = &#123; // ... actions: &#123; incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123; if ((state.count + rootState.count) % 2 === 1) &#123; commit(&apos;increment&apos;) &#125; &#125; &#125;&#125; 对于模块内部的 getter，根节点状态会作为第三个参数： 12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount (state, getters, rootState) &#123; return state.count + rootState.count &#125; &#125;&#125; 命名空间模块内部的 action、mutation、和 getter 现在仍然注册在全局命名空间——这样保证了多个模块能够响应同一 mutation 或 action。你可以通过添加前缀或后缀的方式隔离各模块，以避免名称冲突。你也可能希望写出一个可复用的模块，其使用环境不可控。例如，我们想创建一个 todos 模块： 123456// types.js// 定义 getter、action、和 mutation 的名称为常量，以模块名 `todos` 为前缀export const DONE_COUNT = 'todos/DONE_COUNT'export const FETCH_ALL = 'todos/FETCH_ALL'export const TOGGLE_DONE = 'todos/TOGGLE_DONE' 12345678910111213141516171819202122232425// modules/todos.jsimport * as types from '../types'// 使用添加了前缀的名称定义 getter、action 和 mutationconst todosModule = &#123; state: &#123; todos: [] &#125;, getters: &#123; [types.DONE_COUNT] (state) &#123; // ... &#125; &#125;, actions: &#123; [types.FETCH_ALL] (context, payload) &#123; // ... &#125; &#125;, mutations: &#123; [types.TOGGLE_DONE] (state, payload) &#123; // ... &#125; &#125;&#125; 模块动态注册在 store 创建之后，你可以使用 store.registerModule 方法注册模块： 123store.registerModule('myModule', &#123; // ...&#125;) 模块的状态将是 store.state.myModule。 模块动态注册功能可以让其他 Vue 插件为了应用的 store 附加新模块，以此来分割 Vuex 的状态管理。例如，vuex-router-sync 插件可以集成 vue-router 与 vuex，管理动态模块的路由状态。 你也可以使用 store.unregisterModule(moduleName) 动态地卸载模块。注意，你不能使用此方法卸载静态模块（在创建 store 时声明的模块）。","tags":[{"name":"vue,vuex","slug":"vue-vuex","permalink":"http://yoursite.com/tags/vue-vuex/"}]},{"title":"前端面试题整理","date":"2017-04-02T12:07:44.000Z","path":"2017/04/02/Others/前端面试题整理/","text":"前端面试题目搜集 一、理论知识1.1、讲讲输入完网址按下回车，到看到网页这个过程中发生了什么 a. 域名解析 b. 发起TCP的3次握手 c. 建立TCP连接后发起http请求 d. 服务器端响应http请求，浏览器得到html代码 e. 浏览器解析html代码，并请求html代码中的资源 f. 浏览器对页面进行渲染呈现给用户 参考《输入URL到展现页面的全过程》 1.2、谈谈你对前端性能优化的理解 a. 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 b. 请求带宽：开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体 c. 缓存利用：使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 d. 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 e. 代码校验：避免CSS表达式，避免重定向 参考《前端工程与性能优化》《前端网络、JavaScript优化以及开发小技巧》《实践一下前端性能分析》 1.3、前端 MV*框架的意义 早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，基本不太需要框架。 随着 AJAX 的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了。 如果是页面型产品，多数确实不太需要它，因为页面中的 JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。 长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。 从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的 MV框架，这个状况会大有改观。 之所以感受不到 MV*框架的重要性，是因为Model部分代码较少，View的相对多一些。如果主要在操作View和Controller，那当然 jQuery 这类库比较好用了。 参考《前端 MV*框架的意义》 1.4、请简述盒模型 IE6盒子模型与W3C盒子模型。 文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。 CSS3中有个box-sizing属性可以控制盒子的计算方式， content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。（W3C盒子模型） border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。（IE6盒子模型） 参考《盒模型》 1.5、请你谈谈Cookie的弊端 a. 每个特定的域名下最多生成的cookie个数有限制 b. IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie c. cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节 d. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。 1.6、浏览器本地存储 在HTML5中提供了sessionStorage和localStorage。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 1.7、web storage和cookie的区别 a. Cookie的大小是受限的 b. 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽 c. cookie还需要指定作用域，不可以跨域调用 d. Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie e. Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 f. IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage 1.8、对BFC规范的理解 BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。 BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 利用BFC可以闭合浮动，防止与浮动元素重叠。 参考《Learning BFC》 1.9、线程与进程的区别 a. 一个程序至少有一个进程，一个进程至少有一个线程 b. 线程的划分尺度小于进程，使得多线程程序的并发性高 c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 1.10、请说出三种减少页面加载时间的方法 a. 尽量减少页面中重复的HTTP请求数量 b. 服务器开启gzip压缩 c. css样式的定义放置在文件头部 d. Javascript脚本放在文件末尾 e. 压缩合并Javascript、CSS代码 f. 使用多域名负载网页内的多个文件、图片 参考《减低页面加载时间的方法》 1.11、你都使用哪些工具来测试代码的性能？ JSPerf, Dromaeo 1.12、你遇到过比较难的技术问题是？你是如何解决的？ 1.13、常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？ 1.14、列举IE与其他浏览器不一样的特性？ a. IE的排版引擎是Trident （又称为MSHTML） b. Trident内核曾经几乎与W3C标准脱节（2005年） c. Trident内核的大量 Bug等安全性问题没有得到及时解决 d. JS方面，有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等 e. CSS方面，也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式 参考《Trident（排版引擎）)》 1.15、什么叫优雅降级和渐进增强？ 渐进增强 progressive enhancement： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给 b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要 c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 参考《优雅降级和渐进增强的区别》 1.16、WEB应用从服务器主动推送Data到客户端有那些方式？ a. html5 websoket b. WebSocket 通过 Flash c. XHR长时间连接 d. XHR Multipart Streaming e. 不可见的Iframe f. \\标签的长时间连接(可跨域) 1.17、对前端界面工程师这个职位是怎么样理解的？ a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好 b. 参与项目，快速高质量完成实现效果图，精确到1px； c. 与团队成员，UI设计，产品经理的沟通； d. 做好的页面结构，页面重构和用户体验； e. 处理hack，兼容、写出优美的代码格式； f. 针对服务器的优化、拥抱最新前端技术。 1.18、你在现在的团队处于什么样的角色，起到了什么明显的作用？ 1.19、你的优点是什么？缺点是什么？ 1.20、如何管理前端团队? 1.21、最近在学什么？能谈谈你未来3，5年给自己的规划吗？ 1.22、平时如何管理你的项目？ a. 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； b. 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； c. 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； d. 页面进行标注（例如 页面 模块 开始和结束）； e. CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； f. JS 分文件夹存放 命名以该JS功能为准的英文翻译。 g. 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 1.23、说说最近最流行的一些东西吧？常去哪些网站？ CSDN、SegmentFault、php.net、MDN、css参考手册、iconfont、 underscore、github、Bootstrap、W3Shool、W3Cplus、caniuse 1.24、Flash、Ajax各自的优缺点，在使用中如何取舍？ Flash：a. Flash适合处理多媒体、矢量图形、访问机器 b. 对CSS、处理文本上不足，不容易被搜索 Ajax： a. Ajax对CSS、文本支持很好，支持搜索 b. 多媒体、矢量图形、机器访问不足 共同点： a. 与服务器的无刷新传递消息 b. 可以检测用户离线和在线状态 c. 操作DOM 1.25、请解释一下 JavaScript 的同源策略 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 1.26、AMD和CMD 规范的区别？ AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现 CMD 按需执行依赖 - 懒执行，seaJS 是它的实现 参考《SeaJS与RequireJS最大的区别》、《与 RequireJS 的异同》 1.27、网站重构的理解 重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 a. 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) b. 对于移动平台的优化，针对于SEO进行优化 c. 减少代码间的耦合，让代码保持弹性 d. 压缩或合并JS、CSS、image等前端资源 1.28、浏览器的内核分别是什么? IE浏览器的内核Trident、Mozilla的Gecko、Chrome的Blink（WebKit的分支）、Opera内核原为Presto，现为Blink； 1.29、请介绍下cache-control 每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略 Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久 Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。 1.30、前端页面有哪三层构成，分别是什么？作用是什么？ a. 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 b. 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 c. 行为层：由脚本负责。解决了页面上“内容应该如何对事件作出反应”的问题。 1.31、知道的网页制作会用到的图片格式有哪些？ png-8，png-24，jpeg，gif，svg Webp：谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。 Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。 1.32、一次js请求一般情况下有哪些地方会有缓存处理？ a. 浏览器端存储 b. 浏览器端文件缓存 c. HTTP缓存304 d. 服务器端文件类型缓存 e. 表现层&amp;DOM缓存 参考《一次HTTP请求中有哪些地方可以缓存》 1.33、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 a. 图片懒加载，滚动到相应位置才加载图片。 b. 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。 c. 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。 d. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 1.34、谈谈以前端角度出发做好SEO需要考虑什么？ a. 了解搜索引擎如何抓取网页和如何索引网页 b. meta标签优化 c. 关键词分析 d. 付费给搜索引擎 e. 链接交换和链接广泛度（Link Popularity） f. 合理的标签使用 二、HTML2.1、&lt;img&gt;标签上title属性与alt属性的区别是什么？ alt属性是为了给那些不能看到你文档中图像的浏览者提供文字说明的。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。 这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等。 title属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。参考《alt和title属性的区别及应用》 2.2、分别写出以下几个HTML标签：文字加粗、下标、居中、字体 加粗：&lt;b&gt;、&lt;strong&gt; 下标：&lt;sub&gt; 居中：&lt;center&gt; 字体：&lt;font&gt;、&lt;basefont&gt;、参考《HTML标签列表》 2.3、请写出至少5个html5新增的标签，并说明其语义和应用场景 section：定义文档中的一个章节 nav：定义只包含导航链接的章节 header：定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。 footer：定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。 aside：定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。 参考《HTML5 标签列表》 2.4、请说说你对标签语义化的理解？ a. 去掉或者丢失样式的时候能够让页面呈现出清晰的结构 b. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； c. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； d. 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 2.5、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? &lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器以何种模式来渲染文档。 严格模式的排版和 JS 运作模式是，以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 2.6、你知道多少种Doctype文档类型？ 标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页， Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 2.7、HTML与XHTML——二者有什么区别 a. XHTML 元素必须被正确地嵌套。 b. XHTML 元素必须被关闭。 c. 标签名必须用小写字母。 d. XHTML 文档必须拥有根元素。 参考《XHTML 与 HTML 之间的差异》 2.8、html5有哪些新特性、移除了那些元素？ a. HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 b. 拖拽释放(Drag and drop) API c. 语义化更好的内容标签（header,nav,footer,aside,article,section） d. 音频、视频API(audio,video) e. 画布(Canvas) API f. 地理(Geolocation) API g. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 h. sessionStorage 的数据在页面会话结束时会被清除 i. 表单控件，calendar、date、time、email、url、search j. 新的技术webworker, websocket等 移除的元素： a. 纯表现的元素：basefont，big，center, s，strike，tt，u； b. 对可用性产生负面影响的元素：frame，frameset，noframes； 2.9、iframe的优缺点？ 优点： a. 解决加载缓慢的第三方内容如图标和广告等的加载问题 b. iframe无刷新文件上传 c. iframe跨域通信 缺点： a. iframe会阻塞主页面的Onload事件 b. 无法被一些搜索引擎索引到 c. 页面会增加服务器的http请求 d. 会产生很多页面，不容易管理。 参考《iframe的一些记录》 2.10、Quirks模式是什么？它和Standards模式有什么区别？ 在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。IE6以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。 区别：总体会有布局、样式解析和脚本执行三个方面的区别。 a. 盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。 b. 设置行内元素的高宽：在Standards模式下，给&lt;span&gt;等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。 c. 设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用 d. 设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。 2.11、请阐述table的缺点 a. 太深的嵌套，比如table&gt;tr&gt;td&gt;h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了冗余代码量。 b. 灵活性差，比如要将tr设置border等属性，是不行的，得通过td c. 代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱 d. 混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱。 e. table需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。 f. 不够语义 参考《为什么说table表格布局不好？》 2.12、简述一下src与href的区别 src用于替换当前元素；href用于在当前文档和引用资源之间确立联系。 src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置 href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接 三、CSS3.1、谈谈你对CSS布局的理解 3.2、请列举几种可以清除浮动的方法（至少两种） 浮动会漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是这种特性，导致框内部由于不存在其他普通流元素了，表现出高度为0（高度塌陷）。 a. 添加额外标签，例如&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; b. 使用br标签和其自身的html属性，例如&lt;br clear=&quot;all&quot; /&gt; c. 父元素设置 overflow：hidden；在IE6中还需要触发hasLayout，例如zoom：1； d. 父元素设置 overflow：auto 属性；同样IE6需要触发hasLayout e. 父元素也设置浮动 f. 父元素设置display:table g. 使用:after 伪元素；由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 在CSS2.1里面有一个很重要的概念，那就是 Block formatting contexts （块级格式化上下文），简称 BFC。 创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，同时BFC仍然属于文档中的普通流。 IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念。 参考《那些年我们一起清除过的浮动》 3.3、请列举几种隐藏元素的方法 a. visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。 b. opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate c. position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。 d. display: none；元素会变得不可见，并且不会再占用文档的空间。 e. transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。 f. HTML5 hidden attribute；hidden属性的效果和display:none;相同，这个属性用于记录一个元素的状态 g. height: 0; overflow: hidden；将元素在垂直方向上收缩为0,使元素消失。只要元素没有可见的边框，该技术就可以正常工作。 h. filter: blur(0)；将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中。 参考《使用CSS隐藏HTML元素的4种常用方法》《通过HTML和CSS隐藏和显示元素的4种方法》 3.4、如何让一段文本中的所有英文单词的首字母大写 text-transform： none| capitalize(将每个单词的第一个字母转换成大写) | uppercase(将每个单词转换成大写 ) | lowercase(将每个单词转换成小写 ) 3.5、请简述CSS样式表继承 CSS样式表继承指的是，特定的CSS属性向下传递到子孙元素。会被继承下去的属性如下：参考《CSS样式表继承详解》 文本相关：font-family，font-size， font-style，font-variant，font-weight， font，letter-spacing，line-height，color 列表相关：list-style-image，list-style-position，list-style-type， list-style 3.6、请简述CSS的选择器 元素选择器：* 、E、 E#id、 E.class 关系选择器：E、F、E&gt;F、E+F、E~F 属性选择器：E[att]、E[att=”val”]、E[att~=”val”]、E[att^=”val”]、E[att$=”val”]、E[att*=”val”]、E[att|=”val”] 伪类选择器：E:link、E:visited、E:hover、E:active、E:focus、E:lang(fr)、E:not(s)、E:root、E:first-child、E:last-chil等 伪对象选择器：E:first-letter/E::first-letter、E:first-line/E::first-line、E:before/E::before、E:after/E::after、E::selection 参考《选择符列表》 3.7、CSS伪类与CSS伪对象的区别 CSS 引入伪类和伪元素的概念是为了描述一些现有CSS无法描述的东西 根本区别在于：它们是否创造了新的元素（抽象） 伪类：一开始用来表示一些元素的动态状态，随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类 伪对象：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中 参考《CSS伪类与CSS伪元素的区别及由来》 3.8、请简述CSS的权重规则 一个行内样式+1000，一个id+100，一个属性选择器/class类/伪类选择器+10，一个元素名/伪对象选择器+1。 关系选择器将拆分为两个选择器再计算。参考《CSS权重》 3.9、请写出多种等高布局 a. 假等高列：使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像 b. 给容器div使用单独的背景色（固定布局）（流体布局）：用&lt;div&gt;元素中的最大高度撑大其他的&lt;div&gt;容器高度 c. 创建带边框的两列等高布局：用border-left来做，只能使用两列。 d. 使用正padding和负margin对冲实现多列布局方法：在所有列中使用正的上、下padding和负的上、下margin，并在所有列外面加上一个容器，设置overflow:hiden把溢出背景切掉 e. 使用边框和定位模拟列等高：但不能使用在多列 f. 模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行 3.10、在CSS样式中常使用px、em，各有什么优劣，在表现上有什么区别？ px是相对长度单位，相对于显示器屏幕分辨率而言的。 em是相对长度单位，相对于当前对象内文本的字体尺寸。 px定义的字体，无法用浏览器字体放大功能。 em的值并不是固定的，会继承父级元素的字体大小，1 ÷ 父元素的font-size × 需要转换的像素值 = em值。 3.11、CSS中 link 和@import 的区别是什么？ a. link属于HTML标签，而@import是CSS提供的，且只能加载 CSS b. 页面被加载时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 c. import只在IE5以上才能识别，而link是HTML标签，无兼容问题 d. link方式的样式的权重 高于@import的权重 e. 当使用 Javascript 控制 DOM 去改变样式的时候，只能使用 link 方式，因为 @import 眼里只有 CSS ，不是 DOM 可以控制 3.12、position的absolute与fixed共同点与不同点 相同： a. 改变行内元素的呈现方式，display被置为block b. 让元素脱离普通流，不占据空间 c. 默认会覆盖到非定位元素上 区别： absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 3.13、position的值， relative和absolute分别是相对于谁进行定位的？ absolute：生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 （IE6不支持） relative：生成相对定位的元素，相对于其在普通流中的位置进行定位 static：默认值。没有定位，元素出现在正常的流中 3.14、CSS3有哪些新特性？ CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），变形（transform） 增加了更多的CSS选择器 多背景 rgba，在CSS3中唯一引入的伪元素是::selection，媒体查询，多栏布局 参考《CSS3中的动画效果记录》、《CSS3中border-radius、box-shadow与gradient那点事儿》 3.15、为什么要初始化CSS样式？ 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 3.16、解释下 CSS sprites原理，优缺点 CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中， 再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， background-position可以用数字精确的定位出背景图片的位置。 优点： a. 减少网页的http请求 b. 减少图片的字节 c. 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名 d. 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。 缺点： a. 在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂 b. CSS Sprites在开发的时候，要通过photoshop或其他工具测量计算每一个背景单元的精确位置 c. 在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片 3.17、解释下浮动和它的工作原理？ a. 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象） b. 浮动元素碰到包含它的边框或者浮动元素的边框停留。 3.18、浮动元素引起的问题 a. 父元素的高度无法被撑开，影响与父元素同级的元素 b. 与浮动元素同级的非浮动元素会跟随其后 c. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 3.19、什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？ 如果使用import方法对CSS进行导入，会导致某些页面在Windows下的IE出现一些奇怪的现象： 以无样式显示页面内容的瞬间闪烁，这种现象称之为文档样式短暂失效(Flash of Unstyled Content)，简称为FOUC。 原理：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。 解决方法：使用LINK标签将样式表放在文档HEAD中。 3.20、line-height三种赋值方式有何区别？（带单位、纯数字、百分比） 带单位：px不用计算，em则会使元素以其父元素font-size值为参考来计算自己的行高 纯数字：把比例传递给后代，例如父级行高为1.5，子元素字体为18px，则子元素行高为1.5*18=27px 百分比：将计算后的值传递给后代 参考《line-height的理解》、《浅析line-height和vertical》，查看在线源码。 3.21、:link、:visited、:hover、:active的执行顺序是怎么样的？ L-V-H-A，l(link)ov(visited)e h(hover)a(active)te，即用喜欢和讨厌两个词来概括 3.22、经常遇到的浏览器兼容性有哪些？如何解决？ a. 浏览器默认的margin和padding不同 b. IE6双边距bug c. 在ie6，ie7中元素高度超出自己设置高度。原因是IE8以前的浏览器中会给元素设置默认的行高的高度导致的 d. min-height在IE6下不起作用 e. 透明性IE用filter:Alpha(Opacity=60)，而其他主流浏览器用 opacity:0.6 f. input边框问题，去掉input边框一般用border:none;就可以，但由于IE6在解析input样式时的BUG(优先级问题)，在IE6下无效 3.23、有哪项方式可以对一个DOM设置它的CSS样式？ a. 外部样式表：通过&lt;link&gt;标签引入一个外部css文件 b. 内部样式表：将css代码放在 &lt;style&gt; 标签内部 c. 内联样式：将css样式直接定义在 HTML 元素内部 3.24、什么是外边距重叠？重叠的结果是什么？ 外边距重叠就是margin-collapse。 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： a. 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 b. 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 c. 两个外边距一正一负时，折叠结果是两者的相加的和。 3.25、rgba()和opacity的透明效果有什么不同？ a. opacity作用于元素，以及元素内的所有内容的透明度，rgba()只作用于元素的颜色或其背景色。 b. 设置rgba透明的元素的子元素不会继承透明效果！ 3.26、css属性content有什么作用？有什么应用？ css的content属性专门应用在 before/after 伪元素上，用于来插入生成内容。 可以配合自定义字体显示特殊符号。 四、JavaScript4.1、请解释一下什么是闭包 闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。 可以把闭包简单理解成 “定义在一个函数内部的函数”，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包有如下特性： a. JavaScript允许你使用在当前函数以外定义的变量 b. 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量 c. 闭包可以更新外部变量的值 d. 用闭包模拟私有方法 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题 参考《作用域、提升与闭包》 4.2、call 和 apply 的区别是什么？ call 和 apply 就是为了改变函数体内部 this 的指向。 区别是从第二个参数起，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 当参数明确时用call与apply都行, 当参数不明确时可用apply给合arguments 4.3、如何使用原生 Javascript 代码深度克隆一个对象（注意区分对象类型） 在网上找了个函数，用递归的方式做复制。传入的参数必须得是Array或Object。 并且用到了JSON.stringify和JSON.parse。查看在线代码。参考《JavaScript中的对象克隆》 4.4、 jQuery中 $(′.class′)和$(‘div.class’) 哪个效率更高？ jQuery内部使用Sizzle引擎，处理各种选择器。Sizzle引擎的选择顺序是从右到左，所以这条语句是先选.class， 第二个会直接过滤出div标签，而第一个就不会过滤了，将所有相关标签都列出。参考《jQuery最佳实践》 4.5、实现输出document对象中所有成员的名称和类型 用一个for in方式循环document，然后在将内容console出来， 就是看到篇文章还会判断document.hasOwnProperty，然后再做打印，我测试了下这样的话打印不出来。 查看在线代码。参考《JavaScript要点归档：DOM》 4.6、获得一个DOM元素的绝对位置 offsetTop：返回当前元素相对于其 offsetParent 元素的顶部的距离 offsetLeft：返回当前元素相对于其 offsetParent 元素的左边的距离 getBoundingClientRect()：返回值是一个DOMRect对象，它包含了一组用于描述边框的只读属性——left、top、right和bottom，属性单位为像素 参考《JavaScript中尺寸、坐标》，查看在线代码。 4.7、如何利用JS生成一个table？ 首先是用createElement创建一个table，再用setAttribute设置table的属性， 然后用for循环设置tr和td的内容，用appendChild拼接内容，设置td的时候还用到innerHTML和style.padding。 查看在线代码。参考《JavaScript要点归档：DOM表格》《JavaScript要点归档：DOM》 4.8、实现预加载一张图片，加载完成后显示在网页中并设定其高度为50px，宽度为50px 先new Image()获取一个图片对象，然后在图片对象的onload中设置宽度和高度。查看在线代码。 4.9、假设有一个4行tr的table，将table里面tr顺序颠倒 先是通过table.tBodies[0].rows获取到当前tbody中的行，接下来是两种方法处理。获取到的行没有reverse这个方法。 第一种是将这些行push到另外一个数组中 第二种是用Array.prototype.slice.call()将那些行变成数组， 接着用reverse倒叙，table再appendChild。查看在线代码。 这里我有个疑问，就是在appendChild的时候，并不是在最后把列加上，而是做了替换操作？ 4.10、模拟一个HashTable类，一个类上注册四个方法：包含有add、remove、contains、length方法 先是在构造函数中定义一个数组，然后用push模拟add，splice模拟remove。 四个方法都放在了prototype上面。查看在线代码。 4.11、Ajax读取一个XML文档并进行解析的实例 a. 初始化一个HTTP请求，IE以ActiveX对象引入。 后来标准浏览器提供了XMLHttpRequest类，它支持ActiveX对象所提供的方法和属性 b. 发送请求，可以调用HTTP请求类的open()和send()方法 c. 处理服务器的响应，通过http_request.onreadystatechange = nameOfTheFunction。来指定函数 参考《AJAX》《开始AJAX》，查看在线代码。 4.12、JS如何实现面向对象和继承机制？ 创建对象方法： a. 利用json创建对象 b. 使用JavaScript中的Object类型 c. 通过创建函数来生成对象 继承机制： a. 构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上 b. prototype模式，继承new函数的模式 c. 直接继承函数的prototype属性，对b的一种改进 d. 利用空对象作为中介 e. 在ECMAScript5中定义了一个新方法Object.create()，用于创建一个新方法 f. 拷贝继承，把父对象的所有属性和方法，拷贝进子对象，实现继承。参考《JavaScript中的对象克隆》 参考《Javascript继承机制的设计思想》《构造函数的继承》，查看在线代码。 4.13、JS模块的封装方法，比如怎样实现私有变量，不能直接赋值，只能通过公有方法 a. 通过json生成对象的原始模式，多写几个就会非常麻烦，也不能反映出它们是同一个原型对象的实例 b. 原始模式的改进，可以写一个函数，解决代码重复的问题。同样不能反映出它们是同一个原型对象的实例 c. 构造函数模式，就是一个普通函数，不过内部使用了this变量，但是存在一个浪费内存的问题。 d. Prototype模式，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承，可以把那些不变的属性和方法，直接定义在prototype对象上。Prototype模式的验证方法：isPrototypeOf()、hasOwnProperty()和in运算符。 参考《封装》，查看在线代码。 4.14、对this指针的理解，可以列举几种使用情况？ this指的是：调用函数的那个对象。 a. 纯粹的函数调用，属于全局性调用，因此this就代表全局对象Global。 b. 作为对象方法的调用，这时this就指这个上级对象。 c. 作为构造函数调用，就是通过这个函数new一个新对象（object）。这时，this就指这个新对象。 d. apply与call的调用，它们的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。 参考《Javascript的this用法》《this》，查看在线代码。 4.15、在JavaScript中，常用的绑定事件的方法有哪些？ a. 在DOM元素中直接绑定，DOM元素，可以理解为HTML标签，onXXX=”JavaScript Code”，查看事件列表。 b. 在JavaScript代码中绑定，elementObject.onXXX=function(){}，通称为DOM0事件系统。 c. 绑定事件监听函数，标准浏览器使用 addEventListener() ，IE11以下版本attachEvent().aspx) 来绑定事件监听函数，通称为DOM2事件系统。 参考《JavaScript绑定事件的方法》《JavaScript中事件处理》 4.16、解释下javascript的冒泡和捕获 12345&lt;div id=\"click1\"&gt; &lt;div id=\"click2\"&gt; &lt;div id=\"click3\"&gt;事件&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; a. Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型 b. 微软则保持元素3具有优先权，这种事件顺序被称为冒泡型 c. W3C选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 事件监听函数addEventListener()的第三个参数就是控制方法是捕获还是冒泡 参考《事件》、《javascript的冒泡和捕获》，查看在线代码。 4.17、jQuery的特点 a. 一款轻量级的js库 b. 丰富快速的DOM选择器 c. 链式表达式 d. 事件、样式、动画等特效支持 e. Ajax操作封装，支持跨域 f. 跨浏览器兼容 g. 插件扩展开发 参考《JQuery特点、优缺点及其常用操作》 4.18、Ajax有哪些好处和弊端？ 优点： a. 无刷新更新数据 b. 异步与服务器通信 c. 前端和后端负载平衡 d. 基于标准被广泛支持 e. 界面与应用分离 缺点： a. AJAX干掉了Back和History功能，即对浏览器机制的破坏 b. AJAX的安全问题 c. 对搜索引擎支持较弱 d. 违背URL和资源定位的初衷 参考《AJAX工作原理及其优缺点》 4.19、null和undefined的区别？ null： a. null是一个表示”无”的对象，转为数值时为0 b. null表示”没有对象”，即该处不应该有值。 undefined： a. undefined是一个表示”无”的原始值，转为数值时为NaN。 b. undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。 参考《undefined与null的区别》 4.20、new操作符具体干了什么呢? a. 一个新对象被创建。它继承自函数原型 b. 构造函数被执行。执行的时候，相应的传参会被传入 c. 上下文(this)会被指定为这个新实例 d. 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果 参考《new运算符》 4.21、js延迟加载的方式有哪些？ a. 将script节点放置在最后&lt;/body&gt;之前 b. 使用script标签的defer和async属性，defer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载 c. 通过监听onload事件，动态添加script节点 d. 通过ajax下载js脚本，动态添加script节点 参考《javascript延迟加载方式》 4.22、如何解决跨域问题? a. JSONP（JSON with Padding），填充式JSON b. iframe跨域 c. HTML5的window.postMessage方法跨域 d. 通过设置img的src属性，进行跨域请求 e. 跨域资源共享（CORS），服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 4.23、documen.write和 innerHTML的区别 write： a. 改变 HTML 输出流 b. 当在文档加载之后使用 document.write()，这会覆盖该文档。例如onload事件中 c. 输入css的style标签能改变样式，例如document.write(“&lt;style&gt;b{color:red;font-weight:bold;}&lt;/style&gt;“); innerHTML： a. 改变 HTML 内容 b. 输入css的style标签不能改变样式。也是能改变样式的 参考《JavaScript HTML DOM - 改变 HTML》 4.24、哪些操作会造成内存泄漏？ a. 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 b. 在IE中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会处理。 c. 闭包可以维持函数内局部变量，使其得不到释放。 d. 在销毁对象的时候，要遍历属性中属性，依次删除，否则会泄漏。 参考《js内存泄漏的几种情况》、《JavaScript内存分析》 4.25、JavaScript中的变量声明提升？ 函数声明和变量声明总是被JavaScript解释器隐式地提升到包含他们的作用域的最顶端。 function优先声明于var。 函数表达式中只会提升名称，函数体只有在执行到赋值语句时才会被赋值。 ; “复制代码”) 123456789101112131415function foo() &#123; bar(); var x = 1;&#125;function foo() &#123;//等同于 var x; bar(); x = 1;&#125;function test() &#123; foo(); // TypeError \"foo is not a function\" bar(); // \"this will run!\" var foo = function () &#123; &#125;// 函数表达式被赋值给变量'foo' function bar() &#123; &#125;// 名为'bar'的函数声明&#125; ; “复制代码”) 4.26、如何判断当前脚本运行在浏览器还是node环境中？ 通过判断Global对象是否为window，如果是window，当前脚本运行在浏览器中 4.27、什么是 “use strict” ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode） 设立”严格模式”的目的，主要有以下几个： a. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; b. 消除代码运行的一些不安全之处，保证代码运行的安全； c. 提高编译器效率，增加运行速度； d. 为未来新版本的Javascript做好铺垫。 注：经过测试IE6,7,8,9均不支持严格模式 参考《Javascript 严格模式详解》 4.28、eval是做什么的？ eval()函数可计算某个字符串，并执行其中的的 JavaScript 代码。 eval()是一个顶级函数并且跟任何对象无关。 如果字符串表示了一个表达式，eval()会对表达式求值。如果参数表示了一个或多个JavaScript声明， 那么eval()会执行声明。 4.29、JavaScript原型，原型链 ? 原型： a. 原型是一个对象，其他对象可以通过它实现属性继承。 b. 一个对象的真正原型是被对象内部的[[Prototype]]属性(property)所持有。浏览器支持非标准的访问器proto。 c. 在javascript中，一个对象就是任何无序键值对的集合，如果它不是一个主数据类型(undefined，null，boolean，number，string)，那它就是一个对象。 原型链： a. 因为每个对象和原型都有一个原型(注:原型也是一个对象)，对象的原型指向对象的父，而父的原型又指向父的父，我们把这种通过原型层层连接起来的关系撑为原型链。 b. 这条链的末端一般总是默认的对象原型。 1234a.__proto__ = b; b.__proto__ = c; c.__proto__ = &#123;&#125;; //default object &#123;&#125;.__proto__.__proto__; //null 参考《理解JavaScript原型》《原型》 4.30、画出此对象的内存图 查看在线代码。 4.31、JQuery与jQuery UI 有啥区别？ jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。 jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等 4.32、jQuery的源码看过吗？能不能简单说一下它的实现原理？ jQuery给我们带来了一个简洁方便的编码模型(1&gt;创建jQuery对象;2&gt;直接使用jQuery对象的属性/方法/事件), 一个强悍的dom元素查找器($)，插件式编程接口(jQuery.fn)，以及插件初始化的”配置”对象思想 参考《jQuery工作原理解析以及源代码示例》《jQuery系列分析》 4.33、jQuery 中如何将数组转化为json字符串 在jQuery1.8.3中有个方法“parseJSON”，在这个方法中会做从string转换为json。 如果当前浏览器支持window.JSON，那就直接调用这个对象中的方法。 如果没有就使用( new Function( “return “ + data ) )();执行代码返回。 eval和new Function是有区别的。 4.34、请写出console.log中的内容 ; “复制代码”)1234567891011121314var msg = 'hello';//顶级作用域window下有个变量msgfunction great(name, attr) &#123; var name = 'david'; var greating = msg + name + '!'; var msg = '你好'; for (var i = 0; i &lt; 10; i++) &#123; var next = msg + '你的id是' + i * 2 + i; &#125; console.log(arguments[0]); console.log(arguments[1]); console.log(greating); console.log(next);&#125;great('Tom') ; “复制代码”) 查看在线代码。 a. arguments[0]被覆盖了 b. msg出现了声明提升，可以查看4.25的例子 c. next中出现了隐式的类型转换 4.35、请说明下下面代码的执行过程 ; “复制代码”) 12345678var t=true;window.setTimeout(function()&#123; t=false;&#125;,1000);while(t)&#123; console.log(1);&#125;alert('end'); ; “复制代码”) 查看在线代码。 a. JavaScript引擎是单线程运行的，浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序 b. setTimeout是异步线程，需要等待js引擎处理完同步代码（while语句）之后才会执行，while语句直接是个死循环，js引擎没有空闲，不会执行下面的alert，也不会插入setTimeout。我在chrome中执行在线代码，最后浏览器是终止死循环执行alert。 c. JavaScript的工作机制是：当线程中没有执行任何同步代码的前提下才会执行异步代码，setTimeout是异步代码，所以setTimeout只能等js空闲才会执行，但死循环是永远不会空闲的，所以setTimeout也永远不会执行。 4.36、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26 参考《JavaScript Date 对象》《日月如梭，玩转JavaScript日期》 4.37、Javascript中callee和caller的作用？ arguments.callee属性包含当前正在执行的函数。 Function.caller返回一个对函数的引用，该函数调用了当前函数。 4.38、函数柯里化（Currying）如何理解？ 柯里化：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。 参考《前端开发者进阶之函数柯里化Currying》 4.39、JS异步编程方式有几种？ a. 回调函数 b. 事件监听 c. 发布订阅 d. promise 参考《异步编程的4种方法》 4.40、请说说在JavaScript引用类型和值类型的理解 值类型：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。即Undefined、Null、Boolean、Number 和 String。 引用类型：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。即对象、数组 参考《ECMAScript 原始值和引用值》，查看在线代码。下面有道题目可以研究下，具体流程参考《理解js引用类型指针的工作方式》 12345var a = &#123;n:1&#125;; var b = a; a.x = a = &#123;n:2&#125;; console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; [object Object] 参考资料： 【答阿里寒冬面试题】呵呵，大神的面试题就是好！ 做几道前端面试题休息休息吧 来看一点CSS相关的吧 前端面试题第二弹袭来，接招！ 阿里巴巴校招笔试题整理（HTML+CSS篇） 最全前端面试问题及答案总结 2014年最新前端开发面试题 2014PPTV-题解 一些前端开发的笔试题及答案【编程题】 常见前端面试题之HTML/CSS部分 BAT及各大互联网公司2014前端笔试面试题–Html,Css篇 BAT及各大互联网公司2014前端笔试面试题–JavaScript篇【编程题】 10道javascript笔试题【编程题】 分类: CSS,JavaScript,面试题目","tags":[{"name":"CSS,JavaScript,面试题目","slug":"CSS-JavaScript-面试题目","permalink":"http://yoursite.com/tags/CSS-JavaScript-面试题目/"}]},{"title":"前端模块化","date":"2017-04-02T12:03:39.000Z","path":"2017/04/02/Others/前端模块化/","text":"前端模块化在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀 这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码 模块既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可 1import java.util.ArrayList; 遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了 规范形成的过程是痛苦的，前端的先驱在刀耕火种、茹毛饮血的阶段开始，发展到现在初具规模，简单了解一下这段不凡的历程 函数封装我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了 1234567function fn1()&#123; statement&#125;function fn2()&#123; statement&#125; 这样在需要的以后夹在函数所在文件，调用函数就可以了 这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。 对象为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中 12345678910111213var myModule = &#123; var1: 1, var2: 2, fn1: function()&#123; &#125;, fn2: function()&#123; &#125;&#125; 这样我们在希望调用模块的时候引用对应文件，然后 1myModule.fn2(); 这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系 看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员 1myModel.var1 = 100; 这样就会产生意外的安全问题 立即执行函数可以通过立即执行函数，来达到隐藏细节的目的 1234567891011121314151617var myModule = (function()&#123; var var1 = 1; var var2 = 2; function fn1()&#123; &#125; function fn2()&#123; &#125; return &#123; fn1: fn1, fn2: fn2 &#125;;&#125;)(); 这样在模块外部无法修改我们没有暴露出来的变量、函数 上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD CommonJS我们先从CommonJS谈起，因为在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。 定义模块根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 模块输出：模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象 加载模块：加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象 看个例子 12345678910111213141516171819202122//模块定义 myModel.jsvar name = 'Byron';function printName()&#123; console.log(name);&#125;function printFullName(firstName)&#123; console.log(firstName + name);&#125;module.exports = &#123; printName: printName, printFullName: printFullName&#125;//加载模块var nameModule = require('./myModel.js');nameModule.printName(); 不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块） 尴尬的浏览器仔细看上面的代码，会发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。 这在服务器端实现很简单，也很自然，然而， 想在浏览器端实现问题却很多。 浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。 解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。 另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧： AMDAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范 由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出 requireJS主要解决两个问题 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 看一个使用requireJS的例子 1234567891011121314// 定义模块 myModule.jsdefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName();}); 语法requireJS定义了一个函数 define，它是全局变量，用来定义模块 1define(id?, dependencies?, factory); id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） dependencies：是一个当前模块依赖的模块名称数组 factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 在页面上使用require函数加载模块 1require([dependencies], function()&#123;&#125;); require()函数接受两个参数 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 CMDCMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同 语法Sea.js 推崇一个模块一个文件，遵循统一的写法 define1define(id?, deps?, factory) 因为CMD推崇 一个文件一个模块，所以经常就用文件名作为模块id CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写 factory有三个参数 1function(require, exports, module) requirerequire 是 factory 函数的第一个参数 1require(id) require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口 exportsexports 是一个对象，用来向外提供模块接口 modulemodule 是一个对象，上面存储了与当前模块相关联的一些属性和方法 demo12345678910// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;); AMD与CMD区别关于这两个的区别网上可以搜出一堆文章，简单总结一下 最明显的区别就是在模块定义时对依赖的处理不同 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require 这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法 AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同 很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略 为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。） 同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行 CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的 这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因 参考从 CommonJS 到 Sea.js Javascript模块化编程（一）：模块的写法 Javascript模块化编程（二）：AMD规范 详解JavaScript模块化开发 require SeaJS API 快速参考 SeaJS 与 RequireJS 的异同 分类: Web综合标签: 模块化, CMD, AMD, CommonJS, seajs, requireJS","tags":[{"name":"模块化,CMD,AMD,CommonJS,seajs,requireJS","slug":"模块化-CMD-AMD-CommonJS-seajs-requireJS","permalink":"http://yoursite.com/tags/模块化-CMD-AMD-CommonJS-seajs-requireJS/"}]},{"title":"ECMAScript-2015","date":"2017-03-31T14:59:11.000Z","path":"2017/03/31/JavaScript/ECMAScript-2015/","text":"[toc] 1. ECMAScript 6简介详细内容 2. let 和 const 命令详细内容 3. 变量的解构赋值详细内容 4. 字符串的扩展详细内容 5. 正则的扩展详细内容 6. 数值的扩展详细内容 7. 数组的扩展详细内容 1. Array.from() Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 参数一：要转换的对象或者字符串 参数二：（可选）一个函数，类似数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 参数三：（可选）如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 123456789Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b']Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x); 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); 2. Array.of() Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 3. 数组实例的copyWithin() 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 参数一：target（必需）：从该位置开始替换数据。 参数二：start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 参数三：end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。 下面是更多例子。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 4. 数组实例的find()和findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 两个方法参数 参数一：回调函数 回调函数可以接收三个参数 参数一：当前值value 参数二：当前的位置index 参数三：原数组array 参数二：（可选）thisArg用来绑定回调函数内部的this 另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。下面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 5. 数组实例的fill() fill方法使用给定值，填充一个数组。 参数一：填充的值 参数二：（可选）填充的起始位置 参数三：（可选）填充的结束位置，不包括该位置 12['a', 'b', 'c'].fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。 6. 数组实例的entries()，keys()和values() ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 7. 数组实例的includes() Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。 参数一：要查找的值 参数二：（可选）搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度，则会重置为从0开始 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains([\"foo\", \"bar\"], \"baz\"); // =&gt; false 另外，Map和Set数据结构有一个has方法，需要注意与includes区分。 Map结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 8. 数组的空位 数组的空位指，数组的某一个位置没有任何值。注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314151617181920// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // \"#a##\"// toString方法[,'a',undefined,null].toString() // \",a,,\" ES6则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 12Array.from(['a',,'b'])// [ \"a\", undefined, \"b\" ] 扩展运算符（...）也会将空位转为undefined。 12[...['a',,'b']]// [ \"a\", undefined, \"b\" ] copyWithin()会连空位一起拷贝。 1[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"] fill()会将空位视为正常的数组位置。 1new Array(3).fill('a') // [\"a\",\"a\",\"a\"] for...of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,\"a\"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。 8. 函数的扩展详细内容 1. 函数参数的默认值2. rest参数3. 扩展运算符4. 严格模式5. name 属性6. 箭头函数7. 绑定 this8. 尾调用优化9. 函数参数的尾逗号9. 对象的扩展详细内容 10. Symbol详细内容 11. Set 和 Map 数据结构详细内容 1. Set1. 基本用法 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 1234567891011121314151617181920// 例一var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;var set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 在Set内部，两个NaN是相等。 123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 2. Set实例的属性和方法Set结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 Array.from方法可以将Set结构转为数组。 这就提供了去除数组重复成员的另一种方法。 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 3. 遍历操作Set结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。 （1）keys()，values()，entries() keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。 12Set.prototype[Symbol.iterator] === Set.prototype.values// true 这意味着，可以省略values方法，直接用for...of循环遍历Set。 12345678let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// blue （2）forEach() Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。 参数一：处理函数 函数有三个参数 参数一：value 参数二：key 参数三：set 参数二：thisArg，绑定函数内的this对象 12345let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 （3）遍历的应用 扩展运算符（...）内部使用for...of循环，所以也可以用于Set结构。 123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 数组的map和filter方法也可以用于Set了。 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。 123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 2. WeakSet WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。 首先，WeakSet的成员只能是对象，而不能是其他类型的值。其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 12345var ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set 上面代码试图向WeakSet添加一个数值和Symbol值，结果报错，因为WeakSet只能放置对象。 WeakSet结构有以下三个方法。 WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。 WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。 WeakSet没有size属性，没有办法遍历它的成员。 WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 3. Map1. Map结构的目的和基本用法JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。 作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910var map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\" 上面代码在新建Map实例时，就指定了两个键name和title。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。 123456var items = [ ['name', '张三'], ['title', 'Author']];var map = new Map();items.forEach(([key, value]) =&gt; map.set(key, value)); 如果对同一个键多次赋值，后面的值将覆盖前面的值。 如果读取一个未知的键，则返回undefined。 注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。 1234var map = new Map();map.set(['a'], 555);map.get(['a']) // undefined Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。 2. 实例的属性和操作方法Map结构的实例有以下属性和操作方法。 （1）size属性 size属性返回Map结构的成员总数。 12345let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 （2）set(key, value) set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。 12345var m = new Map();m.set(\"edition\", 6) // 键是字符串m.set(262, \"standard\") // 键是数值m.set(undefined, \"nah\") // 键是undefined set方法返回的是Map本身，因此可以采用链式写法。 1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); （3）get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 123456var m = new Map();var hello = function() &#123;console.log(\"hello\");&#125;m.set(hello, \"Hello ES6!\") // 键是函数m.get(hello) // Hello ES6! （4）has(key) has方法返回一个布尔值，表示某个键是否在Map数据结构中。 12345678910var m = new Map();m.set(\"edition\", 6);m.set(262, \"standard\");m.set(undefined, \"nah\");m.has(\"edition\") // truem.has(\"years\") // falsem.has(262) // truem.has(undefined) // true （5）delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 123456var m = new Map();m.set(undefined, \"nah\");m.has(undefined) // truem.delete(undefined)m.has(undefined) // false （6）clear() clear方法清除所有成员，没有返回值。 1234567let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0 3. 遍历方法Map原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员。 需要特别注意的是，Map的遍历顺序就是插入顺序。 下面是使用实例。 1234567891011121314151617181920212223242526272829303132let map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125; 上面代码最后的那个例子，表示Map结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。 12map[Symbol.iterator] === map.entries// true Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（...）。 1234567891011121314151617let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。 1234567891011121314let map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');let map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;let map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。 123map.forEach(function(value, key, map) &#123; console.log(\"Key: %s, Value: %s\", key, value);&#125;); forEach方法还可以接受第二个参数，用来绑定this。 123456789var reporter = &#123; report: function(key, value) &#123; console.log(\"Key: %s, Value: %s\", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 上面代码中，forEach方法的回调函数的this，就指向reporter。 4. 与其他数据结构的互相转换（1）Map转为数组 前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。 123let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] （2）数组转为Map 将数组转入Map构造函数，就可以转为Map。 12new Map([[true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; （3）Map转为对象 如果所有Map的键都是字符串，它可以转为对象。 1234567891011function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; （4）对象转为Map 12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// [ [ 'yes', true ], [ 'no', false ] ] （5）Map转为JSON Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。 1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;\"yes\":true,\"no\":false&#125;' 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]' （6）JSON转为Map JSON转为Map，正常情况下，所有键名都是字符串。 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;\"yes\":true,\"no\":false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; 但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。 123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap('[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]')// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; 4.WeakMap WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。 WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 12. Proxy详细内容 13. Reflect详细内容 14. Promise 对象详细内容 15. Iterator 和 for…of 循环详细内容 16. Generator 函数的语法详细内容 17. Generator 函数的异步应用详细内容 18. async 函数详细内容 19. Class详细内容 20. Decorator详细内容 21. Module 的语法详细内容 22. Module 的加载实现详细内容 23. 编程风格详细内容 24. 读懂规格详细内容 25. 二进制数组详细内容 26. SIMD详细内容 27. 参考链接详细内容","tags":[{"name":"javascript,es6","slug":"javascript-es6","permalink":"http://yoursite.com/tags/javascript-es6/"}]},{"title":"Gulp和Webpack对比","date":"2017-03-18T13:50:52.000Z","path":"2017/03/18/Framework/Webpack/Gulp和Webpack对比/","text":"原文 http://chping.website/2016/10/18/gulp和webpack对比/ 在现在的前端开发中，前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等等一些原本后端的思想开始逐渐渗透到“大前端”的开发中。前端开发过程越来越繁琐，当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且Webapp通常是一个单页面应用(SPA)，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。 前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 本文需要有一定的 Gulp 和 Webpack 的基本概念，对Gulp和Webpack的使用有一定的了解。 同时还需要对npm或者cnpm有一定的的了解，对ComonJS、AMD规范有一定的的了解。 GulpGulp 就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。说的形象点，“Gulp就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。” 另外，Gulp是通过task对整个开发过程进行构建。 WebpackWebpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS 等。 Gulp和Webpack功能实现对比简单介绍了一下Gulp和Webpack的概念性的问题和大环境，接下来进入本文的主题，对比一下Gulp和Webpack的优缺点。将从基本概念、启动本地Server、sass/less预编译、模块化开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。 基本概念首先从概念上，我们可以清楚的看出，Gulp和Webpack的侧重点是不同的。 Gulp侧重于前端开发的 整个过程 的控制管理（像是流水线），我们可以通过给gulp配置不通的task（通过Gulp中的gulp.task()方法配置，比如启动server、sass/less预编译、文件的合并压缩等等）来让gulp实现不同的功能，从而构建整个前端开发流程。 Webpack有人也称之为 模块打包机 ，由此也可以看出Webpack更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js文件、css文件等）都可以看成模块，最初Webpack本身就是为前端JS代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack是通过loader（加载器）和plugins（插件）对资源进行处理的。 另外我们知道Gulp是对整个过程进行控制，所以在其配置文件（gulpfile.js）中配置的每一个task对项目中 该task配置路径下所有的资源 都可以管理。 比如，对sass文件进行预编译的task可以对其配置路径下的所有sass文件进行预编译处理：12345gulp.task('sass',function()&#123; gulp.src('src/styles/*.scss') .pipe(sass().on('error',sass.logError)) .pipe(gulp.dest('./build/prd/styles/'));//编译后的输出路径&#125;); 上面这个task可以对 &#39;src/styles/*.scss&#39; 目录下的所有以 .scss 结尾的文件进行预处理。 Webpack则不是这样管理资源的，它是根据模块的 依赖关系 进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源(如下图)。 通俗的说，Webpack就是需要通过其配置文件（webpack.config.js）中 entry 配置的一个入口文件（JS文件）,如下图123entry: &#123; app:__dirname + \"/src/scripts/app.js\",&#125; 然后Webpack进入该 app.js 文件进行解析， app.js 文件如下图：123456//引入scss文件import'../style/app.scss';//引入依赖模块vargreeter =require('./Greeter.js');document.getElementById('root').appendChild(greeter()); 解析过程中，发现一个 app.scss 文件，然后根据 webpack.config.js 配置文件中的 module.loaders 属性去查找处理 .scss 文件的loader进行处理，处理 app.scss 文件过程中，如果发现该文件还有其他依赖文件，则继续处理 app.scss 文件的依赖文件，直至处理完成该“链路”上的依赖文件，然后又遇到一个 Greeter.js 模块，于是像之前一样继续去查找对应的loader去处理… 所以，Webpack中对资源文件的处理是通过入口文件产生的依赖形成的，不会像Gulp那样，配置好路径后，该路径下所有规定的文件都会受影响。 模块化开发所谓的前端模块化开发，我的理解就是，在开发的时候，把不通的资源文件按照他的具体用途进行分类管理，在使用的时候利用CommonJS、AMD、CMD等规范将这些资源文件引入到当前文件中。然后在测试或者最后上线的时候，将这些资源文件按照一定的要求进行压缩合并再加上版本控制处理。 可能这样的理解或者说法值得商榷，但是个人还是觉得模块化就是对内容的管理，是为了解耦合。 首先从Gulp入手，看看在项目中，怎样利用模块化的思想进行开发。下面是一个gulp项目的目录结构： 123456789101112131415161718192021Gulp |——build: 项目输出路径 | |——prd: css、js文件输出路径 | |——scripts: js文件的输出路径 | |——styles: css文件的输出路径 | |——ver: 版本号相关文件 | |——index.html: 编译后的index.html |——images: 图片文件夹 |——mock: mock数据文件夹 |——node_modules: npm包管理文件夹 |——src: 工作目录 | |——scripts | |——libs: 第三方依赖库（jQuery等） | |——tpls: 模板文件 | |——utils: 工具类文件夹 | |——views: 页面自定义js文件 | |——app.js: index.html文件的入口js | |——styles：文件和scripts文件夹下基本一致（本例中我引用了第三方框架，目录更深，不在展示） |——gulpfile.js: gulp的配置文件 |——index.html: 主页html文件 |——package.json: npm包管理配置文件 在实际开发过程中，在src目录下工作，html、js和css等文件通过gulp的task配置，执行合并和压缩后输出到build目录下（下面会详细介绍合并压缩的实现）。在详细一点就是： 创建主页html文件 创建与之对应的app.js入口文件和app.scss入口文件。这两个文件只通过CommonJS规范 引入各自views文件中自定义的js(或scss)文件 ，具体逻辑不写此文件中。 在views目录下编写js（或css）文件的逻辑代码，其中如果多个文件需要公共逻辑或者工具方法，就可以抽离出来在util文件夹下创建对应的公共方法，然后在views中需要的js（或css）文件中通过CommonJS规范引入使用。libs目录下的第三方库或框架也是这个思想去引用。 scripts目录下的tpls文件是用来放置html模板的，引用方式和引用libs相同。 大体介绍了一下我理解的模块化的思想，但是需要指出的是Gulp对js文件的模块化工作是通过Webpack实现的，具体来说是通过安装 gulp-webpack 模块和相关的 loader 模块进行js模块化管理的。具体步骤如下： 在项目中通过npm安装一个 gulp-webpack 、 vinyl-named 、 imports-loader 和 string-loader 模块(压缩合并模块后面再介绍) 1$ npm install gulp-webpack vinyl-named -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-webpack 模块，并进行简单配置 123456789101112131415161718192021222324252627282930313233343536//1.引入 gulp-webpack和vinyl-named模块varwebpack=require('gulp-webpack');varwebpack=require('vinyl-named');//2.js 模块化配置varjsFiles = ['./src/scripts/*.js', ]; gulp.task('packjs',function()&#123; gulp.src(jsFiles) .pipe(uglify().on('error',function(err)&#123;console.log('\\x07',err.lineNumber,err.message);returnthis.end(); &#125;))//Webpack 对js模块化部分 start .pipe(webpack(&#123; output:&#123; filename:'[name].js' &#125;,module:&#123; loaders:[&#123; test: /\\.js$/, loader:'imports?define=&gt;false' &#125;, &#123; test:/\\.string$/, loader:'string' &#125; ] &#125; &#125;));//Webpack 对js模块化部分 end .pipe(concat('all.js')) .pipe(gulp.dest('./build/prd/scripts/'));&#125;); 对css文件我们也采用同js文件一样的模块化思想，利用sass进行模块化开发，至于对scss文件的合并压缩配置，下面还会详细介绍。 接下来应该介绍一下Webpack的模块化实现了，其实也就没什么可以说的了，文件目录和Gulp的基本相同，只不过实现过程中使用到的插件或者说模块不同，配置不同而已。另外需要注意的是，Webpack对于资源文件的模块化打包处理都是按js文件的处理方式处理的，例如还是上一小节中，你可能发现了，我在 app.js 入口文件中有这样一行代码1import'../style/app.scss'; 你当时可能产生疑问，为什么在js文件中引入scss文件呢？ 这是因为Webpack是通过依赖关系进行文件管理的，所以，想要对样式文件进行模块化管理则必须与 app.js 入口文件建立依赖关系，因此我们将样式文件的入口 app.scss 文件引入到了 app.js 中（其他资源想要被管理，也需要这样与 app.js 入口文件建立依赖关系）。 但是这样做很明显的就是样式文件通过 app.js 入口文件全部都合并压缩到js文件中了，这很显然不是我们想要的结果，所以我们需要将样式文件从js文件中剥离出来。 在项目中通过npm安装一个 extract-text-webpack-plugin 的模块 1$ npm install extract-text-webpack-plugin -D 然后在Webpack的配置文件webpack.config.js中进行简单配置 1234567891011121314151617181920212223242526272829303132333435//1.引入extract-text-webpack-plugin模块varEt =require('extract-text-webpack-plugin');module.exports = &#123;//source-map调试 devtool: 'eval-source-map',//webpack入口文件配置 entry: &#123; app:__dirname + \"/src/scripts/app.js\", &#125;,//webpack出口文件配置 output: &#123; path: __dirname + \"/prd/scripts/\",//输出文件路径配置 filename: \"bundle.js\"//输出文件名配置 &#125;,module:&#123; loaders:[ &#123; test: /\\.scss$/, loader: Et.extract('style','css!sass')//从js中抽离scss文件 &#125; ] &#125;, plugins: [newEt('./styles/bundle.css'),//从js中抽离scss文件输出目录设置 ],//本地server配置 devServer: &#123; contentBase: __dirname + '/prd/',//本地服务器所加载的页面所在的目录 port:8089,//本地服务端口配置 colors: true,//终端中输出结果为彩色 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;&#125; 上面有些配置信息并不完全，下面的小节中会逐渐介绍到。这样我们就实现了将css文件从js文件中剥离出来的目的。Webpack不但可以对css文件可以进行模块化管理，还可以对图片进行模块管理，有兴趣的可以自己去尝试一下。 文件合并与压缩上面的模块化中，我们提到了模块化其实很大一部分是在做文件的合并与压缩操作，所以我们马上来看看Gulp和Webpack是怎样是想文件的合并和压缩的。 先来看看大背景，由于现在前端越来越庞大，页面文件依赖也越来越多，所以对这些文件进行合理的合并和压缩就志在必得。根据前面的了解，Webpack应该比Gulp更擅长文件合并和压缩，毕竟人家被称为 模块打包机 吗。 结论是正确的，Gulp可以对css文件以及js文件进行合并压缩处理，而Webpack可以实现对css文件，js文件，html文件等进行合并压缩和图片的压缩，还可以对js文件进行编译（如es6–&gt;es5，react jsx）等等，这些都是通过Webpack的 loader 实现的，当然这些也可以加入到Gulp中，毕竟Gulp把Webpack当做一个模块，通过 gulp-webpack 都引入了。 Gulp合并压缩文件css的压缩要想实现Gulp对css文件的压缩只需要安装一个 gulp-minify-css 模块即可。 在项目中通过npm安装一个 gulp-minify-css 的模块 1$ npm install gulp-minify-css -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-minify-css模块，并进行简单配置 12345678910111213//1.引入 gulp-minify-css模块varminifyCSS =require('gulp-minify-css');//2.css 预处理varcssFiles = ['./src/styles/usage/page/index.scss']gulp.task('sass',function()&#123; gulp.src(cssFiles) .pipe(sass().on('error',sass.logError)) .pipe(minifyCSS())//执行压缩处理在一行 .pipe(gulp.dest('./build/prd/styles/'));&#125;); 这样一个简单的css压缩就实现了。 js合并压缩要想实现Gulp对js文件的合并压缩需要安装一个 gulp-uglify 和 gulp-concat 两个模块，前者是用于压缩的模块，后者是一个合并的模块。 在项目中通过npm安装 gulp-uglify 和 gulp-concat 模块 1$ npm install gulp-uglify gulp-concat -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入 gulp-uglify 和 gulp-concat 模块，并进行简单配置 1234567891011121314151617181920212223242526272829303132333435//1.引入**gulp-uglify**和**gulp-concat**模块varuglify =require('gulp-uglify');varconcat =require('gulp-concat');//js 合并压缩varjsFiles = ['./src/scripts/*.js', ]; gulp.task('packjs',function()&#123; gulp.src(jsFiles)//js文件的压缩 .pipe(uglify().on('error',function(err)&#123;console.log('\\x07',err.lineNumber,err.message);returnthis.end(); &#125;)) .pipe(webpack(&#123; output:&#123; filename:'[name].js' &#125;,module:&#123; loaders:[&#123; test: /\\.js$/, loader:'imports?define=&gt;false' &#125;, &#123; test:/\\.string$/, loader:'string' &#125; ] &#125; &#125;));//js文件的合并 .pipe(concat('all.js')) .pipe(gulp.dest('./build/prd/scripts/'));&#125;); js的文件合并压缩也完成了。我们再来看一下Webpack的合并压缩。 Webpack的合并压缩压缩js和css针对js和css文件的压缩，Webpack已经内嵌了uglifyJS来完成对js与css的压缩混淆，无需引用额外的插件。我们只需要在Webpack配置文件中的plugins属性中做如下配置：12345678plugins: [ newwebpack.optimize.UglifyJsPlugin(&#123;//压缩代码 compress: &#123; warnings: false &#125;, except: ['$super','/pre&gt;,'exports','require']//排除关键字 &#125;)] 需要注意的是：压缩的时候需要排除一些关键字，不能混淆，比如$或者require，如果混淆的话就会影响到代码的正常运行。 html的压缩想要对html进行压缩，同样也是需要配置Webpack的配置文件，并且需要下载两个插件 HtmlWebpackPlugin 和 html-minifier 插件： 1.在项目中通过npm安装 HtmlWebpackPlugin 和 html-minifier 模块12$ npm install HtmlWebpackPlugin -D$ npm install html-minifier -D 2.然后在Webpack的配置文件webpack.config.js进行如下配置：12345678910111213plugins: [ newHtmlWebpackPlugin(&#123;//根据模板插入css/js等生成最终HTML favicon:'./src/img/favicon.ico',//favicon路径 filename:'/view/index.html',//生成的html存放路径 template:'./src/view/index.html',//html模板路径 inject:true,//允许插件修改哪些内容，包括head与body hash:true,//为静态资源生成hash值 minify:&#123; //压缩HTML文件 removeComments:true,//移除HTML中的注释 collapseWhitespace:true//删除空白符与换行符 &#125; &#125;)] HtmlWebpackPlugin插件在生成HTML时调用了 html-minifier 插件来完成对HTML的压缩，这里我们使用两个配置完成来移除HTML中的注释以及空白符达到压缩的效果。 sass/less预编译我们再来看看sass/less预编译，其实就sass/less的预编译来说，两者区别不是很大。Gulp是通过 gulp-sass 、 gulp-less 模块进行预处理；而Webpack是通过 scss-loader 、 less-loader 加载器（loader）进行预处理。我们还是分别来看一下两者对此的实现。 Gulp预编译sass/less以sass为例子： 在项目中通过npm安装一个 gulp-sass 的模块 1$ npm install gulp-sass -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-sass模块，并进行简单配置 1234567891011121314151617181920212223//1.引入 gulp-sass模块var sass=require('gulp-sass');//2.css 预处理var cssFiles = [ './src/styles/usage/page/**/*' //./src/styles/usage/page目录下的所有文件];gulp.task('sass',function()&#123; gulp.src(cssFiles) .pipe(sass().on('error',sass.logError)) .pipe(minifyCSS()) .pipe(gulp.dest('./build/prd/styles/'));//编译后的输出路径 &#125;);//3.对sass文件的修改添加监听事件gulp.task('watch',function()&#123; gulp.watch('./src/styles/**/*',['sass']);&#125;);gulp.task('default',['watch','webserver'],function()&#123; console.log('所有任务队列执行完毕');&#125;); 这样，一个简单的sass预处理的task就配置完成了，然后我们还将该task加到gulp.watch()上实现了自动编译（即修改sass文件后保存，则立即执行sass预处理），配合Gulp启动的server则可以实现sass文件修改保存即可在浏览器中查看效果的目的，下一小节会介绍启动本地server。 Webpack预编译sass/less同样以sass为例子： 在项目中通过npm安装一个 sass-loader 和 node-sass 模块，前者是用来加载sass相关文件的，后者是用来编译sass文件的。另外还需要安装另外两个模块 css-loader 和 style-loader ，前者是用来加载css相关文件的，后者是用来将css样式装填到html中的内联样式。 1$ npm install sass-loader node-sass css-loader style-sass -D 然后在Webpack的配置文件webpack.config.js中进行简单配置 123456789101112module:&#123; loaders:[ &#123; test: /\\.css$/,//匹配以.css结尾的文件，如果你项目不需要刻意不配置 loader: 'style!css'//这里顺序必须这样 &#125;, &#123; test: /\\.scss$/,//匹配以.scss结尾的文件 loader: 'style!css!sass' &#125; ]&#125; 前面提到过，Webpack是通过文件的依赖关系进行加载分析的，所以当程序从主入口（js文件）进入后，在依赖的资源文件中发现有sass文件后，就会利用我们配置的 sass-loader 去加载，然后用 node-sass 去解析编译成普通的css语法的样式文件，在然后就是利用 style-loader 将样式以内联样式的形式配置到html中（这里有一个问题，就是css-loader有什么用?我也没搞明白，但是不添加会报错，有知道的可以留言交流一下）。这样Webpack就完成了sass的预处理。 启动server我们都知道在前端开发中，ajax请求是需要启动一个server的。特别是在前后端分离思想中，前端开发不再像以前一样过分依赖于后端开发，以前的那种前端测试ajax请求需要装个tomcat或者其它服务器来启动server的现象已经成为过去式，现在我们可以使用像Gulp这类前端自动构建工具启动一个本地server进行测试，再也不收后端程序员钳制了（开个玩笑，和后端好好沟通才能让前端开发更方便）。那么，我们来分别看一下Gulp和Webpack是怎样实现这个功能的。 Gulp启动server在Gulp中想要启动一个本地serve，只需要以下几步： 在项目中通过npm安装一个 gulp-webserver 的模块 1$ npm install gulp-webserver -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-webserver模块，并进行简单配置 1234567891011121314151617181920212223//1.引入 gulp-webserver 模块varwebserver =require('gulp-webserver');//2.配置server taskgulp.task('webserver',function()&#123; gulp.src('./') .pipe(webserver(&#123; host:'localhost', port:80, //浏览器自动刷新 livereload:true, //显示文件目录 directoryListing:&#123; enable: true, path:'./' &#125;, &#125;));&#125;);//3.配置默认taskgulp.task('default',['webserver'],function()&#123; console.log('启动任务队列执行完毕');&#125;) 在命令行中启动server 1$ gulp 启动成功： 在浏览器地址栏中输入 localhost 打开页面验证。 经过以上这三步，我们就在Gulp中启动了一个server了。在Gulp中启动本地服务有一个很方便的配置，就是 livereload:true 属性的设置，设置后浏览器会根据你项目中资源的变化自动刷新浏览器（如果你的chrome浏览器设置该属性后在你修改文件并保存时仍没有自动刷新，可能是你的chrome浏览器不支持，可以chrome扩展程序中搜索并安装LiveReload插件），比如： 我的gulp测试目录结构： index.html1234567891011&lt;!DOCTYPE html&gt;&lt;htmllang=\"en\"&gt; &lt;head&gt; &lt;metacharset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;scriptsrc=\"/src/scripts/app.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我在app.js文件中输入以下内容，然后保存。1console.log('gulp-webserver livereload'); 浏览器中控制台上会立刻打印出一下信息： 说明浏览器自动刷新工程，这个小功能在我们开发中屡试不爽。但是，这个功能是需要结合上一小节中的 gulp.watch() 实时监控文件变化，然后执行合并压缩和sass/less编译等操作后，浏览器再刷新时才能保证是我们修改后的内容。所以， livereload:true 属性只是监控到我们修改文件后刷新浏览器重新请求文件，如果我们不重新编译修改后的文件，浏览器获取到的还是原文件，并不会展示变化。 Webpack启动server在Webpack中也可以通过插件的形式安装一个 webpack-dev-server 来实现达到启动本地server的目的，具体步骤如下： 在项目中通过npm安装一个 webpack-dev-server 的模块 1$ npm install -g webpack-dev-server -D 然后在Webpack的配置文件webpack.config.js中进行简单配置 1234567891011121314151617181920module.exports = &#123; devtool: 'eval-source-map', //webpack入口文件配置 entry: &#123; app:__dirname + \"/src/scripts/app.js\", &#125;, //webpack出口文件配置 output: &#123; path: __dirname + \"/prd/scripts/\",//输出文件路径配置 filename: \"bundle.js\"//输出文件名配置 &#125;, //本地server配置 devServer: &#123; contentBase: __dirname,//本地服务器所加载的页面所在的目录 port:8089,//本地服务端口配置 colors: true,//终端中输出结果为彩色 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;&#125; 在命令行中启动server 1$ webpack-dev-server 然后你就会看见命令行输出内容很多，只要看看保证没有Error就说明成功了。 在浏览器地址栏中输入 localhost：8089 测试一下。 Webpack的启动本地服务也顺利实现了，是不是也想实现像Gulp一样浏览器自动刷新呀？那Webpack能不能实现呢？答案是肯定的，Webpack官方提供了一个辅助开发工具，它可以自动监控项目下的文件，一旦有修改保存操作，开发服务器就会自动运行Webpack 打包命令，帮我们自动将开发的代码重新打包。而且，如果需要的话，还能自动刷新浏览器，重新加载资源。理论上好像是这样，但是实现好像有不少限制，比如，HTML文件的自动刷新问题（html-webpack-plugin插件使用老是报错），当本地server启动在非output.path路径之外时则不能自动刷新等问题，等我再学习学习再说，或者有知道的可以留言讨论。 而这个辅助工具就是 webpack-dev-server ，它主要提供两个功能：一是为静态文件提供server服务，二是自动刷新和热替换(HMR)。所以想实现如Gulp一样的功能也是可以的，只需要在 $ webpack-dev-server 后面添加 --inline --hot 即可。需要注意的是 --inline 是自动刷新，同时在第二部中的devServer属性中有一个 inline:true 需要配置；而 --hot 是热替换（ 详细了解热替换、 了解webpack-dev-server 、 webpack-dev-server ）。 通过对比来看，好像Webpack的 webpack-dev-server 比Gulp的 gulp-server 功能要强一些。因为通过上面可以看出 webpack-dev-server 有两个大功能：一是为静态文件提供server服务，二是自动刷新（ 自动刷新其实需要两步：1.修改文件后，文件自动编译{包括合并压缩或者语法编译等}，2.刷新浏览器请求最新编译后的文件 ）和热替换(HMR)；而 gulp-server 虽然提供了启动本地server的能力和仅自动刷新浏览器的能力，缺少一个文件自动编译的能力，这需要借助其他模块实现（上一小节已介绍，结合gulp.watch()实时监控文件变化，并编译）。 另外需要注意的是，实际开发中发现 webpack-dev-server 实现自动刷新的时候，并没有执行自动编译，只是将修改的内容合并压缩等处理后发送给了浏览器，并造成了已经编译的现象，但是通过build/prd/scripts目录下的bundle.js(合并压缩后的输出文件)文件，可以发现内容并没有编译（对于Webpack还是不熟悉，好多问题等待解决）。 mock数据在现在前后端分离的思想中，前端和后端耦合度越来越小，现在唯一需要前后端密切联系的就是借口的定义和数据格式的确定。一般在项目开始前，前端和后端将项目中的接口和数据格式全部确定下来（当然项目需求变更就需要临时确立这些共识了），然后前端就可以自己mock数据了。 Gulp实现mock数据Gulp中对mock数据的实现使通过NodeJS内置的fs模块和url模块实现的，因为Gulp本身就是基于NodeJS的。还记得第一小节“模块化开发”中目录结构中的那个mock目录吗？那就是用来储存 .json 文件的mock数据目录。 配置Gulp的gulpfile.js文件1234567891011121314151617181920212223242526272829303132333435//1.引入 fs 和 url 模块varfs =require('fs');varurl =require('url');//2.重新配置一下上一小节的servergulp.task('webserver',function()&#123; gulp.src('./') .pipe(webserver(&#123; host:'localhost', port:80, livereload:true, directoryListing:&#123; enable: true, path:'./' &#125;, //mock数据配置 middleware:function(req,res,next)&#123; varurlObj = url.parse(req.url,true); switch(urlObj.pathname) &#123; case'/pro/getPro': res.setHeader('Content-Type','application/json;charaset=utf-8'); fs.readFile('./mock/list.json',function(err,data)&#123; //上面list.json路径使用相对路径，绝对路径前台无法获取数据 res.end(data); &#125;); return; case'/web/getUser': //.... return; &#125; next(); &#125; &#125;));&#125;); 具体来说，就是通过NodeJS拦截http请求，根据请求URL来模拟后端做出处理后返回不同的数据。 Webpack实现mock数据完善中。。。 版本控制对于版本控制，我们在开发过程中，也是一个使用比较频繁的功能，特别是开发团队比较大的时候，这个功能就显得更加重要了。那么Gulp和Webpack是具体怎样实现的呢？ Gulp实现版本控制 在项目中通过npm安装 gulp-rev 和 gulp-rev-collector 模块，前者用于生成文件的MD5码文件和按MD5码命名的资源文件，后者是利用MD5码，对文件名进行替换。 1$ npm install gulp-rev gulp-rev-collector -D 然后在Gulp的配置文件gulpfile.js中进行简单配置 12345678910111213141516171819202122//1.引入连个模块varrev =require('gulp-rev');varrevCollector =require('gulp-rev-collector');// 2.版本号控制 gulp.task('ver',function()&#123; gulp.src(cssFiles) .pipe(rev())//产生MD5码 .pipe(gulp.dest('./build/prd/styles/'))//重命名文件 .pipe(rev.manifest())//产生版本信息的json文件 .pipe(gulp.dest('./build/ver/styles/')); gulp.src(jsFiles) .pipe(rev()) .pipe(gulp.dest('./build/prd/scripts/')) .pipe(rev.manifest()) .pipe(gulp.dest('./build/ver/scripts/')); &#125;)//动态修改html中对css和js文件的修改 gulp.task('html',function()&#123; gulp.src(['./build/ver/**/*','./build/*.html']) .pipe(revCollector()) .pipe(gulp.dest('./build/'));&#125;) Gulp实现版本控制很方便，将这两个task加入gulp.watch()中，即可实现修改保存文件实时自动修改版本的功能。 Webpack实现版本控制Webpack中需要版本控制的有css、js文件，不过Webpack的版本控制只实现了将css、js文件添加hash值方式命名的文件方式，修改引用路径中的文件名需手动实现。 不过实现确实很简单，只需要将webpack.config.js配置文件中的output.filename和plugins中的输出文件名称修改一下即可。12345678910111213module.exports = &#123; devtool: 'eval-source-map', entry: &#123; app: __dirname + \"/src/scripts/app.js\", &#125;, output: &#123; path: __dirname + \"/prd/scripts/\", filename: \"[name]-[hash].js\"//修改输出文件名 &#125;, plugins: [ newEt('./styles/[name]-[hash].css'),//修改输出文件名 ]&#125; 这样就解决了。 组件控制组件控制原本应该放在模块化小节或者前后小节，但是由于实在不知道该怎样比较，其实也没啥可比较的，就放在最后了。 Gulp和Webpack对各自组件的管理都是使用的npm进行的组件管理，想了解更多npm组件的管理的可自行百度，或者看看这篇文章入个门《npm介绍》。 总结通过以上八个方面的功能对比，Gulp和Webpack基本都能满足前端自动化构建工具的任务，但是还是看出两个工具的侧重点是不通的，Gulp侧重整个过程的控制，Webpack在模块打包方面有特别出众。所以，Gulp + Webpack 组合使用可能更方便。 很长的一篇总结文章，前前后后花了两天时间终于写完了，还有很多测试没做，并且还有很多疑问没解决。慢慢学习，慢慢在补充修改吧。","tags":[{"name":"Webpack,Gulp","slug":"Webpack-Gulp","permalink":"http://yoursite.com/tags/Webpack-Gulp/"}]},{"title":"Gulp和Webpack对比","date":"2017-03-18T13:50:52.000Z","path":"2017/03/18/Others/BFC神奇背后的原理/","text":"原文： 前端精选文摘：BFC 神奇背后的原理 BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清浮动，防止 margin 重叠等）。虽然我知道如何利用 BFC 解决这些问题，但当别人问我 BFC 是什么，我还是不能很有底气地解释清楚。于是这两天仔细阅读了CSS2.1 spec 和许多文章来全面地理解BFC。 一、BFC是什么？ 在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。 Box: CSS布局的基本单位 Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context； run-in box: css3 中才有， 这儿先不讲了。 Formatting context Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 CSS2.1 中只有 BFC和 IFC, CSS3 中还增加了 GFC和 FFC。 BFC 定义 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 二、哪些元素会生成BFC? 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 三、BFC的作用及原理1. 自适应两栏布局 代码： 12345678910111213141516171819202122&lt;style&gt; body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/body&gt; 页面： 根据BFC布局规则第3条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。 根据BFC布局规则第四条： BFC的区域不会与float box重叠。 我们可以通过通过触发main生成BFC， 来实现自适应两栏布局。 123.main &#123; overflow: hidden;&#125; 当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下： 2. 清除内部浮动 代码： 12345678910111213141516171819&lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 页面： 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。 代码： 123.par &#123; overflow: hidden;&#125; 效果如下： 3. 防止垂直 margin 重叠 代码： 1234567891011121314&lt;style&gt; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 页面： 两个p之间的距离为100px，发送了margin重叠。 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 代码： 12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden; &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=\"wrap\"&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果如下: 总结 其实以上的几个例子都体现了BFC布局规则第五条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。 您可能感兴趣的相关文章 使用 CSS3 实现超炫的加载动画效果 你想不到的！CSS 实现的各种球体效果 精心挑选的在线 CSS3 代码生成工具 推荐10个特别方便的 CSS3 开发工具 推荐收集的40款优秀的免费 CSS 工具","tags":[{"name":"Webpack,Gulp","slug":"Webpack-Gulp","permalink":"http://yoursite.com/tags/Webpack-Gulp/"}]},{"title":"CSS命名规范——BEM思想","date":"2017-03-15T13:40:20.000Z","path":"2017/03/15/Others/CSS命名规范——BEM思想/","text":"转载自CSS命名规范——BEM思想（非常赞的规范） 人们问我最多的问题之一是在CSS类名中--和__是什么意思？它们的出现是源于BEM和Nicolas Gallagher… BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。 重要的是要注意，我使用的基于BEM的命名方式是经过Nicolas Gallagher修改过的。这篇文章中介绍的这种命名技术并不是原始的BEM，但却是一个我更喜欢的改进版。无论实际使用了什么样的符号，它们其实都是基于同样的BEM原则。 命名约定的模式如下：123.block&#123;&#125; .block__element&#123;&#125; .block--modifier&#123;&#125; .block 代表了更高级别的抽象或组件。 .block__element 代表.block的后代，用于形成一个完整的.block的整体。 .block--modifier代表.block的不同状态或不同版本。 之所以使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定，如：123.site-search&#123;&#125; /* 块 */ .site-search__field&#123;&#125; /* 元素 */ .site-search--full&#123;&#125; /* 修饰符 */ BEM的关键是光凭名字就可以告诉其他开发者某个标记是用来干什么的。通过浏览HTML代码中的class属性，你就能够明白模块之间是如何关联的：有一些仅仅是组件，有一些则是这些组件的子孙或者是元素,还有一些是组件的其他形态或者是修饰符。我们用一个类比/模型来思考一下下面的这些元素是怎么关联的：12345.person&#123;&#125; .person__hand&#123;&#125; .person--female&#123;&#125; .person--female__hand&#123;&#125; .person__hand--left&#123;&#125; 顶级块是‘person’，它拥有一些元素，如‘hand’。一个人也会有其他形态，比如女性，这种形态进而也会拥有它自己的元素。下面我们把他们写成‘常规’CSS:12345.person&#123;&#125; .hand&#123;&#125; .female&#123;&#125; .female-hand&#123;&#125; .left-hand&#123;&#125; 这些‘常规’CSS都是有意义的，但是它们之间却有些脱节。就拿.female来说，是指女性人类还是某种雌性的动物？还有.hand，是在说一只钟表的指针（译注：英文中hand有指针的意思）？还是一只正在玩纸牌的手？使用BEM我们可以获得更多的描述和更加清晰的结构，单单通过我们代码中的命名就能知道元素之间的关联。BEM真是强大。 再来看一个之前用‘常规’方式命名的.site-search的例子：1234&lt;form class=\"site-search full\"&gt; &lt;input type=\"text\" class=\"field\"&gt; &lt;input type=\"Submit\" value =\"Search\" class=\"button\"&gt; &lt;/form&gt; 这些CSS类名真是太不精确了，并不能告诉我们足够的信息。尽管我们可以用它们来完成工作，但它们确实非常含糊不清。用BEM记号法就会是下面这个样子：1234&lt;form class=\"site-search site-search--full\"&gt; &lt;input type=\"text\" class=\"site-search__field\"&gt; &lt;input type=\"Submit\" value =\"Search\" class=\"site-search__button\"&gt; &lt;/form&gt; 我们能清晰地看到有个叫.site-search的块，他内部是一个叫.site-search__field的元素。并且.site-search还有另外一种形态叫.site-search–full。 我们再来举个例子…… 如果你熟悉OOCSS（面向对象CSS），那么你对media对象一定也不陌生。用BEM的方式，media对象就会是下面这个样子：1234.media&#123;&#125; .media__img&#123;&#125; .media__img--rev&#123;&#125; .media__body&#123;&#125; 从这种CSS的写法上我们就已经知道.mediaimg 和.mediabody一定是位于.media内部的，而且.mediaimg–rev是.mediaimg的另一种形态。仅仅通过CSS选择器的名字我们就能获取到以上全部信息。 BEM的另外一个好处是针对下面这种情况：1234567&lt;div class=\"media\"&gt; &lt;img src=\"logo.png\" alt=\"Foo Corp logo\" class=\"img-rev\"&gt; &lt;div class=\"body\"&gt; &lt;h3 class=\"alpha\"&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=\"lede\"&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 光从上面的代码来看，我们根本不明白.media和.alpha两个class彼此之间是如何相互关联的？同样我们也无从知晓.body和.lede之间，或者.img-rev 和.media之间各是什么关系？从这段HTML（除非你对那个media对象非常了解）中我们也不知道这个组件是由什么组成的和它还有什么其他的形态。如果我们用BEM方式重写这段代码：1234567&lt;div class=\"media\"&gt; &lt;img src=\"logo.png\" alt=\"Foo Corp logo\" class=\"media__img--rev\"&gt; &lt;div class=\"media__body\"&gt; &lt;h3 class=\"alpha\"&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=\"lede\"&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 我们立马就能明白.media是一个块，.media__img–rev是一个加了修饰符的.media__img的变体，它是属于.media的元素。而.media__body是一个尚未被改变过的也是属于.media的元素。所有以上这些信息都通过它们的class名称就能明白，由此看来BEM确实非常实用。 丑极了！通常人们会认为BEM这种写法难看。我敢说，如果你仅仅是因为这种代码看上去不怎么好看而羞于使用它，那么你将错失最重要的东西。除非使用BEM让代码增加了不必要的维护困难，或者这么做确实让代码更难读了，那么你在使用它之前就要三思而行了。但是，如果只是“看起来有点怪”而事实上是一种有效的手段，那么我们在开发之前当然应该充分考虑它。 是，BEM看上去确实怪怪的，但是它的好处远远超过它外观上的那点瑕疵。 BEM可能看上去有点滑稽，而且有可能导致我们输入更长的文本（大部分编辑器都有自动补全功能，而且gzip压缩将会让我们消除对文件体积的担忧），但是它依旧强大。 用还是不用BEM?我在我的所有项目中都使用了BEM记号法，因为它的有效性已经被它自己一次又一次地证明。我也极力地建议别人使用BEM，因为它让所有东西之间的联系变得更加紧密，让团队甚至是你个人都能够更加容易地维护代码。 然而，当你真正使用BEM的时候，重要的是，请记住你没必要真的在每个地方都用上它。比如：1.caps&#123; text-transform:uppercase; &#125; 这条CSS不属于任何一个BEM范畴，它仅仅只是一条单独的样式。 另一个没有使用BEM的例子是：1.site-logo&#123;&#125; 这是一个logo，我们可以把它写成BEM格式，像下面这样：12.header&#123;&#125; .header__logo&#123;&#125; 但我们没必要这么做。使用BEM的诀窍是，你要知道什么时候哪些东西是应该写成BEM格式的。因为某些东西确实是位于一个块的内部，但这并不意味它就是BEM中所说的元素。这个例子中，网站logo完全是恰巧在.header的内部，它也有可能在侧边栏或是页脚里面。一个元素的范围可能开始于任何上下文，因此你要确定只在你需要用到BEM的地方你才使用它。再看一个例子：123&lt;div class=\"content\"&gt; &lt;h1 class=\"content__headline\"&gt;Lorem ipsum dolor...&lt;/h1&gt; &lt;/div&gt; 在这个例子里，我们也许仅仅只需要另一个class，可以叫它.headline；它的样式取决于它是如何被层叠的，因为它在.content的内部；或者它只是恰巧在.content的内部。如果它是后者（即恰巧在.content的内部，而不总是在）我们就不需要使用BEM。 然而，一切都有可能潜在地用到BEM。我们再来看一下.site-logo的例子，想象一下我们想要给网站增加一点圣诞节的气氛，所以我们想有一个圣诞版的logo。于是我们有了下面的代码：12.site-logo&#123;&#125; .site-logo--xmas&#123;&#125; 我们可以通过使用–修饰符来快速地为我们的代码构建另一个版本。 BEM最难的部分之一是明确作用域是从哪开始和到哪结束的，以及什么时候使用（不使用）它。随着接触的多了，有了经验积累，你慢慢就会知道怎么用，这些问题也不再是问题。 结束语所以，BEM（或BEM的变体）是一个非常有用，强大，简单的命名约定，以至于让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确而且更加严密。 尽管BEM看上去多少有点奇怪，但是无论什么项目，它对前端开发者都是一个巨有价值的工具。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"webpack的使用","date":"2017-03-12T16:00:00.000Z","path":"2017/03/13/Framework/Webpack/webpack/","text":"原文地址 Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 前言现状伴随着移动互联的大潮，当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。 前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 模块系统的演进模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统。 &lt;script&gt;标签1234&lt;script src=\"module1.js\"&gt;&lt;/script&gt;&lt;script src=\"module2.js\"&gt;&lt;/script&gt;&lt;script src=\"libraryA.js\"&gt;&lt;/script&gt;&lt;script src=\"module3.js\"&gt;&lt;/script&gt; 这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 YUI 库。 这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突 文件只能按照&lt;script&gt; 的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonJS服务器端的 Node.js 遵循 CommonJS规范，该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。1234require(\"module\");require(\"../file.js\");exports.doStuff = function() &#123;&#125;;module.exports = someValue; 优点： 服务器端模块便于重用 NPM 中已经有将近20万个可以使用模块包 简单并容易使用 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 实现： 服务器端的 Node.js Browserify，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大 modules-webmake，类似Browserify，还不如 Browserify 灵活 wreq，Browserify 的前身 AMDAsynchronous Module Definition 规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。1234define(\"module\", [\"dep1\", \"dep2\"], function(d1, d2) &#123; return someExportedValue;&#125;);require([\"module\", \"../file\"], function(module, file) &#123; /* ... */ &#125;); 优点： 适合在浏览器环境中异步加载模块 可以并行加载多个模块 缺点： 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅 不符合通用的模块化思维方式，是一种妥协的实现 实现： RequireJS curl CMDCommon Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。123456define(function(require, exports, module) &#123; var $ = require('jquery'); var Spinning = require('./spinning'); exports.doSomething = ... module.exports = ...&#125;) 优点： 依赖就近，延迟执行 可以很容易在 Node.js 中运行 缺点： 依赖 SPM 打包，模块的加载逻辑偏重 实现： Sea.js coolie UMDUniversal Module Definition 规范类似于兼容 CommonJS 和 AMD 的语法糖，是模块定义的跨平台解决方案。 ES6 模块EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。123import \"jquery\";export function doStuff() &#123;&#125;module \"localModule\" &#123;&#125; 优点： 容易进行静态分析 面向未来的 EcmaScript 标准 缺点： 原生浏览器端还没有实现该标准 全新的命令字，新版的 Node.js才支持 实现： Babe 期望的模块系统可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。 前端模块加载前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。 模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。 分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。 要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。 所有资源都是模块在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。 如果他们都可以视作模块，并且都可以通过require的方式来加载，将带来优雅的开发体验，比如：1234require(\"./style.css\");require(\"./style.less\");require(\"./template.jade\");require(\"./image.png\"); 那么如何做到让 require 能加载各种资源呢？ 静态分析在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用 LESS 写的样式模块，可以先用 LESS 加载器将它转成一个CSS 模块，在通过 CSS 模块把他插入到页面的 &lt;style&gt; 标签中执行。Webpack 就是在这样的需求中应运而生。 同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们还需要一个模块加载的兼容策略，来避免重写所有的模块。 那么接下来，让我们开始 Webpack 的神奇之旅吧。 什么是webpackWebpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 为什么重复造轮子市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。 这些已有的模块化工具并不能很好的完成如下的目标： 将依赖树拆分成按需加载的块 初始化加载的耗时尽量少 各种静态资源都可以视作模块 将第三方库整合成模块的能力 可以自定义打包逻辑的能力 适合大项目，无论是单页还是多页的 Web 应用 Webpack 的特点Webpack 和其他模块化工具有什么区别呢？ 代码拆分Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 LoaderWebpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。 插件系统Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 准备开始我们通过具体案例来快速上手 Webpack。以下章节中的案例源码可以在 https://github.com/zhaoda/webpack-handbook/tree/master/examples/start 查看。 安装首先要安装 Node.js， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。 用 npm 安装 Webpack：1$ npm install webpack -g 此时 Webpack 已经安装到了全局环境下，可以通过命令行 webpack -h 试试。 通常我们会将 Webpack 安装到项目的依赖中，这样就可以使用项目本地版本的 Webpack。1234# 进入项目目录# 确定已经有 package.json，没有就通过 npm init 创建# 安装 webpack 依赖$ npm install webpack --save-dev Webpack 目前有两个主版本，一个是在 master 主干的稳定版，一个是在 webpack-2 分支的测试版，测试版拥有一些实验性功能并且和稳定版不兼容，在正式项目中应该使用稳定版。12345# 查看 webpack 版本信息$ npm info webpack# 安装指定版本的 webpack$ npm install webpack@1.12.x --save-dev 如果需要使用 Webpack 开发工具，要单独安装：1$ npm install webpack-dev-server --save-dev 使用首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：123456789&lt;!-- index.html --&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12// entry.jsdocument.write('It works.') 然后编译 entry.js 并打包到 bundle.js：1$ webpack entry.js bundle.js 打包过程会显示日志：123456Hash: e964f90ec65eb2c29bb9Version: webpack 1.12.2Time: 54ms Asset Size Chunks Chunk Namesbundle.js 1.42 kB 0 [emitted] main [0] ./entry.js 27 bytes &#123;0&#125; [built] 用浏览器打开 index.html 将会看到 It works. 。 接下来添加一个模块 module.js 并修改入口 entry.js：12// module.jsmodule.exports = 'It works from module.js.' 123// entry.jsdocument.write('It works.')document.write(require('./module.js')) // 添加模块 重新打包 webpack entry.js bundle.js 后刷新页面看到变化 It works.It works from module.js.1234567Hash: 279c7601d5d08396e751Version: webpack 1.12.2Time: 63ms Asset Size Chunks Chunk Namesbundle.js 1.57 kB 0 [emitted] main [0] ./entry.js 66 bytes &#123;0&#125; [built] [1] ./module.js 43 bytes &#123;0&#125; [built] Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。 LoaderWebpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。 先来看看 loader 有哪些特性？ Loader 可以通过管道方式链式调用，每个 loader 可以把资源转换成任意格式并传递给下一个 loader ，但是最后一个 loader 必须返回 JavaScript。 Loader 可以同步或异步执行。 Loader 运行在 node.js 环境中，所以可以做任何可能的事情。 Loader 可以接受参数，以此来传递配置项给 loader。 Loader 可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。 Loader 可以通过 npm 发布和安装。 除了通过 package.json 的 main 指定，通常的模块也可以导出一个 loader 来使用。 Loader 可以访问配置。 插件可以让 loader 拥有更多特性。 Loader 可以分发出附加的任意文件。 Loader 本身也是运行在 node.js 环境中的 JavaScript 模块，它通常会返回一个函数。大多数情况下，我们通过 npm 来管理 loader，但是你也可以在项目中自己写 loader 模块。 按照惯例，而非必须，loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。 在引用 loader 的时候可以使用全名 json-loader，或者使用短名 json。这个命名规则和搜索优先级顺序在 webpack 的 resolveLoader.moduleTemplates api 中定义。1Default: [&quot;*-webpack-loader&quot;, &quot;*-web-loader&quot;, &quot;*-loader&quot;, &quot;*&quot;] Loader 可以在 require() 引用模块的时候添加，也可以在 webpack 全局配置中进行绑定，还可以通过命令行的方式使用。 接上一节的例子，我们要在页面中引入一个 CSS 文件 style.css，首页将 style.css 也看成是一个模块，然后用 css-loader 来读取它，再用 style-loader 把它插入到页面中。12/* style.css */body &#123; background: yellow; &#125; 修改 entry.js：123require(\"!style-loader!css-loader!./style.css\") // 载入 style.cssdocument.write('It works.')document.write(require('./module.js')) 安装 loader：1npm install css-loader style-loader 重新编译打包，刷新页面，就可以看到黄色的页面背景了。 如果每次 require CSS 文件的时候都要写 loader 前缀，是一件很繁琐的事情。我们可以根据模块类型（扩展名）来自动绑定需要的 loader。 将 entry.js 中的 require(&quot;!style!css!./style.css&quot;) 修改为 require(&quot;./style.css&quot;) ，然后执行：1234$ webpack entry.js bundle.js --module-bind 'css=style-loader!css-loader'# 有些环境下可能需要使用双引号$ webpack entry.js bundle.js --module-bind \"css=style-loader!css-loader\" 显然，这两种使用 loader 的方式，效果是一样的。 配置文件Webpack 在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的 webpack.config.js 文件，这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 –config 选项来指定配置文件。 继续我们的案例，在根目录创建 package.json 来添加 webpack 需要的依赖：12345678910111213141516171819&#123; \"name\": \"webpack-example\", \"version\": \"1.0.0\", \"description\": \"A simple webpack example.\", \"main\": \"bundle.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"webpack\" ], \"author\": \"zhaoda\", \"license\": \"MIT\", \"devDependencies\": &#123; \"css-loader\": \"^0.21.0\", \"style-loader\": \"^0.13.0\", \"webpack\": \"^1.12.2\" &#125;&#125; 123# 如果没有写入权限，请尝试如下代码更改权限chflags -R nouchg .sudo chmod 775 package.json 别忘了运行 npm install。 然后创建一个配置文件 webpack.config.js：1234567891011121314var webpack = require('webpack')module.exports = &#123; entry: './entry.js', output: &#123; path: \\_\\_dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;&#125; 同时简化 entry.js 中的 style.css 加载方式： require(‘./style.css’)最后运行 webpack，可以看到 webpack 通过配置文件执行的结果和上一章节通过命令行 webpack entry.js bundle.js --module-bind &#39;css=style-loader!css-loader&#39; 执行的结果是一样的。 插件插件可以完成更多 loader 不能完成的功能。 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。 Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件。 接下来，我们利用一个最简单的 BannerPlugin 内置插件来实践插件的配置和运行，这个插件的作用是给输出的文件头部添加注释信息。 修改 webpack.config.js，添加 plugins：1234567891011121314151617var webpack = require('webpack')module.exports = &#123; entry: './entry.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;, plugins: [ new webpack.BannerPlugin('This file is created by zhaoda') ]&#125; 然后运行 webpack，打开 bundle.js，可以看到文件头部出现了我们指定的注释信息：12345/*! This file is created by zhaoda *//******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;// 后面代码省略 开发环境当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。1$ webpack --progress --colors 如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。1$ webpack --progress --colors --watch 当然，使用 webpack-dev-server 开发服务是一个更好的选择。它将在 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开 http://localhost:8080/ 或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。12345# 安装$ npm install webpack-dev-server -g# 运行$ webpack-dev-server --progress --colors 故障处理Webpack 的配置比较复杂，很容出现错误，下面是一些通常的故障处理手段。 一般情况下，webpack 如果出问题，会打印一些简单的错误信息，比如模块没有找到。我们还可以通过参数 --display-error-details 来打印错误详情。12345678910111213141516171819202122232425262728$ webpack --display-error-detailsHash: a40fbc6d852c51fceadbVersion: webpack 1.12.2Time: 586ms Asset Size Chunks Chunk Namesbundle.js 12.1 kB 0 [emitted] main [0] ./entry.js 153 bytes &#123;0&#125; [built] [1 error] [5] ./module.js 43 bytes &#123;0&#125; [built] + 4 hidden modulesERROR in ./entry.jsModule not found: Error: Cannot resolve 'file' or 'directory' ./badpathmodule in /Users/zhaoda/data/projects/webpack-handbook/examplesresolve file /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json doesn't existresolve directory /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist (directory default file) /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule/package.json doesn't exist (directory description file)[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json] @ ./entry.js 3:0-26 Webpack 的配置提供了 resolve 和 resolveLoader 参数来设置模块解析的处理细节，resolve 用来配置应用层的模块（要被打包的模块）解析，resolveLoader 用来配置 loader 模块的解析。 当引入通过 npm 安装的 node.js 模块时，可能出现找不到依赖的错误。Node.js 模块的依赖解析算法很简单，是通过查看模块的每一层父目录中的 node_modules 文件夹来查询依赖的。当出现 Node.js 模块依赖查找失败的时候，可以尝试设置 resolve.fallback 和 resolveLoader.fallback 来解决问题。1234module.exports = &#123; resolve: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;, resolveLoader: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;&#125;; Webpack 中涉及路径配置最好使用绝对路径，建议通过 path.resolve(__dirname, &quot;app/folder&quot;) 或 path.join(__dirname, &quot;app&quot;, &quot;folder&quot;) 的方式来配置，以兼容 Windows 环境。 高级以下章节是进阶内容。 CommonJS 规范CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。 这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 ServerJS。 我在这里描述的并不是一个技术问题，而是一件重大的事情，让大家走到一起来做决定，迈出第一步，来建立一个更大更酷的东西。 —— Kevin Dangoor’s What Server Side JavaScript needs 2009年8月，这个项目改名为 CommonJS，以显示其 API 的更广泛实用性。CommonJS 是一套规范，它的创建和核准是开放的。这个规范已经有很多版本和具体实现。CommonJS 并不是属于 ECMAScript TC39 小组的工作，但 TC39 中的一些成员参与 CommonJS 的制定。2013年5月，Node.js 的包管理器 NPM 的作者 Isaac Z. Schlueter 说 CommonJS 已经过时，Node.js 的内核开发者已经废弃了该规范。 CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。 一个直观的例子：1234// moduleA.jsmodule.exports = function( value )&#123; return value * 2;&#125; 123// moduleB.jsvar multiplyBy2 = require('./moduleA');var result = multiplyBy2(4); CommonJS 是同步加载模块，但其实也有浏览器端的实现，其原理是现将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 的源码来理解其解析（resolve）的过程。 更多关于 CommonJS 规范的内容请查看 http://wiki.commonjs.org/wiki/CommonJS。 AMD 规范AMD（异步模块定义）是为浏览器环境设计的，因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件。 AMD 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。 模块通过 define 函数定义在闭包中，格式如下：1define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。1define(function(require, exports, module) &#123;&#125;） factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 一些用例： 定义一个名为 myModule 的模块，它依赖 jQuery 模块：123456define('myModule', ['jquery'], function($) &#123; // $ 是 jquery 模块的输出 $('body').text('hello world');&#125;);// 使用define(['myModule'], function(myModule) &#123;&#125;); 注意：在 webpack 中，模块名只有局部作用域，在 Require.js 中模块名是全局作用域，可以在全局引用。 定义一个没有 id 值的匿名模块，通常作为应用的启动函数：123define(['jquery'], function($) &#123; $('body').text('hello world');&#125;); 依赖多个模块的定义：1234define(['jquery', './math.js'], function($, math) &#123; // $ 和 math 一次传入 factory $('body').text('hello world');&#125;); 模块输出：123456789define(['jquery'], function($) &#123; var HelloWorldize = function(selector)&#123; $(selector).text('hello world'); &#125;; // HelloWorldize 是该模块输出的对外接口 return HelloWorldize;&#125;); 在模块定义内部引用依赖：1234define(function(require) &#123; var $ = require('jquery'); $('body').text('hello world');&#125;); 参考链接模块规范CommonJS 规范Asynchronous Module DefinitionCommon Module DefinitionCMD 模块定义规范Universal Module DefinitionECMAScript 6 Module什么是 AMD、 CommonJS、 UMD关于 CommonJS AMD CMD UMD为什么我推荐 requirejs 而不是 seajsAMD 和 CMD 的区别有哪些前端模块化开发的价值What Server Side JavaScript needs 模块系统RequireJScurlSea.jscoolieBrowserifymodules-webmakewreq WebpackWebpack 官方文档React Webpack cookbook 编译Babel","tags":[{"name":"webpack,打包工具","slug":"webpack-打包工具","permalink":"http://yoursite.com/tags/webpack-打包工具/"}]},{"title":"mongodb的安装、配置与基本使用","date":"2017-03-11T16:00:00.000Z","path":"2017/03/12/DataBase/mongodb/mongodb的安装、配置与基本使用/","text":"相关网址MongoDB官网:https://www.mongodb.com/下载地址:https://www.mongodb.com/download-center?jmp=nav#community菜鸟教程：http://www.runoob.com/mongodb/mongodb-tutorial.html 为什么选择MongoDB?1.只要会js/json就会mongodb(学习成本低)2.mongodb对js的兼容性最好3.mongodb存数据就是存json 安装与配置 MongoDB 数据库环境安装mongodb在官网下载，直接安装即可，默认下一步直到完成 验证安装成功：在cmd终端中输入： mongo --version 或是 mongod --version ,能看到版本好,说明安装成功如果终端中输入 mongo –version 提示找不到命令,一定要看看是不是没有配置mongodb的环境变量,并且配置环境变量之后一定要记得重启cmd 配置环境变量我的电脑右键–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量–&gt;path添加mongodb的安装目录的bin目录到最后即可 window7安装MongoDB存在的问题建议:升级到window10解决步骤: 将你的操作系统升级到window7最新版 安装 vc_redist.x64.exe 如果你的电脑是32位的,再安装32位的mongodb软件 mongodb-win32-i386-3.2.11-signed.msi mongodb配置创建数据目录(必须)我们在安装完成MongoDB后需要创建一个存放数据的目录。请注意，数据目录应该放在根目录下（(如： C:\\ 或者 D:\\ 等 ),数据目录的命名随意,比如我就命名 mongodb_datas 启动服务器(必须) 启动MongoDB服务器的方式一：通过终端指令去启动 首先在终端切换到你的MongoDB的安装目录的bin目录下(当然如果配置了环境变量在哪个目录下都可以了) 在终端执行: mongod.exe –dbpath c:\\mongodb_datas ,如果成功启动就表示一切都OK了 注意点: 32位版本使用下面的命令启动数据服务：1mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1 - 执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了， - 千万不要关闭，否则无法连接，如果对数据库的操作结束，可以打开该控制台通过 `Ctrl + C` 关闭。 启动MongoDB服务器的方式二:方式一的延续,把上面的指令做成一个批处理文件.bat 新建一个文本文件修改后缀为.bat，以记事本的方式打开，输入mongod.exe --dbpath c:\\mongodb_datas 启动MongoDB服务器的方式三:将MongoDB服务器作为Windows服务运行 以管理员的身份打开命令行输入下面的 1mongod.exe --bind_ip 127.0.0.1 --logpath \"C:/mongodb_datas/server_log/mongodb.log\" --logappend --dbpath \"c:/mongodb_datas\" --port 27017 --serviceName \"MongoDBServer\" --serviceDisplayName \"MongoDBServerDisplayName\" --install 补充:从Windows服务中卸载 MongoDB 服务 先停止要删除的服务(比如MongoDBServer) 以管理员身份运行cmd,在cmd中输入: sc delete 服务名称(比如MongoDBServer) 千万不要删错了，不然你的系统可能就挂了 注意点: mongodb.log 这个日志文件一定要先创建好,才能执行指令 必须要以管理员的身份打开cmd窗口,并运行 MongoDB 数据库存储结构 和Excel对比一下即可明 Excel MongoDB 创建工作簿 创建数据库 创建一个sheet(工作表单) 创建集合 确立表头,插入数据 插入文档(确立表头) 核心思想: 1. 分门别类的存储数据 2. mongodb是以`集合`的概念来区分不同数据的,比如用户集合,商品集合,订单集合等等,不同的数据要放在不同的集合中去统一管理 3. 集合里面存储的可以认为是一个数组 4. 数组中的每一个对象,可以认为就是JSON对象,在mongodb中我们称之为 `文档` 5. 文档的结构可以随意,但是必须统一,也就是说,同一个集合中,所有的文档一定要遵守相同的数据结构 其他: 集合的作用就是用来隔离数据,分门别类的存储数据 操作MongoDB的步骤1.创建数据库中数据的存储目录2.启动MongoDB的服务实例3.创建数据库4.创建集合5.创建文档 如何连接到MongoDB服务器并且操作它？注意：在进行连接之前请确保你的服务实例是开启状态的（不要关闭刚才开启的数据服务实例）。 可以使用两种方式来连接到MongoDB服务器并且操作它 连接方式1:使用MongoDB自带的MongoDB后台管理 Shell 在终端中输入 `mongo` 或是 `mongo --host 127.0.0.1 --port 27017` mongo 命令默认去连接本机上的 MongoDB 服务实例：`127.0.0.1:27017`，可以通过下面的命令 指定连接的主机名和端口号： 1mongo --host 127.0.0.1 --port 27017 如果看到类似于如下的字样说明连接成功： 123456789MongoDB shell version v3.4.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.2Server has startup warnings:2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten]2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten]&gt; 如果提示 “无法连接主机”，请检查你的 MongoDB 数据服务实例是否开启。 操作方式1:在终端中使用mongodb的指令进行操作 常见指令：见下一个知识点 连接及操作方式2:使用图形化客户端工具： robomongo(跨平台) : https://robomongo.org/download 基本操作命令可以参考: http://www.yiibai.com/mongodb/mongodb_create_collection.html http://www.runoob.com/mongodb/mongodb-tutorial.html show dbs 查看当前服务实例上所有的数据库 use 数据库名称 如果数据库不存在，则创建数据库，否则切换到指定数据库。 db.dropDatabase() 删除数据库,注意,要在切换的数据库中删除 db 查看当前所处的数据库 show collections 查看当前数据库中所有的集合 db.createCollection(&quot;集合名称&quot;) 创建集合 db.集合名称.drop() 删除集合 db.集合名称.insert({数据文档}) 插入的每一条文档会自动帮我们生成一个_id字段,它是mongodb自动维护的,不需要我们关心 db.集合名称.find() 查询指定集合中所有的数据 可以通过 db.集合名称.find().pretty() 美化输出格式 默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据 模糊查询的条件 {要查询的字段:{$regex: ‘关键字’}} db.集合名称.update({更新条件}, {要更新的字段}) 更新指定集合数据,注意点,要更新的字段一定要这样写 {$set:{字段的名称:字段的值}}, db.集合名称.remove({删除条件}) 删除指定集合中的数据 exit 退出当前操作 cls 清屏 注意点：更新和删除时一般都需要带条件，除非是全部更新与全部删除，不过全部更新与全部删除这样很危险,实际操作过程中很少 使用 Node 操作 MongoDB安装 MongoDB 官方提供的驱动包：1npm install --save mongodb 具体操作方式请参考官方文档：https://www.npmjs.com/package/mongodb","tags":[{"name":"mongodb,数据库","slug":"mongodb-数据库","permalink":"http://yoursite.com/tags/mongodb-数据库/"}]},{"title":"nodejs","date":"2017-03-06T16:00:00.000Z","path":"2017/03/07/Framework/Node/node/","text":"##","tags":[{"name":"nodejs,node,javascript","slug":"nodejs-node-javascript","permalink":"http://yoursite.com/tags/nodejs-node-javascript/"}]},{"title":"express的基本使用","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/Framework/Express/express的基本使用/","text":"安装首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。12$ mkdir myapp$ cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。1$ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外：1entry point: (index.js) 键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。 接下来安装 Express 并将其保存到依赖列表中：1$ npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可：1$ npm install express 安装 Node 模块时，如果指定了 –save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。 路由路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。 路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback…], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。 下面是一个基本的路由示例：123456789101112var express = require('express');var app = express();// 当以GET方法请求根路径，服务器返回hello worldapp.get('/', function(req, res) &#123; res.send('hello world');&#125;);app.listen(3000, '127.0.0.1', function(err)&#123; if (err) return console.error(err) console.log('start ok!!!')&#125;); //开启服务器，监听3000端口，网址和回调函数可以省略 路由方法123456789// GET method routeapp.get('/', function (req, res) &#123; res.send('GET request to the homepage');&#125;);// POST method routeapp.post('/', function (req, res) &#123; res.send('POST request to the homepage');&#125;); Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。 有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如： app[‘m-search’](‘/‘, function … app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 在下面的例子中，来自 “/secret” 的请求，不管使用 GET、POST、PUT、DELETE 或其他任何 http 模块支持的 HTTP 请求，句柄都会得到执行。1234app.all('/secret', function (req, res, next) &#123; console.log('Accessing the secret section ...'); next(); // pass control to the next handler&#125;); 查询字符串的处理 get请求：express的req.query可以获取到查询字符串，并且默认就是对象的形式 1234567// http://localhost:3000/login?username=zhangsan&amp;password=123app.get('/login', (req, res, next) =&gt; &#123; console.log(req.query) //&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;) post请求：需要使用body-parser第三方插件 12345678910111213141516const bodyParser = require('body-parser')app.use(bodyParser.urlencoded(&#123;extended: false&#125;))app.post('/login', (req, res, next) =&gt; &#123; console.log(`req.body`)//&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;)// 或者下面这种凡事方式const bodyParser = require('body-parser')app.post('/login', bodyParser.urlencoded(&#123;extended: false&#125;), (req, res, next) =&gt; &#123; console.log(`req.body`)//&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;) 路由路径路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。 Express 使用 path-to-regexp 匹配路由路径，请参考文档查阅所有定义路由路径的方法。 Express Route Tester 是测试基本 Express 路径的好工具，但不支持模式匹配。查询字符串不是路由路径的一部分。 使用字符串的路由路径示例： 1234567891011121314// 匹配根路径的请求app.get('/', function (req, res) &#123; res.send('root');&#125;);// 匹配 /about 路径的请求app.get('/about', function (req, res) &#123; res.send('about');&#125;);// 匹配 /random.text 路径的请求app.get('/random.text', function (req, res) &#123; res.send('random.text');&#125;); 使用字符串模式的路由路径示例： 12345678910111213141516171819// 匹配 acd 和 abcdapp.get('/ab?cd', function(req, res) &#123; res.send('ab?cd');&#125;);// 匹配 abcd、abbcd、abbbcd等app.get('/ab+cd', function(req, res) &#123; res.send('ab+cd');&#125;);// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等app.get('/ab*cd', function(req, res) &#123; res.send('ab*cd');&#125;);// 匹配 /abe 和 /abcdeapp.get('/ab(cd)?e', function(req, res) &#123; res.send('ab(cd)?e');&#125;); 字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。 使用正则表达式的路由路径示例：123456789// 匹配任何路径中含有 a 的路径：app.get(/a/, function(req, res) &#123; res.send('/a/');&#125;);// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res) &#123; res.send('/.*fly$/');&#125;); 路由句柄可以为请求处理提供多个回调函数，其行为类似 中间件。唯一的区别是这些回调函数有可能调用 next(‘route’) 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。 路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合，如下所示. 使用一个回调函数处理路由： 123app.get('/example/a', function (req, res) &#123; res.send('Hello from A!');&#125;); 使用多个回调函数处理路由（记得指定 next 对象）： 123456app.get('/example/b', function (req, res, next) &#123; console.log('response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from B!');&#125;); 使用回调函数数组处理路由： 123456789101112131415var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/example/c', [cb0, cb1, cb2]); 混合使用函数和函数数组处理路由： 12345678910111213141516var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;app.get('/example/d', [cb0, cb1], function (req, res, next) &#123; console.log('response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from D!');&#125;); 相应方法下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。 方法 描述 res.download() 提示下载文件。 res.end() 终结响应处理流程。 res.json() 发送一个 JSON 格式的响应。 res.jsonp() 发送一个支持 JSONP 的 JSON 格式的响应。 res.redirect() 重定向请求。 res.render() 渲染视图模板。 res.send() 发送各种类型的响应。 res.sendFile 以八位字节流的形式发送文件。 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 app.route()可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。请参考 Router() 文档 了解更多有关路由的信息。 下面这个示例程序使用 app.route() 定义了链式路由句柄。12345678910app.route('/book') .get(function(req, res) &#123; res.send('Get a random book'); &#125;) .post(function(req, res) &#123; res.send('Add a book'); &#125;) .put(function(req, res) &#123; res.send('Update the book'); &#125;); express.Router可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。 下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。 在 app 目录下创建名为 birds.js 的文件，内容如下：123456789101112131415161718var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 然后在应用中加载路由模块：123var birds = require('./birds');...app.use('/birds', birds); 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。 使用中间件Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。中间件的功能包括： 执行任何代码。 修改请求和响应对象。 终结请求-响应循环。 调用堆栈中的下一个中间件。 如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。Express 应用可使用如下几种中间件： 应用级中间件] 路由级中间件 错误处理中间件 内置中间件 第三方中间件 使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。 应用级中间件应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如：123456789101112131415161718var app = express();// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use('/user/:id', function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; res.send('USER');&#125;); 下面这个例子展示了在一个挂载点装载一组中间件。12345678// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息app.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;); 作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。123456789101112// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; console.log('ID:', req.params.id); next();&#125;, function (req, res, next) &#123; res.send('User Info'); // 终止了请求-响应循环&#125;);// 处理 /user/:id， 打印出用户 id，该路由永远不会被执行app.get('/user/:id', function (req, res, next) &#123; res.end(req.params.id);&#125;); 如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由。 注意： next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效。123456789101112131415// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 否则将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面app.get('/user/:id', function (req, res, next) &#123; res.render('special');&#125;); 路由级中间件路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。1var router = express.Router(); 路由级使用 router.use() 或 router.VERB() 加载。上述在应用级创建的中间件系统，可通过如下代码改写为路由级：12345678910111213141516171819202122232425262728293031323334353637var app = express();var router = express.Router();// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 负责将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面router.get('/user/:id', function (req, res, next) &#123; console.log(req.params.id); res.render('special');&#125;);// 将路由挂载至应用app.use('/', router); 错误处理中间件 错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 请参考 错误处理 一章了解更多关于错误处理中间件的内容。 内置中间件从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。 express.static(root, [options])express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。 参数 root 指提供静态资源的根目录。 可选的 options 参数拥有如下属性。 属性 描述 类型 缺省值 dotfiles 是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore” String “ignore” etag 是否启用 etag 生成 Boolean true extensions 设置文件扩展名备份选项 Array [] index 发送目录索引文件，设置为 false 禁用目录索引。 Mixed “index.html” lastModified 设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false。 Boolean true maxAge 以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性。 Number 0 redirect 当路径为目录时，重定向至 “/”。 Boolean true setHeaders 设置 HTTP 头以提供文件的函数。 Function 下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。12345678910111213var options = &#123; dotfiles: 'ignore', etag: false, extensions: ['htm', 'html'], index: false, maxAge: '1d', redirect: false, setHeaders: function (res, path, stat) &#123; res.set('x-timestamp', Date.now()); &#125;&#125;app.use(express.static('public', options)); 每个应用可有多个静态目录。123app.use(express.static('public'));app.use(express.static('uploads'));app.use(express.static('files')); 更多关于 serve-static 和其参数的信息，请参考 serve-static 文档。 第三方中间件通过使用第三方中间件从而为 Express 应用增加更多功能。安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser1$ npm install cookie-parser 123456var express = require('express');var app = express();var cookieParser = require('cookie-parser');// 加载用于解析 cookie 的中间件app.use(cookieParser()); 请参考 第三方中间件 获取 Express 中经常用到的第三方中间件列表。 在 Express 中使用模板引擎需要在应用中进行如下设置才能让 Express 渲染模板文件： views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’) view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’)然后安装相应的模板引擎 npm 软件1$ npm install jade --save 和 Express 兼容的模板引擎，比如 Jade，通过 res.render() 调用其导出方法 __express(filePath, options, callback) 渲染模板。 有一些模板引擎不遵循这种约定，Consolidate.js 能将 Node 中所有流行的模板引擎映射为这种约定，这样就可以和 Express 无缝衔接。 一旦 view engine 设置成功，就不需要显式指定引擎，或者在应用中加载模板引擎模块，Express 已经在内部加载，如下所示。1app.set('view engine', 'jade'); 在 views 目录下生成名为 index.jade 的 Jade 模板文件，内容如下：12345html head title!= title body h1!= message 然后创建一个路由渲染 index.jade 文件。如果没有设置 view engine，您需要指明视图文件的后缀，否则就会遗漏它。123app.get('/', function (req, res) &#123; res.render('index', &#123; title: 'Hey', message: 'Hello there!'&#125;);&#125;); 此时向主页发送请求，“index.jade” 会被渲染为 HTML。 请阅读 “为 Express 开发模板引擎” 了解模板引擎在 Express 中是如何工作的。 错误处理定义错误处理中间件和定义其他中间件一样，除了需要 4 个参数，而不是 3 个，其格式如下 (err, req, res, next)。例如：1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 在其他 app.use() 和路由调用后，最后定义错误处理中间件，比如：12345678var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑&#125;); 中间件返回的响应是随意的，可以响应一个 HTML 错误页面、一句简单的话、一个 JSON 字符串，或者其他任何您想要的东西。 为了便于组织（更高级的框架），您可能会像定义常规中间件一样，定义多个错误处理中间件。比如您想为使用 XHR 的请求定义一个，还想为没有使用的定义一个，那么：12345678var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(logErrors);app.use(clientErrorHandler);app.use(errorHandler); logErrors 将请求和错误信息写入标准错误输出、日志或类似服务：1234function logErrors(err, req, res, next) &#123; console.error(err.stack); next(err);&#125; clientErrorHandler 的定义如下（注意这里将错误直接传给了 next）：1234567function clientErrorHandler(err, req, res, next) &#123; if (req.xhr) &#123; res.status(500).send(&#123; error: 'Something blew up!' &#125;); &#125; else &#123; next(err); &#125;&#125; errorHandler 能捕获所有错误，其定义如下：1234function errorHandler(err, req, res, next) &#123; res.status(500); res.render('error', &#123; error: err &#125;);&#125; 如果向 next() 传入参数（除了 ‘route’ 字符串），Express 会认为当前请求有错误的输出，因此跳过后续其他非错误处理和路由/中间件函数。如果需做特殊处理，需要创建新的错误处理路由，如下节所示。 如果路由句柄有多个回调函数，可使用 ‘route’ 参数跳到下一个路由句柄。比如：12345678910111213app.get('/a_route_behind_paywall', function checkIfPaidSubscriber(req, res, next) &#123; if(!req.user.hasPaid) &#123; // 继续处理该请求 next('route'); &#125; &#125;, function getPaidContent(req, res, next) &#123; PaidContent.find(function(err, doc) &#123; if(err) return next(err); res.json(doc); &#125;); &#125;); 在这个例子中，句柄 getPaidContent 会被跳过，但 app 中为 /a_route_behind_paywall 定义的其他句柄则会继续执行。 next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄。 缺省错误处理句柄Express 内置了一个错误处理句柄，它可以捕获应用中可能出现的任意错误。这个缺省的错误处理中间件将被添加到中间件堆栈的底部。 如果你向 next() 传递了一个 error ，而你并没有在错误处理句柄中处理这个 error，Express 内置的缺省错误处理句柄就是最后兜底的。最后错误将被连同堆栈追踪信息一同反馈到客户端。堆栈追踪信息并不会在生产环境中反馈到客户端。 设置环境变量 NODE_ENV 为 “production” 就可以让应用运行在生产环境模式下。 如果你已经开始向 response 输出数据了，这时才调用 next() 并传递了一个 error，比如你在将向客户端输出数据流时遇到一个错误，Express 内置的缺省错误处理句柄将帮你关闭连接并告知 request 请求失败。 因此，当你添加了一个自定义的错误处理句柄后，如果已经向客户端发送包头信息了，你还可以将错误处理交给 Express 内置的错误处理机制。1234567function errorHandler(err, req, res, next) &#123; if (res.headersSent) &#123; return next(err); &#125; res.status(500); res.render('error', &#123; error: err &#125;);&#125;","tags":[{"name":"express,node","slug":"express-node","permalink":"http://yoursite.com/tags/express-node/"}]},{"title":"gulp插件的使用","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/Framework/Gulp/gulp插件的使用/","text":"常用插件列表 插件名称 作用 del 删除文件或文件夹 gulp-less 编译LESS文件 gulp-rname 重命名文件 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 js 文件 gulp-concat-css 合并 css 文件 gulp-cssnano 压缩 css gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-load-plugins 依赖自动加载 gulp-useref 自动合并打包处理 gulp-wrap 包装内容 gulp-angular-templatecache AngularJS 模板缓存 browser-sync 和 gulp 配合使用实现文件改变执行某个任务后自动刷新 yargs 获取命令行参数 gulp-if 根据判断执行某个插件 gulp-angular-templatecache安装插件1npm install --save-dev gulp-angular-templatecache 基本使用ulpfile.js 连接模板目录中所有.html文件的内容，并保存到public / templates.js（默认文件名）。1234567var gulp = require('gulp');var templateCache = require('gulp-angular-templatecache');gulp.task('default', function () &#123; return gulp.src('templates/**/*.html') .pipe(templateCache()) .pipe(gulp.dest('public'));&#125;); 结果(public/templates.js) 输出样式（预处理）。1234567891011angular.module(\"templates\").run([$templateCache, function($templateCache) &#123; $templateCache.put(\"template1.html\", // template1.html content (escaped) ); $templateCache.put(\"template2.html\", // template2.html content (escaped) ); // etc. &#125;]); 将此文件包含在您的应用程序中，AngularJS将使用$ templateCache（如果可用）。注意：这个插件不会默认创建一个新的AngularJS模块，但需要调用templates模块。如果想要创建新模块，请将 options.standalone 设置为true。 注意：如果在Windows上使用Visual Studio，您可能会遇到此错误消息：ASPNETCOMPILER : error ASPRUNTIME: The specified path, file name, or both are too long. The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters.这很可能是由于路径名太长，可以通过在 lodash.bindpackage.json 中添加一个 dev dependecy 来修复。无论如何，如果你遇到这个错误，请在＃62中删除一个注释，我们可以合并＃63。 APIgulp-angular-templatecache(filename, options) filename - {string} [filename=’templates.js’] Name to use when concatenating. options root - {string} Prefix for template URLs. module - {string} [module=’templates’] Name of AngularJS module. standalone - {boolean} [standalone=false] Create a new AngularJS module, instead of using an existing. base {string | function} [base=file.base] Override file base path. moduleSystem {string} Wrap the templateCache in a module system. Currently supported systems: RequireJS, Browserify, ES6 and IIFE (Immediately-Invoked Function Expression). transformUrl {function} Transform the generated URL before it’s put into $templateCache. 123transformUrl: function(url) &#123; return url.replace(/\\.tpl\\.html$/, '.html')&#125; templateHeader {string} [templateHeader=see below] Override template header. 1var TEMPLATE_HEADER = 'angular.module(\"&lt;%= module %&gt;\"&lt;%= standalone %&gt;).run([\"$templateCache\", function($templateCache) &#123;'; templateBody {string} [templateBody=see below] Override template body. 1var TEMPLATE_BODY = '$templateCache.put(\"&lt;%= url %&gt;\",\"&lt;%= contents %&gt;\");'; templateFooter {string} [templateFooter=see below] Override template footer. 1var TEMPLATE_FOOTER = '&#125;]);';","tags":[{"name":"gulp，","slug":"gulp，","permalink":"http://yoursite.com/tags/gulp，/"}]},{"title":"NodeJS基本模块","date":"2017-03-05T03:59:57.000Z","path":"2017/03/05/Framework/Node/基本模块/","text":"本文是根据廖雪峰的javascript教程精简而来，仅是为了方便自己学习 fs文件系统模块Node.js内置的fs模块就是文件系统模块，负责读写文件。和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。 异步读文件按照JavaScript的标准，异步读取一个文本文件的代码如下： 1234567891011'use strict';var fs = require('fs');fs.readFile('sample.txt', 'utf-8', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 请注意，sample.txt文件必须在当前目录下，且文件编码为utf-8。 异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。 由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是： 12345if (err) &#123; // 出错了&#125; else &#123; // 正常&#125; 如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？ 下面的例子演示了如何读取一个图片文件： 123456789101112'use strict';var fs = require('fs');fs.readFile('sample.png', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + ' bytes'); &#125;&#125;); 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String： 123// Buffer -&gt; Stringvar text = data.toString('utf-8');console.log(text); 或者把一个String转换成Buffer： 123// String -&gt; Buffervar buf = new Buffer(text, 'utf-8');console.log(buf); 同步读文件除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。 用fs模块同步读取一个文本文件的代码如下： 123456'use strict';var fs = require('fs');var data = fs.readFileSync('sample.txt', 'utf-8');console.log(data); 可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。 如果同步读取文件发生错误，则需要用try...catch捕获该错误： 123456try &#123; var data = fs.readFileSync('sample.txt', 'utf-8'); console.log(data);&#125; catch (err) &#123; // 出错了&#125; 写文件将数据写入文件是通过fs.writeFile()实现的： 123456789101112'use strict';var fs = require('fs');var data = 'Hello, Node.js';fs.writeFile('output.txt', data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('ok.'); &#125;&#125;); writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。 和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()： 123456'use strict';var fs = require('fs');var data = 'Hello, Node.js';fs.writeFileSync('output.txt', data); stat如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息： 12345678910111213141516171819202122'use strict';var fs = require('fs');fs.stat('sample.txt', function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log('isFile: ' + stat.isFile()); // 是否是目录: console.log('isDirectory: ' + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log('size: ' + stat.size); // 创建时间, Date对象: console.log('birth time: ' + stat.birthtime); // 修改时间, Date对象: console.log('modified time: ' + stat.mtime); &#125; &#125;&#125;); 运行结果如下： 12345isFile: trueisDirectory: falsesize: 181birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST) stat()也有一个对应的同步函数statSync()，请试着改写上述异步代码为同步代码。 异步还是同步在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？ 由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。 streamstream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。 如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。 在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例： 12345678910111213141516171819'use strict';var fs = require('fs');// 打开一个流:var rs = fs.createReadStream('sample.txt', 'utf-8');rs.on('data', function (chunk) &#123; console.log('DATA:') console.log(chunk);&#125;);rs.on('end', function () &#123; console.log('END');&#125;);rs.on('error', function (err) &#123; console.log('ERROR: ' + err);&#125;); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束： 12345678910111213'use strict';var fs = require('fs');var ws1 = fs.createWriteStream('output1.txt', 'utf-8');ws1.write('使用Stream写入文本数据...\\n');ws1.write('END.');ws1.end();var ws2 = fs.createWriteStream('output2.txt');ws2.write(new Buffer('使用Stream写入二进制数据...\\n', 'utf-8'));ws2.write(new Buffer('END.', 'utf-8'));ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 pipe就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序： 12345678&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var rs = fs.createReadStream(&apos;sample.txt&apos;);var ws = fs.createWriteStream(&apos;copied.txt&apos;);rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： 1readable.pipe(writable, &#123; end: false &#125;); httpNode.js开发的目的就是为了用JavaScript编写Web服务器程序。因为JavaScript实际上已经统治了浏览器端的脚本，其优势就是有世界上数量最多的前端开发人员。如果已经掌握了JavaScript前端开发，再学习一下如何将JavaScript应用在后端开发，就是名副其实的全栈了。 HTTP协议要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。如果你对HTTP协议不太熟悉，先看一看HTTP协议简介。 HTTP服务器要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!： 1234567891011121314151617181920'use strict';// 导入http模块:var http = require('http');// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + ': ' + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 将HTTP响应的HTML内容写入response: response.end('&lt;h1&gt;Hello world!&lt;/h1&gt;');&#125;);// 让服务器监听8080端口:server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); 在命令提示符下运行该程序，可以看到以下输出： 12$ node hello.js Server is running at http://127.0.0.1:8080/ 不要关闭命令提示符，直接打开浏览器输入http://localhost:8080，即可看到服务器响应的内容： 同时，在命令提示符窗口，可以看到程序打印的请求信息： 12GET: /GET: /favicon.ico 这就是我们编写的第一个HTTP服务器程序！ 文件服务器让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 12345'use strict';var url = require('url');console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash')); 结果如下： 12345678910111213Url &#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/path/to/file', path: '/path/to/file?query=string', href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' &#125; 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录： 12345678910'use strict';var path = require('path');// 解析当前目录:var workDir = path.resolve('.'); // '/Users/michael'// 组合完整的文件路径:当前目录+'pub'+'index.html':var filePath = path.join(workDir, 'pub', 'index.html');// '/Users/michael/pub/index.html' 使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\\Users\\michael\\static\\index.html，这样，我们就不关心怎么拼接路径了。 最后，我们实现一个文件服务器file_server.js： 1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';var fs = require('fs'), url = require('url'), path = require('path'), http = require('http');// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || '.');console.log('Static root dir: ' + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 '/css/bootstrap.css': var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css': var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log('200 ' + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log('404 ' + request.url); // 发送404响应: response.writeHead(404); response.end('404 Not Found'); &#125; &#125;);&#125;);server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); 没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。 在命令行运行node file_server.js /path/to/dir，把/path/to/dir改成你本地的一个有效的目录，然后在浏览器中输入http://localhost:8080/index.html： 只要当前目录下存在文件index.html，服务器就可以把文件内容发送给浏览器。观察控制台输出： 1234200 /index.html200 /css/uikit.min.css200 /js/jquery.min.js200 /fonts/fontawesome-webfont.woff2 第一个请求是浏览器请求index.html页面，后续请求是浏览器解析HTML后发送的其它资源请求。 练习在浏览器输入http://localhost:8080/时，会返回404，原因是程序识别出HTTP请求的不是文件，而是目录。请修改file_server.js，如果遇到请求的路径是目录，则自动在目录下依次搜索index.html、default.html，如果找到了，就返回HTML文件的内容。 cryptocrypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。 MD5和SHA1MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示： 123456789const crypto = require('crypto');const hash = crypto.createHash('md5');// 可任意多次调用update():hash.update('Hello, world!');hash.update('Hello, nodejs!');console.log(hash.digest('hex')); // 7e1977739c748beac0c0fd14fd26a544 update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把&#39;md5&#39;改成&#39;sha1&#39;，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。 还可以使用更安全的sha256和sha512。 HmacHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥： 12345678const crypto = require('crypto');const hmac = crypto.createHmac('sha256', 'secret-key');hmac.update('Hello, world!');hmac.update('Hello, nodejs!');console.log(hmac.digest('hex')); // 80f7e22570... 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。 AESAES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用： 123456789101112131415161718192021222324const crypto = require('crypto');function aesEncrypt(data, key) &#123; const cipher = crypto.createCipher('aes192', key); var crypted = cipher.update(data, 'utf8', 'hex'); crypted += cipher.final('hex'); return crypted;&#125;function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher('aes192', key); var decrypted = decipher.update(encrypted, 'hex', 'utf8'); decrypted += decipher.final('utf8'); return decrypted;&#125;var data = 'Hello, this is a secret message!';var key = 'Password!';var encrypted = aesEncrypt(data, key);var decrypted = aesDecrypt(encrypted, key);console.log('Plain text: ' + data);console.log('Encrypted text: ' + encrypted);console.log('Decrypted text: ' + decrypted); 运行结果如下： 123Plain text: Hello, this is a secret message!Encrypted text: 8a944d97bdabc157a5b7a40cb180e7...Decrypted text: Hello, this is a secret message! 可以看出，加密后的字符串通过解密又得到了原始内容。 注意到AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Nodejs全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，字符串密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。 Diffie-HellmanDH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做： 小明先选一个素数和一个底数，例如，素数p=23，底数g=5（底数可以任选），再选择一个秘密整数a=6，计算A=g^a mod p=8，然后大声告诉小红：p=23，g=5，A=8； 小红收到小明发来的p，g，A后，也选一个秘密整数b=15，然后计算B=g^b mod p=19，并大声告诉小明：B=19； 小明自己计算出s=B^a mod p=2，小红也自己计算出s=A^b mod p=2，因此，最终协商的密钥s为2。 在这个过程中，密钥2并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道p=23，g=5，A=8，B=19，由于不知道双方选的秘密整数a=6和b=15，因此无法计算出密钥2。 用crypto模块实现DH算法如下： 1234567891011121314151617181920212223const crypto = require('crypto');// xiaoming's keys:var ming = crypto.createDiffieHellman(512);var ming_keys = ming.generateKeys();var prime = ming.getPrime();var generator = ming.getGenerator();console.log('Prime: ' + prime.toString('hex'));console.log('Generator: ' + generator.toString('hex'));// xiaohong's keys:var hong = crypto.createDiffieHellman(prime, generator);var hong_keys = hong.generateKeys();// exchange and generate secret:var ming_secret = ming.computeSecret(hong_keys);var hong_secret = hong.computeSecret(ming_keys);// print secret:console.log('Secret of Xiao Ming: ' + ming_secret.toString('hex'));console.log('Secret of Xiao Hong: ' + hong_secret.toString('hex')); 运行后，可以得到如下输出： 12345$ node dh.js Prime: a8224c...deead3Generator: 02Secret of Xiao Ming: 695308...d519beSecret of Xiao Hong: 695308...d519be 注意每次输出都不一样，因为素数的选择是随机的。 证书crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。 参考源码crypto常用算法","tags":[{"name":"nodejs,node,javascript","slug":"nodejs-node-javascript","permalink":"http://yoursite.com/tags/nodejs-node-javascript/"}]},{"title":"前端学习资源","date":"2017-03-05T03:55:20.000Z","path":"2017/03/05/前端学习资源/","text":"转载自：https://cnodejs.org/topic/56ef3edd532839c33a99d00e 前端资源教程 发布于 1 年前 作者 i5ting资源教程原文 综合类 前端知识体系 前端知识结构 Web前端开发大系概览 Web前端开发大系概览-中文版 Web Front-end Stack v2.2 免费的编程中文书籍索引 前端书籍 前端免费书籍大全 前端知识体系 免费的编程中文书籍索引 智能社 - 精通JavaScript开发 重新介绍 JavaScript（JS 教程） 麻省理工学院公开课：计算机科学及编程导论 JavaScript中的this陷阱的最全收集–没有之一 JS函数式编程指南 JavaScript Promise迷你书（中文版） 腾讯移动Web前端知识库 Front-End-Develop-Guide 前端开发指南 前端开发笔记本 大前端工具集 - 聂微东 前端开发者手册 入门类 前端入门教程 瘳雪峰的Javascript教程 jQuery基础教程 前端工程师必备的PS技能——切图篇 结合个人经历总结的前端入门方法 效果类 弹出层 焦点图轮播特效 工具类 css sprite 雪碧图制作 版本控制入门 – 搬进 Github Grunt-beginner前端自动化工具 慕课专题 张鑫旭 - 慕课系列 lyn - 慕课系列 艾伦 - 慕课系列 碧仔 - Hello，移动WEB 周报类 平安科技移动开发二队技术周报 六. API:1. 总目录 开发中心 mozilla js参考 chrome开发中心（chrome的内核已转向blink） safari开发中心 microsoft js参考.aspx) js秘密花园 js秘密花园 w3help 综合Bug集合网站 综合搜索 javascripting 各种流行库搜索 综合API runoob.com-包含各种API集合 开源中国在线API文档合集 devdocs 英文综合API网站 2. jQuery jQuery API 中文文档 hemin 在线版 css88 jq api css88 jqui api 学习jquery jquery 源码查找 3. Ecmascript Understanding ECMAScript 6 - Nicholas C. Zakas exploring-es6 exploring-es6翻译 exploring-es6翻译后预览 阮一峰 es6 阮一峰 Javascript ECMA-262，第 5 版 es5 4. Js template template-chooser artTemplate tomdjs 淘宝模板juicer模板 Fxtpl v1.0 繁星前端模板引擎 laytpl mozilla - nunjucks Juicer dustjs etpl 5. 弹出层 artDialog 最新版 artDialog 文档 google code 下载地址 贤心弹出层 响应式用户交互组件库 sweetalert-有css3动画弹出层 6. CSS CSS 语法参考 CSS3动画手册 腾讯css3动画制作工具 志爷css小工具集合 css3 js 移动大杂烩 bouncejs 触摸库 css3 按钮动画 animate.css 全局CSS的终结(狗带) [译] 7. Angularjs Angular.js 的一些学习资源 angularjs中文社区 Angularjs源码学习 Angularjs源码学习 angular对bootstrap的封装 angularjs + nodejs 吕大豹 Angularjs AngularJS 最佳实践 Angular的一些扩展指令 Angular数据绑定原理 一些扩展Angular UI组件 Ember和AngularJS的性能测试 带你走近AngularJS - 基本功能介绍 Angularjs开发指南 Angularjs学习 不要带着jQuery的思维去学习AngularJS angularjs 学习笔记 angularjs 开发指南 angularjs 英文资料 angular bootstrap angular jq mobile angular ui 整合jQuery Mobile+AngularJS经验谈 有jQuery背景，该如何用AngularJS编程思想 AngularJS在线教程 angular学习笔记 8. React react.js 中文论坛 react.js 官方网址 react.js 官方文档 react.js material UI react.js TouchstoneJS UI react.js amazeui UI React 入门实例教程 - 阮一峰 React Native 中文版 Webpack 和 React 小书 - 前端乱炖 Webpack 和 React 小书 - gitbook webpack Webpack，101入门体验 webpack入门教程 基于webpack搭建前端工程解决方案探索 React原创实战视频教程 9. 移动端API API 99移动端知识集合 移动端前端开发知识库 移动前端的一些坑和解决方法（外观表现） 【原】移动web资源整理 zepto 1.0 中文手册 zepto 1.0 中文手册 zepto 1.1.2 zepto 中文注释 jqmobile 手册 移动浏览器开发集合 移动开发大杂烩 微信webview中的一些问题 框架 特色的HTML框架可以创建精美的iOS应用 淘宝SUI 10. avalon avalonjs Avalon新一代UI库： OniUI avalon.oniui-基于avalon的组件库 11. Requriejs Javascript模块化编程（一）：模块的写法 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 RequireJS入门（一） RequireJS入门（二） RequireJS进阶（三） requrie源码学习 requrie 入门指南 requrieJS 学习笔记 requriejs 其一 require backbone结合 12. Seajs seajs seajs 中文手册 13. Less,sass sass sass教程-sass中国 Sass 中文文档 less 14. Markdown Markdown 语法说明 (简体中文版) markdown入门参考 gitbook 国外的在线markdown可编辑成书 mdeditor 一款国内的在线markdown编辑器 stackedit 国外的在线markdown编辑器，功能强大，同步云盘 mditor 一款轻量级的markdown编辑器 lepture-editor markdown-editor 15. D3 d3 Tutorials Gallery lofter iteye ruanyifeng 16. 兼容性 esma 兼容列表 W3C CSS验证服务 caniuse csscreator microsoft.aspx) 在线测兼容-移动端 emulators 17. UI相关 bootcss MetroUICSS semantic Buttons kitecss pintuer amazeui worldhello linuxtoy gitmagic rogerdudler gitref book gogojimmy 18. HTTP HTTP API 设计指南 19. 其它API javascript流行库汇总 验证api underscore 中文手册 underscore源码分析 underscore源码分析-亚里士朱德的博客 underscrejs en api lodash - underscore的代替品 ext4api backbone 中文手册 qwrap手册 缓动函数 svg 中文参考 svg mdn参考 svg 导出 canvas svg 导出 png ai-to-svg localStorage 库 20. 图表类 Highcharts 中文API Highcharts 英文API ECharts 百度的图表软件 高德地图 开源的矢量图脚本框架 svg 地图 21. vue Vue Vue 论坛 Vue 入门指南 Vue 的一些资源索引 21. 正则 JS正则表达式元字符 正则表达式30分钟入门教程 MDN-正则表达式 ruanyifeng - RegExp对象 小胡子哥 - 进阶正则表达式 is.js 正则在线测试 22. ionic ionic 23. 其它 Mock.js 是一款模拟数据生成器 七. 开发规范 前端 通过分析github代码库总结出来的工程师代码书写习惯 HTML&amp;CSS编码规范 by @mdo 团队合作的css命名规范-腾讯AlloyTeam前端团队 前端编码规范之js - by yuwenhui 前端编码规范之js - by 李靖 前端开发规范手册 Airbnb JavaScript 编码规范（简体中文版） AMD与CMD规范的区别 AMD与CMD规范的区别 KISSY 源码规范 bt编码规范 规范加强版 前端代码规范 及 最佳实践 百度前端规范 百度前端规范 百度前端规范 ECMAScript6 编码规范–广发证券前端团队 JavaScript 风格指南/编码规范（Airbnb公司版） 网易前端开发规范 css模块 前端规范资源列表 PHP 最流行的PHP 代码规范 最流行的PHP 代码规范 Android 【敏捷开发】Android团队开发规范 Android 开发规范与应用 八. 其它收集1. 各大公司开源项目 Facebook Projects 百度web前端研发部 百度EFE 百度github alloyteam alloyteam-github alloyteam-AlloyGameEngine AlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具 H5交互页编辑器AEditor介绍 H5动画交互页开发的工具介绍 AEditor H5动画交互页开发的工具 maka 值得订阅的weekly 腾讯html5 奇舞团开源项目 Qunar UED 2. Javascript 常用 ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性 模拟键盘 拼音 中国个人身份证号验证 算法 数据结构与算法 JavaScript 描述. 章节练习 常见排序算法（JS版） 经典排序 常见排序算法-js版本 JavaScript 算法与数据结构 精华集 面试常考算法题精讲 移动端 fastclick no-click-delay JSON 模拟生成JSON数据 返回跨域JSONAPI 3. Html5 HTML5 有哪些让你惊艳的 demo？ 4. CSS browserhacks 5. jQuery 焦点图 myfocus myfocus-官方演示站 SuperSlidev2.1 – 大话主席 soChange 6. Ext, EasyUI, J-UI 及其它各种UI方案 Ext extjs ext4英文api ext4中文api EasyUI jquery easyui 未压缩源代码 J-UI J-UI Other MUI-最接近原生APP体验的高性能前端框架 Amaze UI | 中国首个开源 HTML5 跨屏前端框架 淘宝 HTML5 前端框架 KISSY - 阿里前端JavaScript库 网易Nej - Nice Easy Javascript Kendo UI MVVM Demo Bootstrap Smart UI 雅虎UI - CSS UI 7. 页面 社会化 分享功能 百度分享 pc端 JiaThis pc端 社会化分享组件 移动端 ShareSDK 轻松实现社会化功能 移动端 友盟分享 移动端 8. 富文本编辑器 百度 ueditor 经典的ckeditor 经典的kindeditor wysiwyg 一个有情怀的编辑器。Bach’s Editor tower用的编辑器 summernote 编辑器 html5编辑器 XEditor wangEditor 9. 日历 PC 经典my97 强大的独立日期选择器 fullcalendar fullcalendar日历控件知识点集合 中文api 农历日历 超酷的仿百度带节日日历老黄历控件 日期格式化 大牛日历控件 我群某管理作品 input按位替换-官网 input按位替换-github bootstrap-daterangepicker 国外30个插件集合 JavaScript datepicker Datepair.js 一个风格多样的日历 弹出层式的全日历 jquery双日历 移动 大气实用jQuery手机移动端日历日期选择插件 jQuery Mobile 移动开发中的日期插件Mobiscroll Date library Datejs sugarjs 10. 综合效果搜索平台 效果网 17素材 常用的JavaScript代码片段 11. 前端工程化 概述 前端工具大全 什么是前端工程化 Gulp Gulp官网 Gulp中文网 gulp资料收集 Gulp：任务自动管理工具 - ruanyifeng Gulp插件 Gulp不完全入门教程 为什么使用gulp? Gulp安装及配合组件构建前端开发一体化 Gulp 入门指南 Gulp 入门指南 - nimojs Gulp入门教程 Gulp in Action Gulp开发教程（翻译） 前端构建工具gulpjs的使用介绍及技巧 Grunt gruntjs Grunt中文网 Fis fis 官网 fis 12. 轮播图 pc图轮 单屏轮播sochange 左右按钮多图切换 fullpage全屏轮播 移动端 无缝切换 滑屏效果 全屏fullpage 单个图片切换 单个全屏切换 百度的切换库 单个全屏切换 滑屏效果 旋转拖动设置 类似于swipe切换 支持多种形式的触摸滑动 滑屏效果 大话主席pc移动图片轮换 滑屏效果 基于zepto的fullpage [WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应 判断微信客户端的那些坑 可以通过javascript直接调用原生分享的工具 JiaThis 分享到微信代码 聊聊移动端跨平台开发的各种技术 前端自动化测试 多种轮换图片 滑动侧边栏 13. 文件上传 百度上传组件 上传 flash 头像上传 图片上传预览 图片裁剪 图片裁剪-shearphoto jQuery图片处理 14. 模拟select 糖饼 select flexselect 双select select2 15. 取色插件 类似 Photoshop 的界面取色插件 jquery color 取色插件集合 farbtastic 圆环＋正方形 16. 城市联动 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 17. 剪贴板 剪贴板 clipboard 最新的剪切方案 不是Flash的剪贴板 18. 简繁转换 简繁转换 19. 表格 Grid facebook表格 类似于Excel编辑表格-handsontable bootstrap-table插件 datatables 20. 在线演示 js 在线编辑 - runjs js 在线编辑 - jsbin js 在线编辑 - codepen js 在线编辑 - jsfiddle java 在线编辑 - runjs js 在线编辑 - hcharts js 在线编辑 - jsdm sql 在线编辑 - sqlfiddle mozilla 在线编辑器 21. 播放器 Html5 VideoPlayer 22. 粒子动画 Proton 烟花 九. Nodejs nodejs 篇幅比较巨大 Node.js 包教不包会 篇幅比较少 node express 入门教程 nodejs定时任务 一个nodejs博客 【NodeJS 学习笔记04】新闻发布系统 过年7天乐，学nodejs 也快乐 七天学会NodeJS Nodejs学习笔记（二）— 事件模块 nodejs入门 angularjs nodejs 从零开始nodejs系列文章 理解nodejs nodejs事件轮询 node入门 nodejs cms Node初学者入门，一本全面的NodeJS教程 NodeJS的代码调试和性能调优 十. 性能优化 常规优化 Javascript高性能动画与页面渲染 移动H5前端性能优化指南 5173首页前端性能优化实践 给网页设计师和前端开发者看的前端性能优化 复杂应用的 CSS 性能分析和优化建议 张鑫旭——前端性能 前端性能监控总结 网站性能优化之CSS无图片技术 web前端性能优化进阶路 前端技术：网站性能优化之CSS无图片技术 浏览器的加载与页面性能优化 页面加载中的图片性能优化 Hey——前端性能 html优化 99css——性能 Yslow——性能优化 YSLOW中文介绍 转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化 Yahoo!团队实践分享：网站性能 网站性能优化指南：什么使我们的网站变慢？ 网站性能优化实践，减少加载时间，提高用户体验 浅谈网站性能优化 前端篇 前端重构实践之如何对网站性能优化？ 前端性能优化：使用媒体查询加载指定大小的背景图片 网站性能系列博文 加载，不只是少一点点 前端性能的测试与优化 分享网页加载速度优化的一些技巧？ 页面加载中的图片性能优化 web前端优化(基于Yslow) 网站性能优化工具大全 【高性能前端1】高性能HTML 【高性能前端2】高性能CSS 由12306谈谈网站前端性能和后端性能优化 AlloyTeam——前端优化 毫秒必争，前端网页性能最佳实践 网站性能工具Yslow的使用方法 前端工程与性能优化（上）：静态资源版本更新与缓存 前端工程与性能优化（下）：静态资源管理与模板框架 HTTPS连接的前几毫秒发生了什么 Yslow Essential Web Performance Metrics — A Primer, Part 1 Essential Web Performance Metrics — Part 2 YUISlide,针对移动设备的动画性能优化 Improving Site Performance 让网站提速的最佳前端实践 Why Website Speed is Important Need for Speed – How to Improve your Website Performance 阿里无线前端性能优化指南 (Pt.1 加载期优化) 优化工具 JavaScript 性能分析新工具 OneProfile JavaScript 堆内存分析新工具 OneHeap 在线工具 google在线工具 阿里测 阿里-免费测试服务 阿里-F2etest多浏览器兼容性测试解决方案 js性能测试 十一. 前端架构 技术架构 前端架构 如何成为前端架构师 关于前端架构-张克军 百度腾讯offer比较（腾讯游戏VS百度基础架构） 十二. 个人作品1. 推荐作品 winter代码片段需要翻墙 fgm 岑安作品集 当耐特demo集合 米空格 js作品 myFocus SeaJS组件库 颜海镜作品 脚儿网作品 javascript个人作品 妙味的雷东升游戏作品 javascript作品集 云五笔，灰度产生生成工具 项目主页 个性的作品主页 播放器 ucren js demos 集 智能社 实例陈列架 zoye demo 王员外 平凡 jyg 游戏案例 很多jquery插件 不羁虫 - soJs 作品系列 frozenui 黑白棋 fromone 2. 群员作品 MDialog - [合肥-M.J] 轮播图 - [上海－冷静] [广州—坚壳] [成都 - 无痕] 感恩节专题 [球霸天] [北京-小数] [ptf] Magix 工具 [杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用 [上海-剧中人]-实验室 [上海-豪情 ] 作品集合 [成都-feeling] [上海-angela] [海南-hank]作品 [上海-张力]博客 [上海-zenki]作品 移动端图案解锁 [合肥-M.J] - MPreview 移动端图片预览组 [合肥-M.J] - Mexam 移动端在线做题组 [北京-苏瑞] - dancer小人 [上海-玄沐]- 个人网站 [厦门-二哲]- 个人博客 3. 国外大牛精品 pazguille 十三. 简历模板 不错的个人简历 简历 张伦 简历 翁天信 动画方式的简历 组件丰富简历 简历池 haorooms博客 Justin Young 十四. 面试题 那几个月在找工作（百度，网易游戏） 2014最新面试题 阿里前端面试题 2016校招内推 – 阿里巴巴前端 – 三面面试经历 腾讯面试题 年后跳槽那点事：乐视+金山+360面试之行 阿里前端面试题上线 拉勾网js面试题 前端面试 Web开发笔试面试题 大全 前端开发面试题 2014最新前端面试题 百度面试 面试题 前端工作面试问题 前端开发面试题 5个经典的前端面试问题 最全前端面试问题及答案总结 如何面试一名前端开发工程师？ 史上最全 前端开发面试问题及答案整理 前端实习生面试总结 史上最全 前端开发面试问题及答案整理 BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 前端开发面试题大收集 收集的前端面试题和答案 如何面试前端工程师 前端开发面试题 牛客网-笔试面经 十五. iconfont 中文字体 淘宝字库 字体 制作教程 zhangxinxu-icommon icommon 用字体在网页中画ICON图标(推荐教程) 字体压缩工具 感谢初级群 [深圳-小鱼] 的推荐 十六. 开发工具类 前端开发工具 IntelliJ IDEA 简体中文专题教程 Webstorm,InterllIdea,Phpstorm SublimeText Atom visual studio code Chrome, Firebug, Filddle 调试 Fiddler Fiddler调式使用知多少(一)深入研究 微信fiddle 微信fiddle Chrome Google Chrome 官方 Chrome - 基础 Chrome - 进阶 Chrome - 性能 Chrome - 性能进阶 Chrome - 移动 Chrome - 使用技巧 Chrome - Console控制台不完全指南 Chrome - Workspace使浏览器变成IDE network面板 chrome开发工具快捷键 chrome调试工具常用功能整理 Chrome 开发工具 Workspace 使用 Chrome神器Vimium快捷键学习记录 sass调试-w3cplus 如何更专业的使用Chrome开发者工具-w3cplus chrome调试canvas chrome profiles1 chrome profiles2 chrome profiles3 chrome移动版调试 chrome调试 chrome的调试 chrome console 命令详解 查看事件绑定1 查看事件绑定2 神器——Chrome开发者工具(一) 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍) chrome 开发者工具的 15 个小技巧 Chrome开发者工具不完全指南 Chrome 开发者工具使用技巧 Firebug firebug视频教程 firefox 模拟器 console.log 命令详解 Firebug入门指南 Firebug控制台详解 移动,微信调试 浏览器端调试安卓 移动端前端开发调试 使用 Chrome 远程调试 Android 设备 mac移动端调试 mac移动端调试 无线调试攻略 无线调试攻略 屌爆了,完美调试 微信webview(x5) 微信调试的那些事 远程console 微信调试工具 各种真机远程调试方法汇总 iOS Simulator Simulator Xcode中的iOS模拟器(iOS Simulator)的介绍和使用心得 img loading img 智图-图片优化平台 在线png优化 生成二维码 生成二维码 浏览器同步 puer liveReload f5 File Watchers 在线PPT制作 nodePPT PPT reveal slippy 十七. 前端导航网站 界面清爽的前端导航 前端导航 前端网址导航 前端名录 前端导航 前端开发资源 网址导航 前端开发仓库 - 众多效果的收集地 前端资源导航 F2E 前端导航 十八. 常用CDN 新浪CDN 百度静态资源公共库 360网站卫士常用前端公共库CDN服务 Bootstrap中文网开源项目免费 CDN 服务 开放静态文件 CDN - 七牛 CDN加速 - jq22 jQuery CDN Google jQuery CDN 微软CDN 十九. Git,SVN,Github Git git-scm 廖雪峰-Git教程 git-for-windows GitHub 添加 SSH keys gogithub git常规命令练习 git的资料整理 我所记录的git命令（非常实用） 企业开发git工作流模式探索部分休整 GitHub 漫游指南 GitHub秘籍 使用git和github进行协同开发流程 动画方式练习git前端资源教程 发布于 1 年前 作者 i5ting 95350 次浏览 最后一次编辑是 1 个月前 来自 分享 资源教程原文 综合类 前端知识体系 前端知识结构 Web前端开发大系概览 Web前端开发大系概览-中文版 Web Front-end Stack v2.2 免费的编程中文书籍索引 前端书籍 前端免费书籍大全 前端知识体系 免费的编程中文书籍索引 智能社 - 精通JavaScript开发 重新介绍 JavaScript（JS 教程） 麻省理工学院公开课：计算机科学及编程导论 JavaScript中的this陷阱的最全收集–没有之一 JS函数式编程指南 JavaScript Promise迷你书（中文版） 腾讯移动Web前端知识库 Front-End-Develop-Guide 前端开发指南 前端开发笔记本 大前端工具集 - 聂微东 前端开发者手册 入门类 前端入门教程 瘳雪峰的Javascript教程 jQuery基础教程 前端工程师必备的PS技能——切图篇 结合个人经历总结的前端入门方法 效果类 弹出层 焦点图轮播特效 工具类 css sprite 雪碧图制作 版本控制入门 – 搬进 Github Grunt-beginner前端自动化工具 慕课专题 张鑫旭 - 慕课系列 lyn - 慕课系列 艾伦 - 慕课系列 碧仔 - Hello，移动WEB 周报类 平安科技移动开发二队技术周报 六. API:1. 总目录 开发中心 mozilla js参考 chrome开发中心（chrome的内核已转向blink） safari开发中心 microsoft js参考.aspx) js秘密花园 js秘密花园 w3help 综合Bug集合网站 综合搜索 javascripting 各种流行库搜索 综合API runoob.com-包含各种API集合 开源中国在线API文档合集 devdocs 英文综合API网站 2. jQuery jQuery API 中文文档 hemin 在线版 css88 jq api css88 jqui api 学习jquery jquery 源码查找 3. Ecmascript Understanding ECMAScript 6 - Nicholas C. Zakas exploring-es6 exploring-es6翻译 exploring-es6翻译后预览 阮一峰 es6 阮一峰 Javascript ECMA-262，第 5 版 es5 4. Js template template-chooser artTemplate tomdjs 淘宝模板juicer模板 Fxtpl v1.0 繁星前端模板引擎 laytpl mozilla - nunjucks Juicer dustjs etpl 5. 弹出层 artDialog 最新版 artDialog 文档 google code 下载地址 贤心弹出层 响应式用户交互组件库 sweetalert-有css3动画弹出层 6. CSS CSS 语法参考 CSS3动画手册 腾讯css3动画制作工具 志爷css小工具集合 css3 js 移动大杂烩 bouncejs 触摸库 css3 按钮动画 animate.css 全局CSS的终结(狗带) [译] 7. Angularjs Angular.js 的一些学习资源 angularjs中文社区 Angularjs源码学习 Angularjs源码学习 angular对bootstrap的封装 angularjs + nodejs 吕大豹 Angularjs AngularJS 最佳实践 Angular的一些扩展指令 Angular数据绑定原理 一些扩展Angular UI组件 Ember和AngularJS的性能测试 带你走近AngularJS - 基本功能介绍 Angularjs开发指南 Angularjs学习 不要带着jQuery的思维去学习AngularJS angularjs 学习笔记 angularjs 开发指南 angularjs 英文资料 angular bootstrap angular jq mobile angular ui 整合jQuery Mobile+AngularJS经验谈 有jQuery背景，该如何用AngularJS编程思想 AngularJS在线教程 angular学习笔记 8. React react.js 中文论坛 react.js 官方网址 react.js 官方文档 react.js material UI react.js TouchstoneJS UI react.js amazeui UI React 入门实例教程 - 阮一峰 React Native 中文版 Webpack 和 React 小书 - 前端乱炖 Webpack 和 React 小书 - gitbook webpack Webpack，101入门体验 webpack入门教程 基于webpack搭建前端工程解决方案探索 React原创实战视频教程 9. 移动端API API 99移动端知识集合 移动端前端开发知识库 移动前端的一些坑和解决方法（外观表现） 【原】移动web资源整理 zepto 1.0 中文手册 zepto 1.0 中文手册 zepto 1.1.2 zepto 中文注释 jqmobile 手册 移动浏览器开发集合 移动开发大杂烩 微信webview中的一些问题 框架 特色的HTML框架可以创建精美的iOS应用 淘宝SUI 10. avalon avalonjs Avalon新一代UI库： OniUI avalon.oniui-基于avalon的组件库 11. Requriejs Javascript模块化编程（一）：模块的写法 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 RequireJS入门（一） RequireJS入门（二） RequireJS进阶（三） requrie源码学习 requrie 入门指南 requrieJS 学习笔记 requriejs 其一 require backbone结合 12. Seajs seajs seajs 中文手册 13. Less,sass sass sass教程-sass中国 Sass 中文文档 less 14. Markdown Markdown 语法说明 (简体中文版) markdown入门参考 gitbook 国外的在线markdown可编辑成书 mdeditor 一款国内的在线markdown编辑器 stackedit 国外的在线markdown编辑器，功能强大，同步云盘 mditor 一款轻量级的markdown编辑器 lepture-editor markdown-editor 15. D3 d3 Tutorials Gallery lofter iteye ruanyifeng 16. 兼容性 esma 兼容列表 W3C CSS验证服务 caniuse csscreator microsoft.aspx) 在线测兼容-移动端 emulators 17. UI相关 bootcss MetroUICSS semantic Buttons kitecss pintuer amazeui worldhello linuxtoy gitmagic rogerdudler gitref book gogojimmy 18. HTTP HTTP API 设计指南 19. 其它API javascript流行库汇总 验证api underscore 中文手册 underscore源码分析 underscore源码分析-亚里士朱德的博客 underscrejs en api lodash - underscore的代替品 ext4api backbone 中文手册 qwrap手册 缓动函数 svg 中文参考 svg mdn参考 svg 导出 canvas svg 导出 png ai-to-svg localStorage 库 20. 图表类 Highcharts 中文API Highcharts 英文API ECharts 百度的图表软件 高德地图 开源的矢量图脚本框架 svg 地图 21. vue Vue Vue 论坛 Vue 入门指南 Vue 的一些资源索引 21. 正则 JS正则表达式元字符 正则表达式30分钟入门教程 MDN-正则表达式 ruanyifeng - RegExp对象 小胡子哥 - 进阶正则表达式 is.js 正则在线测试 22. ionic ionic 23. 其它 Mock.js 是一款模拟数据生成器 七. 开发规范 前端 通过分析github代码库总结出来的工程师代码书写习惯 HTML&amp;CSS编码规范 by @mdo 团队合作的css命名规范-腾讯AlloyTeam前端团队 前端编码规范之js - by yuwenhui 前端编码规范之js - by 李靖 前端开发规范手册 Airbnb JavaScript 编码规范（简体中文版） AMD与CMD规范的区别 AMD与CMD规范的区别 KISSY 源码规范 bt编码规范 规范加强版 前端代码规范 及 最佳实践 百度前端规范 百度前端规范 百度前端规范 ECMAScript6 编码规范–广发证券前端团队 JavaScript 风格指南/编码规范（Airbnb公司版） 网易前端开发规范 css模块 前端规范资源列表 PHP 最流行的PHP 代码规范 最流行的PHP 代码规范 Android 【敏捷开发】Android团队开发规范 Android 开发规范与应用 八. 其它收集1. 各大公司开源项目 Facebook Projects 百度web前端研发部 百度EFE 百度github alloyteam alloyteam-github alloyteam-AlloyGameEngine AlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具 H5交互页编辑器AEditor介绍 H5动画交互页开发的工具介绍 AEditor H5动画交互页开发的工具 maka 值得订阅的weekly 腾讯html5 奇舞团开源项目 Qunar UED 2. Javascript 常用 ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性 模拟键盘 拼音 中国个人身份证号验证 算法 数据结构与算法 JavaScript 描述. 章节练习 常见排序算法（JS版） 经典排序 常见排序算法-js版本 JavaScript 算法与数据结构 精华集 面试常考算法题精讲 移动端 fastclick no-click-delay JSON 模拟生成JSON数据 返回跨域JSONAPI 3. Html5 HTML5 有哪些让你惊艳的 demo？ 4. CSS browserhacks 5. jQuery 焦点图 myfocus myfocus-官方演示站 SuperSlidev2.1 – 大话主席 soChange 6. Ext, EasyUI, J-UI 及其它各种UI方案 Ext extjs ext4英文api ext4中文api EasyUI jquery easyui 未压缩源代码 J-UI J-UI Other MUI-最接近原生APP体验的高性能前端框架 Amaze UI | 中国首个开源 HTML5 跨屏前端框架 淘宝 HTML5 前端框架 KISSY - 阿里前端JavaScript库 网易Nej - Nice Easy Javascript Kendo UI MVVM Demo Bootstrap Smart UI 雅虎UI - CSS UI 7. 页面 社会化 分享功能 百度分享 pc端 JiaThis pc端 社会化分享组件 移动端 ShareSDK 轻松实现社会化功能 移动端 友盟分享 移动端 8. 富文本编辑器 百度 ueditor 经典的ckeditor 经典的kindeditor wysiwyg 一个有情怀的编辑器。Bach’s Editor tower用的编辑器 summernote 编辑器 html5编辑器 XEditor wangEditor 9. 日历 PC 经典my97 强大的独立日期选择器 fullcalendar fullcalendar日历控件知识点集合 中文api 农历日历 超酷的仿百度带节日日历老黄历控件 日期格式化 大牛日历控件 我群某管理作品 input按位替换-官网 input按位替换-github bootstrap-daterangepicker 国外30个插件集合 JavaScript datepicker Datepair.js 一个风格多样的日历 弹出层式的全日历 jquery双日历 移动 大气实用jQuery手机移动端日历日期选择插件 jQuery Mobile 移动开发中的日期插件Mobiscroll Date library Datejs sugarjs 10. 综合效果搜索平台 效果网 17素材 常用的JavaScript代码片段 11. 前端工程化 概述 前端工具大全 什么是前端工程化 Gulp Gulp官网 Gulp中文网 gulp资料收集 Gulp：任务自动管理工具 - ruanyifeng Gulp插件 Gulp不完全入门教程 为什么使用gulp? Gulp安装及配合组件构建前端开发一体化 Gulp 入门指南 Gulp 入门指南 - nimojs Gulp入门教程 Gulp in Action Gulp开发教程（翻译） 前端构建工具gulpjs的使用介绍及技巧 Grunt gruntjs Grunt中文网 Fis fis 官网 fis 12. 轮播图 pc图轮 单屏轮播sochange 左右按钮多图切换 fullpage全屏轮播 移动端 无缝切换 滑屏效果 全屏fullpage 单个图片切换 单个全屏切换 百度的切换库 单个全屏切换 滑屏效果 旋转拖动设置 类似于swipe切换 支持多种形式的触摸滑动 滑屏效果 大话主席pc移动图片轮换 滑屏效果 基于zepto的fullpage [WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应 判断微信客户端的那些坑 可以通过javascript直接调用原生分享的工具 JiaThis 分享到微信代码 聊聊移动端跨平台开发的各种技术 前端自动化测试 多种轮换图片 滑动侧边栏 13. 文件上传 百度上传组件 上传 flash 头像上传 图片上传预览 图片裁剪 图片裁剪-shearphoto jQuery图片处理 14. 模拟select 糖饼 select flexselect 双select select2 15. 取色插件 类似 Photoshop 的界面取色插件 jquery color 取色插件集合 farbtastic 圆环＋正方形 16. 城市联动 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 17. 剪贴板 剪贴板 clipboard 最新的剪切方案 不是Flash的剪贴板 18. 简繁转换 简繁转换 19. 表格 Grid facebook表格 类似于Excel编辑表格-handsontable bootstrap-table插件 datatables 20. 在线演示 js 在线编辑 - runjs js 在线编辑 - jsbin js 在线编辑 - codepen js 在线编辑 - jsfiddle java 在线编辑 - runjs js 在线编辑 - hcharts js 在线编辑 - jsdm sql 在线编辑 - sqlfiddle mozilla 在线编辑器 21. 播放器 Html5 VideoPlayer 22. 粒子动画 Proton 烟花 九. Nodejs nodejs 篇幅比较巨大 Node.js 包教不包会 篇幅比较少 node express 入门教程 nodejs定时任务 一个nodejs博客 【NodeJS 学习笔记04】新闻发布系统 过年7天乐，学nodejs 也快乐 七天学会NodeJS Nodejs学习笔记（二）— 事件模块 nodejs入门 angularjs nodejs 从零开始nodejs系列文章 理解nodejs nodejs事件轮询 node入门 nodejs cms Node初学者入门，一本全面的NodeJS教程 NodeJS的代码调试和性能调优 十. 性能优化 常规优化 Javascript高性能动画与页面渲染 移动H5前端性能优化指南 5173首页前端性能优化实践 给网页设计师和前端开发者看的前端性能优化 复杂应用的 CSS 性能分析和优化建议 张鑫旭——前端性能 前端性能监控总结 网站性能优化之CSS无图片技术 web前端性能优化进阶路 前端技术：网站性能优化之CSS无图片技术 浏览器的加载与页面性能优化 页面加载中的图片性能优化 Hey——前端性能 html优化 99css——性能 Yslow——性能优化 YSLOW中文介绍 转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化 Yahoo!团队实践分享：网站性能 网站性能优化指南：什么使我们的网站变慢？ 网站性能优化实践，减少加载时间，提高用户体验 浅谈网站性能优化 前端篇 前端重构实践之如何对网站性能优化？ 前端性能优化：使用媒体查询加载指定大小的背景图片 网站性能系列博文 加载，不只是少一点点 前端性能的测试与优化 分享网页加载速度优化的一些技巧？ 页面加载中的图片性能优化 web前端优化(基于Yslow) 网站性能优化工具大全 【高性能前端1】高性能HTML 【高性能前端2】高性能CSS 由12306谈谈网站前端性能和后端性能优化 AlloyTeam——前端优化 毫秒必争，前端网页性能最佳实践 网站性能工具Yslow的使用方法 前端工程与性能优化（上）：静态资源版本更新与缓存 前端工程与性能优化（下）：静态资源管理与模板框架 HTTPS连接的前几毫秒发生了什么 Yslow Essential Web Performance Metrics — A Primer, Part 1 Essential Web Performance Metrics — Part 2 YUISlide,针对移动设备的动画性能优化 Improving Site Performance 让网站提速的最佳前端实践 Why Website Speed is Important Need for Speed – How to Improve your Website Performance 阿里无线前端性能优化指南 (Pt.1 加载期优化) 优化工具 JavaScript 性能分析新工具 OneProfile JavaScript 堆内存分析新工具 OneHeap 在线工具 google在线工具 阿里测 阿里-免费测试服务 阿里-F2etest多浏览器兼容性测试解决方案 js性能测试 十一. 前端架构 技术架构 前端架构 如何成为前端架构师 关于前端架构-张克军 百度腾讯offer比较（腾讯游戏VS百度基础架构） 十二. 个人作品1. 推荐作品 winter代码片段需要翻墙 fgm 岑安作品集 当耐特demo集合 米空格 js作品 myFocus SeaJS组件库 颜海镜作品 脚儿网作品 javascript个人作品 妙味的雷东升游戏作品 javascript作品集 云五笔，灰度产生生成工具 项目主页 个性的作品主页 播放器 ucren js demos 集 智能社 实例陈列架 zoye demo 王员外 平凡 jyg 游戏案例 很多jquery插件 不羁虫 - soJs 作品系列 frozenui 黑白棋 fromone 2. 群员作品 MDialog - [合肥-M.J] 轮播图 - [上海－冷静] [广州—坚壳] [成都 - 无痕] 感恩节专题 [球霸天] [北京-小数] [ptf] Magix 工具 [杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用 [上海-剧中人]-实验室 [上海-豪情 ] 作品集合 [成都-feeling] [上海-angela] [海南-hank]作品 [上海-张力]博客 [上海-zenki]作品 移动端图案解锁 [合肥-M.J] - MPreview 移动端图片预览组 [合肥-M.J] - Mexam 移动端在线做题组 [北京-苏瑞] - dancer小人 [上海-玄沐]- 个人网站 [厦门-二哲]- 个人博客 3. 国外大牛精品 pazguille 十三. 简历模板 不错的个人简历 简历 张伦 简历 翁天信 动画方式的简历 组件丰富简历 简历池 haorooms博客 Justin Young 十四. 面试题 那几个月在找工作（百度，网易游戏） 2014最新面试题 阿里前端面试题 2016校招内推 – 阿里巴巴前端 – 三面面试经历 腾讯面试题 年后跳槽那点事：乐视+金山+360面试之行 阿里前端面试题上线 拉勾网js面试题 前端面试 Web开发笔试面试题 大全 前端开发面试题 2014最新前端面试题 百度面试 面试题 前端工作面试问题 前端开发面试题 5个经典的前端面试问题 最全前端面试问题及答案总结 如何面试一名前端开发工程师？ 史上最全 前端开发面试问题及答案整理 前端实习生面试总结 史上最全 前端开发面试问题及答案整理 BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 前端开发面试题大收集 收集的前端面试题和答案 如何面试前端工程师 前端开发面试题 牛客网-笔试面经 十五. iconfont 中文字体 淘宝字库 字体 制作教程 zhangxinxu-icommon icommon 用字体在网页中画ICON图标(推荐教程) 字体压缩工具 感谢初级群 [深圳-小鱼] 的推荐 十六. 开发工具类 前端开发工具 IntelliJ IDEA 简体中文专题教程 Webstorm,InterllIdea,Phpstorm SublimeText Atom visual studio code Chrome, Firebug, Filddle 调试 Fiddler Fiddler调式使用知多少(一)深入研究 微信fiddle 微信fiddle Chrome Google Chrome 官方 Chrome - 基础 Chrome - 进阶 Chrome - 性能 Chrome - 性能进阶 Chrome - 移动 Chrome - 使用技巧 Chrome - Console控制台不完全指南 Chrome - Workspace使浏览器变成IDE network面板 chrome开发工具快捷键 chrome调试工具常用功能整理 Chrome 开发工具 Workspace 使用 Chrome神器Vimium快捷键学习记录 sass调试-w3cplus 如何更专业的使用Chrome开发者工具-w3cplus chrome调试canvas chrome profiles1 chrome profiles2 chrome profiles3 chrome移动版调试 chrome调试 chrome的调试 chrome console 命令详解 查看事件绑定1 查看事件绑定2 神器——Chrome开发者工具(一) 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍) chrome 开发者工具的 15 个小技巧 Chrome开发者工具不完全指南 Chrome 开发者工具使用技巧 Firebug firebug视频教程 firefox 模拟器 console.log 命令详解 Firebug入门指南 Firebug控制台详解 移动,微信调试 浏览器端调试安卓 移动端前端开发调试 使用 Chrome 远程调试 Android 设备 mac移动端调试 mac移动端调试 无线调试攻略 无线调试攻略 屌爆了,完美调试 微信webview(x5) 微信调试的那些事 远程console 微信调试工具 各种真机远程调试方法汇总 iOS Simulator Simulator Xcode中的iOS模拟器(iOS Simulator)的介绍和使用心得 img loading img 智图-图片优化平台 在线png优化 生成二维码 生成二维码 浏览器同步 puer liveReload f5 File Watchers 在线PPT制作 nodePPT PPT reveal slippy 十七. 前端导航网站 界面清爽的前端导航 前端导航 前端网址导航 前端名录 前端导航 前端开发资源 网址导航 前端开发仓库 - 众多效果的收集地 前端资源导航 F2E 前端导航 十八. 常用CDN 新浪CDN 百度静态资源公共库 360网站卫士常用前端公共库CDN服务 Bootstrap中文网开源项目免费 CDN 服务 开放静态文件 CDN - 七牛 CDN加速 - jq22 jQuery CDN Google jQuery CDN 微软CDN 十九. Git,SVN,Github Git git-scm 廖雪峰-Git教程 git-for-windows GitHub 添加 SSH keys gogithub git常规命令练习 git的资料整理 我所记录的git命令（非常实用） 企业开发git工作流模式探索部分休整 GitHub 漫游指南 GitHub秘籍 使用git和github进行协同开发流程 动画方式练习git","tags":[{"name":"前端,资源","slug":"前端-资源","permalink":"http://yoursite.com/tags/前端-资源/"}]},{"title":"Gulp构建工具的使用","date":"2017-03-04T13:50:52.000Z","path":"2017/03/04/Framework/Gulp/Gulp构建工具的使用/","text":"Automate and enhance your workflowgulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something. 简介本文主要是根据gulp中文网文档和gulp教程之gulp中文API的内容综合而成，方便自己理解与学习gulp自动化工具的基本使用 工具介绍 Gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。 常见处理任包括以下几方面： 模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。 使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件； 对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能； 以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack 等。 Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，其以简洁的配置和卓越的性能成为目前主流的构建工具。 相关链接 官方：http://gulpjs.com/中文官网：http://www.gulpjs.com.cn/npm：https://www.npmjs.com/package/gulpGithub：https://github.com/gulpjs/gulpGitbook：https://wizardforcel.gitbooks.io/gulp-doc/content/2.html 安装 首先要全局安装gulp-cli工具 1npm install --global gulp-cli 安装全局gulp 1npm install --global gulp 作为项目的开发依赖（devDependencies）安装 1npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 1234var gulp = require(&apos;gulp&apos;); // 引入gulp这个第三方包gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp 123gulp# 默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。# 想要单独执行特定的任务（task），请输入 gulp &lt;task&gt; &lt;othertask&gt;。 API文档 官方文档：https://github.com/gulpjs/gulp/blob/master/docs/API.md中文文档：http://www.gulpjs.com.cn/docs/gulp教程之gulp中文API：http://www.ydcss.com/archives/424 gulp.src(globs[,options])指定需要处理的源文件的路径，gulp借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，gulp.src返回当前文件流至可用插件；12345// 通过gulp.src()读取文件，经过pipe管道流到gulp.dest()指定的文件中gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) .pipe(gulp.dest('build/minified_templates')); globs类型： String 或StringArray需要处理的源文件匹配符路径，字符串或者数组通配符路径匹配示例： “src/a.js”：指定具体文件；“*“：匹配所有文件 例：src/*.js(包含src下的所有js文件)；“**“：匹配0个或多个子文件夹 例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；“{}“：匹配多个属性 例：src/{a,b}.js(包含a.js和b.js文件) src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；“!”：排除文件 例：!src/a.js(不包含src下的a.js文件)； 1234567891011var gulp = require('gulp'); // 导入第三方gulp插件var less = require('gulp-less'); // 导入第三方gulp-less插件 gulp.task('testLess', function () &#123; // 创建一个testLess任务 // 匹配单个文件 gulp.src('less/test/style.less') // 匹配多个文件（数组） gulp.src(['less/**/*.less','!less/&#123;extend,page&#125;/*.less']) // 匹配less文件夹下的所有.less文件，包括子文件夹下的.less，但是不包括less下的extend和page下的.less文件 .pipe(less()) // 使用gulp-less插件编译less文件 .pipe(gulp.dest('./css')); // 将编译后的css文件存放到当前目录的css文件夹下&#125;); options类型（可选）： Object options.buffer类型： Boolean 默认值： true如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。注意：插件可能并不会实现对 stream 的支持。 options.read类型： Boolean 默认值： true如果该项被设置为 false 那么 file.contents 会返回空值（null），也就是并不会去读取文件。 options.base类型String 默认值：’ ‘设置输出路径以某个路径的某个组成部分为基础向后拼接，将会加在 glob 之前如：请想像一下在一个路径为 client/js/somedir 的目录中，有一个文件叫 somefile.js 12345678// 没有设置base属性gulp.src('client/js/**/*.js') // 匹配 'client/js/somedir/somefile.js' .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/somedir/somefile.js' // 设置 base属性gulp.src('client/js/**/*.js', &#123; base: 'client' &#125;)//设置输出路径为client的js文件夹中，最终变成 'build/js' .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/js/somedir/somefile.js' gulp.dest(path[,options])指定处理后的文件的输出路径。如果某文件夹不存在，将会自动创建它。12345gulp.src('./client/templates/*.jade') .pipe(jade()) .pipe(gulp.dest('./build/templates')) // 将处理后的文件存放到当前文件夹下'build/templates'文件夹中 .pipe(minify()) // 使用gulp-minify插件对文件进行压缩 .pipe(gulp.dest('./build/minified_templates')); // 将处理后的文件存放到当前文件夹下'build/templates'文件夹中 文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。 请查看上述的 gulp.src 来了解更多信息。 path类型（必填）： String 或 Function指定文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。 options类型（可选）： Object options.cwd类型： String 默认值： process.cwd()输出目录的 cwd 参数（前脚本的工作路径），当输出目录是相对路径时候有效。 options.mode类型： String 默认值： 0777八进制权限字符，用以定义在输出目录中所创建的目录的权限。 gulp.task(name[, deps], fn)定义一个使用 Orchestrator 实现的任务（task）。123gulp.task('taskname', function() &#123; // 做一些事&#125;); name类型（必填）：String指定任务的名称，名称中不能包含空格 deps类型（可选）：StringArray指定该任务所依赖的其他任务（注意：被依赖的任务需要返回当前任务的事件流，从而保证任务的执行顺序，请参考如下示例）123456789101112gulp.task('testLess', function () &#123; // 返回事件流，确保该任务执行后才执行minicss任务 return gulp.src(['less/style.less']) .pipe(less()) .pipe(gulp.dest('./css'));&#125;);// minicss任务依赖testLess任务gulp.task('minicss', ['testLess'], function () &#123; //执行完testLess任务后再执行minicss任务 gulp.src(['css/*.css']) .pipe(minifyCss()) .pipe(gulp.dest('./dist/css'));&#125;); fn类型（必填）：Function该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。异步任务支持：任务可以异步执行，如果 fn 能做到以下其中一点 接受一个callback函数 123456789// 在 shell 中执行一个命令var exec = require('child_process').exec;gulp.task('jekyll', function(cb) &#123; // 编译 Jekyll exec('jekyll build', function(err) &#123; if (err) return cb(err); // 返回 error cb(); // 完成 task &#125;);&#125;); 返回一个 stream（事件流） 123456gulp.task('somename', function() &#123; var stream = gulp.src('client/**/*.js') .pipe(minify()) .pipe(gulp.dest('build')); return stream;&#125;); 返回一个 promise 123456789var Q = require('q');gulp.task('somename', function() &#123; var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 1); return deferred.promise;&#125;); 注意： 默认的，task 将以最大的并发数执行，也就是说，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，你需要做两件事： 给出一个提示，来告知 task 什么时候执行完毕， 并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。 对于这个例子，让我们先假定你有两个 task，”one”和 “two”，并且你希望它们按照这个顺序执行： 在 “one” 中，你加入一个提示，来告知什么时候它会完成：可以再完成时候返回一个 callback，或者返回一个 promise 或 stream，这样系统会去等待它完成。 在 “two” 中，你需要添加一个提示来告诉系统它需要依赖第一个 task 完成。 因此，这个例子的实际代码将会是这样：1234567891011var gulp = require('gulp');// 返回一个 callback，因此系统可以知道它什么时候完成gulp.task('one', function(cb) &#123; // 做一些事 -- 异步的或者其他的 cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了&#125;);// 定义一个所依赖的 task 必须在这个 task 执行之后完成gulp.task('two', ['one'], function() &#123; // task 'one' 完成后才执行这里的代码&#125;);gulp.task('default', ['one', 'two']); gulp.watch(glob[, opts], tasks) 与 gulp.watch(glob[, opts, cb])监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。 glob类型（必填）： String 或 StringArray指定需要处理的一个或多个源文件的一个路径匹配符或路径匹配符数组 opts类型（可选）：Object传给 gaze 的参数 ，具体参看 https://github.com/shama/gaze tasks类型(必填)：StringArray需要执行的任务的名称数组 cb(event)类型(可选)：Function每个文件变化执行的回调函数 12345678910111213141516var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); // gulp.watch(glob[, opts], tasks)gulp.task('watch1', function () &#123; gulp.watch('less/**/*.less', ['testLess']);&#125;);// gulp.watch(glob[, opts, cb])gulp.task('watch2', function () &#123; gulp.watch('js/**/*.js', function (event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...'); &#125;);&#125;); 常用插件 插件名称 作用 del 删除文件或文件夹 gulp-less 编译LESS文件 gulp-rname 重命名文件 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 js 文件 gulp-concat-css 合并 css 文件 gulp-cssnano 压缩 css gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-load-plugins 依赖自动加载 gulp-useref 自动合并打包处理 gulp-wrap 包装内容 gulp-angular-templatecache AngularJS 模板缓存 browser-sync 和 gulp 配合使用实现文件改变执行某个任务后自动刷新 yargs 获取命令行参数 gulp-if 根据判断执行某个插件","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"个人简历","date":"2017-03-03T01:32:59.000Z","path":"2017/03/03/个人简历/","text":"个人资料 姓 名： 余京成 性 别： 男 年 龄： 25 学 历： 本科 籍 贯： 河南信阳 现 居： 北京海淀 工作经验： 3年 电 话： 155-6599-9182 E-mail： 15565999182@163.com 求职意向工作性质：全职期望职业：WEB前端开发工程师、移动互联网开发、网页制作工作地区：北京期望薪资：面议到岗时间：目前处于离职状态，一周内上岗 专业技能 熟练掌握DIV+CSS布局、熟练使用HTML5、CSS3等网页制作技术，能够编写语义合理，结构清晰，易维护的页面； 熟练使用JavaScript，掌握面向对象编程思想，对原型链、闭包有一定理解； 熟悉HTTP协议，并能够使用AJAX、JSON、JSONP等WEB开发技术实现前后台数据交互，对JSOP的原理有一定了解； 熟练掌握Bootstrap、jQuery、ZeptoJS等主流框架的基本使用，能够使用BootStrap实现响应式开发，简单封装过jQuery的部分功能，并能够基于jQuery开发自己的框架； 熟悉Angular、vue等流行框架的基本使用，并能够熟练使用vue开发SPA单页面应用； 熟悉Less、Sass、Stylus预编译工具的基本使用； 熟悉版本管理工具SVN、Git的基本使用； 熟悉前端自动化构建工具Gulp、Webpack的基本使用，并能够搭建出基本的项目架构； 了解后台PHP、NodeJS的基本语法，能够使用NodeJS配合Express实现简单的功能，了解SQL Server、MySQL、MongoDB数据库语言。 工作经历2016/07-2017/03 科邻网络科技有限公司 技术部 WEB前端开发工程师工作内容： 负责网站应用前端开发，与后台开发工程师协作，完成数据交互、动态信息展现； 根据产品需求，生产出兼容于目前主流浏览器的前端页面； 编写符合W3C标准的页面代码，负责代码优化，提高页面加载速度，提高用户体验； 配合后台开发工程师一起研讨技术实现方案，以及API的设计规范； 研究和探索创新的开发思路和最新的前端技术。 2014/09-2016/06 驻马店市易创网络科技有限公司 技术部 WEB前端开发工程师工作内容： 与公司产品经理及设计人员沟通，了解项目需求，制定切实可行的实施方案； 负责根据产品部门UI设计需求进行前端页面开发； 根据产品文档开发高性能、高兼容性的前端代码； 在产品开发中提供完善的前端技术方案，并配合后端完成开发工作； 评估、优化网站前端性能。 项目经验2016/12-2017/03 教学资源云平台移动APP项目描述： 教学资源云平台是学生进行在线学习的教学资源平台，老师自己录制视频并上传，学生可以自己选择相应课程进行学习，从而更方便学生们随时随地进行学习而开发的手机端APP。 项目职责： 协同后台人员完成API的设计与调整； 精确还原效果图，完成页面的制作； 完成后台数据的获取以及前台页面的渲染； 页面中人机交互效果的实现； 对页面进行优化，提升用户体验。 技术要点： 由于vue相比Angular框架更加轻巧，因此本系统采用vue框架进行开发； 使用官方提供的vue-cli快速搭建项目基本架构； 使用Swiper完成首页轮播图的制作，使用iScroll框架完成菜单页的滑动效果； 使用vue的过渡效果以及vue-router路由功能实现了不同模块的跳转以及切换效果； 使用vuex状态管理插件存储多个组件之间共享的数据； 使用vue-resource插件完成数据的异步获取。 2016/07-2016/12 懒猫职家网站地址：http://www.lanmaojob.com/ 项目描述： 懒猫职家是一个在线招聘的网站，面向全国，提供最新最全最准确的招聘网站信息，为企业和求职者提供人才招聘、求职、找工作、培训等在内的全方位的人力资源服务，在该网站企业可以查找适合自己的人才，求职者可以选择自己合适的职业及企业。 项目职责： 完成个人中心、登录注册等模块的实现； 人机交互效果的实现与优化； 解决页面在各大浏览器的兼容性问题； 完成前后台数据交互操作。 技术要点： 使用Swiper完成首页轮播图的制作； 使用less预编译工具完成项目css的编写； 使用ajax配合正则完成登录注册页面的验证； 使用artTemplate模板引擎配合Ajax异步请求完成页面的渲染； 使用jQuery完成页面其他交互效果的实现。 使用gulp构建工具完成页面代码的编译与压缩。 2016/02-2016/06 牙宝网微信商城项目描述： 牙宝网是驻马店市牙康网络科技有限公司旗下一家以线下服务和线上推广相结合的互联网+模式，以改善口腔行业医患之间缺乏信任、牙医没有时间自由、患者而看牙贵、看牙难、牙医和患者发展速度不协调等现象，致力于做中国最具情怀的口腔资源整合专家。 项目职责： 配合后台完成API的设计与调整； 搭建项目基本结构，配合其他人员完成项目开发； 实现登录注册等其他模块的功能； 实现前后台的数据交互操作。 2015/09-2015/12 驻马店市易创网络科技官网网站地址：http://www.hhytd.com/ 项目描述： 驻马店市易创网络科技有限公司的官网，主要介绍公司的相关业务，以及公司文化，方便客户更清楚的了解公司业务。 项目职责： 制作网站效果图； 完成静态页面的之制作； 完成动态交互效果。 2015/04-2015/07 驻马店驿城区环境保护局网站地址：http://www.ycqhbj.com/ 项目描述： 驻马店驿城区环境保护局是驻马店环保局的门户网站，主要用来展示环保工作的相关信息，政策法规等，方便市民对环保工作的了解。 项目职责： 高保真还原效果图，完成静态页面的之制作； 完成动态交互效果； 完成前后台数据的交互操作。 2014/10-2015/02 黄淮学院青春黄淮及其子网站网站地址：http://211.67.180.15:8002/ 项目描述： 黄淮学院青春黄淮是黄淮学院共青团黄淮学院委员会信息展示网站，子网站包括学生会，社团联合会和大学生艺术团。 项目职责： 完成静态页面的代码编写； 解决网站的兼容性问题； 完成后台数据的读取操作。 教育背景2012/9–2016/6 黄淮学院 计算机科学与技术 统招 本科 自我评价 做事稳重，对待工作认真，责任心较强，待人真诚，善于沟通，时刻保持学习，积极拥抱变化； 喜欢前端开发，有较强的学习能力与团队精神，能够很快地适应工作环境，具有良好的沟通交流和团队合作能力； 经常逛一些技术论坛（推酷、掘金、简书、博客园等）了解最新前端动态学习最新主流技术不断充实自己。","tags":[{"name":"简历,求职,web前端","slug":"简历-求职-web前端","permalink":"http://yoursite.com/tags/简历-求职-web前端/"}]},{"title":"Vue开发遇到的问题","date":"2017-02-18T13:30:52.000Z","path":"2017/02/18/Framework/Vue/Vue开发遇到的问题/","text":"本文主要是记录学习及开发中遇到的一些问题，仅供自己学习所用，因此没有详细记录 router-link不能够添加绑定事件如果想要在添加点击事件，需要在router-link标签的内部或者外部标签上添加，不能直接在router-link上添加，没有效果详情请看 https://segmentfault.com/q/1010000007891457 返回按钮的显示隐藏在首页时候没有返回按钮，但是其他页面有返回按钮，因此设置了一个isShow属性为false让其隐藏，当跳转到其他页面的时候设置为true，这个时候刷新页面就没有返回按钮了，因为刷新页面会重新构建vue对象的此时isShow是初始值false，所以就隐藏了，这时候就可以考虑在created方法执行的时候直接监听$route.path的变化设置isShow的值从而控制返回按钮的显示和隐藏 新闻列表到详情的内容获取不正确现象：一个首页中有通过router-view组件显示新闻列表以及新闻详情页面，当从列表页跳转到详情页时，第一次详情页数据没有问题，但是以后列表页到详情页的每次跳转都是第一次跳转得到的数据，只有手动刷新详情页才能实现新数据的加载 原因：由于在router-view组件的外层包裹了keep-alive组件，因此router-view中的所有组件都会被缓存起来，所以组件只被创建了一次（即只会执行一次生命周期钩子函数），一直没有被销毁，也就是没有执行destroyed生命周期钩子，而新闻页数据的获取是在新闻页的created生命周期钩子中执行的，所以详情页的数据只获取了一次，即第一次访问时候的数据，因此以后的每次都是第一次获取的数据。而刷新页面相当于重新创建了一次该组件，因此会显示正确的新闻内容 解决办法： 方法一：去掉外层包裹的keep-live组件，即不缓存组件 方法二：使用路由钩子beforeRouteEnter处理数据请求问题 总结：keep-alive组件会把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染，因此不能在经常需要变化的地方用，否则就会出现数据显示不正确的情况，总之根据实际需求来决定需不需要使用keep-alive 相关网址： vue2.0 中keep-alive内容不刷新的问题 vue-router导航钩子 给组件绑定事件无效现象：给组件绑定事件无效解决办法：加上.native修饰符即可 $refs获取DOM元素的问题$refs是在那个时候获取DOM元素的，为什么在组件的beforeCreate和created钩子函数中都可以获取到DOM元素，此时DOM不是应该还没有被渲染吗 拉钩中seller滚动问题涉及到生命周期函数不同的阶段调用初始化betterScroll的初始化 props接受数据但是在js中无法获取现象：在接受数据的组建中无法通过js访问props的属性原因：数据是异步获取的，当组件创建的时候，可能数据还没有获取过来，此时访问props的属性是设置的初始值，而不是最终的值解决办法：通过在updated钩子函数访问props的属性，当异步获取数据之后，会自动触发updated钩子函数，此时props的属性就是最终设置的值 v-for循环需要添加key属性当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有唯一 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值（在这里使用简写）：123&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能使用 v-for 来提供 key ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。因为它是 Vue 识别节点的一个通用机制， key 并不特别与 v-for 关联，key 还具有其他用途，详情请看https://cn.vuejs.org/v2/guide/conditional.html#用-key-管理可复用的元素 数组的更新由于 JavaScript 的限制， Vue 不能检测以下变动的数组：当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue当你修改数组的长度时，例如： vm.items.length = newLength 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果， 同时也将触发状态更新：1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// Array.prototype.splice`example1.items.splice(indexOfItem, 1, newValue) 为了解决第二类问题，你也同样可以使用 splice：1example1.items.splice(newLength) 设置值受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：1var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的&lt;/pre&gt; Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：1Vue.set(vm.someObject, 'b', 2) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名： 1this.$set(this.someObject,'b',2) 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性： 12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 也有一些数组相关的问题，之前已经在列表渲染中讲过。 异步更新队列可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。例如：1&lt;div id=\"example\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue ，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：1234567891011121314151617Vue.component('example', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: function () &#123; return &#123; message: 'not updated' &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = 'updated' console.log(this.$el.textContent) // =&gt; '没有更新' this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; '更新完成' &#125;) &#125; &#125;&#125;)","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"angular 容易遇到的坑","date":"2017-02-11T16:00:00.000Z","path":"2017/02/12/Framework/AngularJS/angular容易遇到的坑/","text":"angular 容易遇到的坑进行遍历ng-repeat的时候要注意是否有重复数据F：我们在进行ng-repeat遍历数组的时候当我们的数据有重复的时候，我们的NG会报错， Q：处理办法是，在我们的要进行数据遍历的地方加入 track by $index 我们在进行事件广播的时候一定要切记的事项我们在进行数据广播的时候，要注意的是我们要进行调用的事件是否已经初始化完毕， 一般处理办法，是进行一个延时广播的操作，这样子就可以就可以避免这个问题了 还有就是我们在进行事件广播的时候一定要避免的是我们的emit和我们的broadcast的事件名称不能相同，不然的话，我们的事件广播会进入一个死循环 还有就是切记不要在我们的controller中操作我们的dom如果必须要进行操作dom的话，我们也要在我们的指令directive 中进行操作，我们在操作过dom之后要进行$scope.$digest()的调用，这样子就可以同步我们的视图和数据了，简单来说，当我们的双向数据绑定发生失效的时候，我们就要调用我们的$scope.$digest()函数，进行数据和视图之间的同步 $scope.$digest()一般情况下，调用这个函数会报错的 为什么不能直接在我们的controller中直接操作我们的dom呢， 因为我们的dom被我们直接操作以后，很容易与我们的NG产生冲突，这样子的话，可能是我们的整个NG模块出现不可预知的问题 当我们的自己调用我们自己写的jsonp的时候，我们的怎么进行数据的刷新$scope. $apply $timeout和我们js的timeout用法基本一致 只是我们在把时间设为0之后，并不会立即执行，只是把我们的匿名函数，放在我们队列的最后面（因为我们的js语言的原理所导致的，因为我们的js是单线程的） 在使用directive（指令）的时候，当我们对外界暴露一个接口的注意事项我们不可以直接在我们的当我们要给我们的接口直接赋值的情况下我们的不要直接给接口一个等于，而是间接地给一个@ 因为我们的如果直接给它赋值的话，如果不加单引号的情况下，会直接报错 例如下面这个指令 appHeadBar.js 123456789101112131415161718192021222324//这儿是我们定义的指令\"use strict\";angular.module(\"app\").directive(\"appHeadBar\",function()&#123; return&#123; restrict:\"A\", replace:true, templateUrl:\"views/template/headBar.html\", //当我们使用这种写法的时候，我们只需要使用下面的第一种写法进行引用即可 scope:&#123; text:\"@\" &#125;, //当我们使用这种写法的时候，我们要使用第二种写法，不然的话，会在浏览器中报错 scope:&#123; text:\"@\" &#125;, link:function($scope)&#123; $scope.back=function()&#123; //这儿window一定要小写 window.history.back(); &#125;; &#125; &#125;;&#125;); post.html 12345&lt;!--写法一--&gt; &lt;div app-head-bar text=\"我的收藏\"&gt;&lt;/div&gt;&lt;!--写法二--&gt;&lt;div app-head-bar text=\"'我的收藏'\"&gt;&lt;/div&gt; ERROR 1Error: [$parse:lexerr] Lexer Error: Unexpected next character at columns 0-0 [我] in expression [我的收藏].","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"gulp搭建静态项目结构","date":"2017-01-10T13:03:08.000Z","path":"2017/01/10/Framework/Gulp/gulp搭建静态项目结构/","text":"基本文件结构123456789├─dist├─node_modules└─src ├─app │ ├─login │ └─register ├─fonts ├─img └─less 安装相关的依赖包12npm install --save angularnpm install --save angular-route gulp del gulp-concat gulp-uglify gulp-yargs gulp-if gulp-less gulp-cssnano gulp-angular-templatecache browser-sync 扩展12# 当根据package.json文件下载安装依赖的时候，如果只想安装生产依赖npm install --production 对文件进行打包操作当写项目的时候需要对项目进行实时打包，合并成单个文件 将静态文件打包到dis中，并保存目录结构 123456789101112131415161718/** * 每次构建dist目录时先删除dist文件 */gulp.task('clear', function(callback) &#123; del(paths.dist) .then(function() &#123; callback() // 保证任务的执行顺序 &#125;)&#125;);/** * 拷贝静态文件到指定目录，每次拷贝前先删除dist文件夹中的内容 */gulp.task('static', ['clear'], function() &#123; return gulp.src(paths.staticPath, &#123; base: './src' //拷贝时，保留src下的目录结构不变 &#125;) .pipe(gulp.dest(paths.dist))&#125;); 将引入的css都打包成一个文件，如： app.css 123456789/** * 编译main.less文件 */gulp.task('less', function() &#123; return gulp.src(paths.lessPath) // lessPath: './src/less/main.less' .pipe(less()) .pipe(gulpif(argv.deploy, css())) .pipe(gulp.dest(paths.lessDist)) // lessPath: './src/less/main.less'&#125;); 将第三方的js文件打包合并成一个 vender.js 文件 123456789/** * 压缩合并第三方依赖的JS文件到指定目录 */gulp.task('vender', function() &#123; return gulp.src(paths.venders) // venders: ['./node_modules/angular/angular.js', './node_modules/angular-route/angular-route.js'], .pipe(concat('vender.js')) // 合并JS代码并取名为vender.js .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.venderDist)) // venderDist: './dist/js'&#125;); 将自己的js文件打包合并成一个 bundle.js 文件 123456789101112131415161718192021222324252627282930313233// html文件中的外部文件路径的引入问题// 使用angular的$templateCache将所有html文件读取出来生成一段js代码/** * 读取app文件夹中所有的html文件自动生成模板字符串缓存 * templatecache参数 * 参数一：fileName默认是templates.js * 参数二：options * root: 生成的路径名 * module：angularjs模块名，默认是templates，然后在主模块中引入该模块 * standalong：创建一个独立的模块 * transformUrl：(类型：function)转换路径，修改原有的生成规则，返回新的路径 * 利用node的内置模块==&gt;node.basename(path) */gulp.task('template', function() &#123; return gulp.src(paths.template) .pipe(templatecache(&#123; module: 'templates', standalong: true, transformUrl: function(url) &#123; return './' + path.basename(url) &#125; &#125;)) //将读取到的html文件生成一段js代码，以字符串的形式存储到缓存中 .pipe(gulpif.dest('./')) //将构建出来的文件存放到&#125;);/** * 压缩合并自己的JS文件到指定目录，包括templates.js文件 */gulp.task('script', ['template'], function() &#123; return gulp.src(paths.scripts) .pipe(concat('bundle.js')) // 合并JS代码 .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.scriptDist))&#125;); 开启服务监视文件改动自动刷新浏览器 123456789101112131415161718192021/** * 监视js文件的变动 */gulp.task('js-watch', function(done) &#123; browserSync.reload() done()&#125;);/** * 开启服务 */gulp.task('server', function() &#123; browserSync.init(&#123; server: &#123; baseDir: path.dist &#125; &#125;) gulp.watch(['./src/app/**/*.js', './src/app/**/*.less', './src/**/*.html' ], ['js-watch'])&#125;); 最终的gulpfile.js这里的代码任务之间的依赖性太强，有很大的优化空间，代码仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * 1. 拷贝静态资源 * 2. 压缩合并第三方JS文件 * 3. 压缩合并自己的JS文件 * 4. 编译压缩less文件 */var gulp = require('gulp')var del = require('del') // 删除文件var concat = require('gulp-concat') // 合并JS文件var uglify = require('gulp-uglify') // 压缩JS文件var argv = require('yargs').argv // 获取命令行参数var gulpif = require('gulp-if') // 根据判断执行某个插件var less = require('gulp-less') // 编译less文件var css = require('gulp-cssnano') // 压缩 cssvar templatecache = require('gulp-angular-templatecache') // 压缩 cssvar path = require('path') // 加载node内置的path方法，解析路径var browserSync = require('browser-sync').create() // 开启服务并和 gulp 配合使用实现文件改变执行某个任务后自动刷新var paths = &#123; staticPath: [ './src/index.html', './src/img/**/*.*', './src/fonts/**/*.*' ], dist: './dist' venders: [ './node_modules/angular/angular.js', './node_modules/angular-route/angular-route.js' ], venderDist: './dist/js', scripts: [ '/templates.js', // 放在前面，保证在合成的时候也是在文件内容的最上面 './src/app/**/*.js' ], scriptDist: './dist/js', lessPath: './src/less/main.less', //其他less文件都引入main.css文件中，最后编译成一个main.css文件 lessDist: './dist/css', template: './src/app/**/*.html'&#125;/** * 每次构建dist目录时先删除dist文件 */gulp.task('clear', function(callback) &#123; del(paths.dist) .then(function() &#123; callback() // 保证任务的执行顺序 &#125;)&#125;);/** * 拷贝静态文件到指定目录 */gulp.task('static', ['clear'], function() &#123; return gulp.src(paths.staticPath, &#123; base: './src' //拷贝时，保留src下的目录结构不变 &#125;) .pipe(gulp.dest(paths.dist))&#125;);/** * 压缩合并第三方依赖的JS文件到指定目录 */gulp.task('vender', ['less'], function() &#123; return gulp.src(paths.venders) .pipe(concat('vender.js')) // 合并JS代码并取名为vender.js .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.venderDist))&#125;);/** * 压缩合并自己的JS文件到指定目录，包括templates.js文件 */gulp.task('script', ['template'], function() &#123; return gulp.src(paths.scripts) .pipe(concat('bundle.js')) // 合并JS代码 .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.scriptDist))&#125;);/** * 编译main.less文件 */gulp.task('less', ['static'], function() &#123; return gulp.src(paths.lessPath) .pipe(less()) .pipe(gulpif(argv.deploy, css())) .pipe(gulp.dest(paths.lessDist))&#125;);// html文件中的外部文件路径的引入问题// 使用angular的$templateCache将所有html文件读取出来生成一段js代码/** * 读取app文件夹中所有的html文件自动生成模板字符串缓存 * templatecache参数 * 参数一：fileName默认是templates.js * 参数二：options * root: 生成的路径名 * module：angularjs模块名，默认是templates，然后在主模块中引入该模块 * standalong：创建一个独立的模块 * transformUrl：(类型：function)转换路径，修改原有的生成规则，返回新的路径 * 利用node的内置模块==&gt;node.basename(path) */gulp.task('template', ['vender'], function() &#123; return gulp.src(paths.template) .pipe(templatecache(&#123; module: 'templates', standalong: true, transformUrl: function(url) &#123; return './' + path.basename(url) &#125; &#125;)) //将读取到的html文件生成一段js代码，以字符串的形式存储到缓存中 .pipe(gulpif.dest('./')) //将构建出来的文件存放到&#125;);/** * 监视js文件的变动 */gulp.task('js-watch', ['script'], function(done) &#123; browserSync.reload() done()&#125;);/** * 开启服务 */gulp.task('server', ['script'], function() &#123; browserSync.init(&#123; server: &#123; baseDir: path.dist &#125; &#125;) gulp.watch(['./src/app/**/*.js', './src/app/**/*.less', './src/**/*.html' ], ['js-watch'])&#125;);","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"windows 免费升级win10","date":"2016-11-11T16:00:00.000Z","path":"2016/11/12/Others/免费更新win10/","text":"windows 免费升级win10 下载win10安装软件 正常来说去年win10已经停止了免费更新，氮素！还是留了个后门的，就是— 面向使用辅助技术的客户的 Windows 10 免费升级优惠 （反正就是给不是正常人使用的，但是跟正常系统是一样的）； 点击【立即升级】按钮即可，官方版本不用担心有乱七八糟的东西； 然而有些电脑是需要激活才能升win10的，我是试过好多的激活码都不管用，当然网上还有一些其他激活的教程，我是选择了最简单的，下软件,用的是 oem7小马激活工具 一键傻瓜式操作； 后面就简单了，用前面下的win10工具下载呗，建议网速好的情况，最好是晚上下，差不多3g？下载完成后，也会自动安装的； 如果电脑内存不大，略卡的情况可以度娘一下，进行各种优化；实在卡的不行，也可以选择恢复的，在安装时已经帮你自动保存了以前的版本； PS：如果电脑原来是32bit的，升级了也还是32bit，想升64bit好像只能重装？反正直接升win10是不行的；","tags":[{"name":"windows,windows 10","slug":"windows-windows-10","permalink":"http://yoursite.com/tags/windows-windows-10/"}]},{"title":"webpack配置","date":"2016-11-03T12:01:51.000Z","path":"2016/11/03/Framework/Webpack/Webpack配置/","text":"全局安装webpack配置webpack.config.js文件123456789101112131415161718192021222324252627282930var path = require('path')var webpack = require('webpack')module.exports = &#123;//-----------------------配置程序入口文件----------------------- entry: &#123; app: './src/main.js' // 文件入口 &#125;, //------------------------配置编译后的文件---------------------- output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js', // 最终编译后的js文件 &#125;, //-----------------------配置自动刷新相关内容----------------------- devtooll: 'eval', devServer: &#123; contentBase: __dirname + '/src', hot: true, inline: true, port: 8080, host: 'localhost', historyApiFallback: true, noInfo: false, // stats: 'minimal', // publicPath: publicPath &#125;, //---------------------------各种插件----------------------------- plugins: &#123; // 自动刷新插件 new webpack.HotModuleReplacementPlugin() &#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"前端跨域访问","date":"2016-11-03T12:01:51.000Z","path":"2016/11/03/Others/前端跨域访问/","text":"原文：http://blog.brucefeng.info/post/web-crossdomain-2016 1. JSONP 2. CORS（Cross-origin resource sharing） 2.1 运行模式 2.2 JQuery支持CORS 2.3 与JSONP相比 3. 跨域访问在点评的应用 References 在互联网应用中： 一个页面需要请求多个域名下的web服务端接口 同时一个web服务接口可能会被很多不同域名下的页面请求。 一个web应用如果支持为了支持以上模式而申请多个域名是不合算的，因为域名申请和管理所占用的资源比较大，因此服务端支持跨域就成了一个更合理的解决方案。 解决跨域的方式主要有两种： 1. JSONP关于JSONP的基本概念就不多介绍了，现在在网上已经有很多解释。JSONP模式下前端Client可以跨域请求JSON文件，进而实现前端跨域请求其他服务器资源的目的。目前在一些流行的JavaScript库中对JSONP和Ajax的支持方式在表现形式上非常相近，在代码中写法几乎都是相同的，但是JSONP与Ajax是完全不同的原理。JSONP是以请求文件数据的方式向服务器发出请求，而Ajax是使用XMLHttpRequest向服务器异步发出请求。 优点JSONP并不需要浏览器特殊支持，可以说所有的浏览器都是支持JSONP请求的。而且目前各流行JavaScript类库对JSONP的支持已经很全面，开发中也比较方便。 缺点但JSONP的请求只能是GET请求，因为在请求URL有长度限制，一般情况下只要不超过2000字符都是可以的(What is the maximum length of a URL?)，主流浏览器所支持的长度也越来越放宽，基本是可以满足条件的。JSONP的web服务端接口因为无法限制接收指定域名的请求，因此在实际应用中需要在安全性方面进行更多限制，以避免接口数据泄漏。 2. CORS（Cross-origin resource sharing）主要是通过定义浏览器与服务器之间共享内容的方式来实现跨域。CORS通过新增一系列 HTTP 头（Access-Control-Allow-Origin，Access-Control-Expose-Headers，Access-Control-Max-Age，Access-Control-Allow-Credentials，Access-Control-Allow-Methods，Access-Control-Allow-Headers等），让服务器能声明那些来源可以通过浏览器访问该服务器上的资源。另外，对那些会对服务器数据造成破坏性影响的 HTTP 请求方法（特别是 GET 以外的 HTTP 方法，或者搭配某些MIME类型的POST请求），标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求(preflight request)，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）。 2.1 运行模式 如果只使用简单请求向服务器发出请求，则浏览器就不需要向服务器发送预请求，服务器端只需要在response中增加Access-Control-Allow-Origin就可以了，开发非常简单，在代码上和Ajax请求几乎没有区别。 简单请求：只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。不会使用自定义请求头（类似于 X-Modified 这种）。但请求以如果 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求或者使用自定义请求头（比如添加诸如 X-PINGOTHER）时，浏览器就需要向服务器发送预请求，以确定服务器是否支持后续请求，如果支持，浏览器则继续发送后续Ajax请求。 2.2 JQuery支持CORS123456789101112$.ajax(&#123; //PUT 和DELETE 需要发送预请求 type: 'HTTP METHOD',//如GET ，POST url: 'cross-domain-url', contentType:, xhrFields: &#123; withCredentials: false &#125;, headers: &#123;&#125;, success: function () &#123;&#125;, error: function () &#123;&#125; &#125;); 详细的使用参见HTTP访问控制(CORS)。 2.3 与JSONP相比CORS的开发更为简单，对安全性的控制更为灵活，且目前所有的现代浏览器都已经支持了CORS模式，CORS支持所有的HTTP Method类型，在Restful请求中可以实现跨域。 3. 跨域访问在点评的应用在点评，很多功能采用动静分离的方式，在项目部署上也采用前端静态文件资源与后端web服务独立域名的方式进行；这种模式下，后端的HTTP 接口对于前端而言是一个服务接口；例如一个查询用户是否登录的接口，可能会被多个项目使用，因此就要求服务端接口支持跨域请求。目前在点评中主要使用JSONP的方式来实现跨域请求；因为CORS算是一个新技术，因此还没有大规模使用，只会在一些不重要的功能中使用过。 References JSONPWhat is the maximum length of a URL?CORS（Cross-origin resource sharing）Cross-Origin Resource SharingHTTP访问控制(CORS)JQuery CORS support IE’s XDomainRequest object plugin","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"Directive的基本使用","date":"2016-10-03T13:50:52.000Z","path":"2016/10/03/Framework/AngularJS/directive/","text":"angular directive什么是指令呢？我们先看官方的说法 What are Directives?At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS’s HTML compiler ($compile) to attach a specified behavior to that DOM element (e.g. via event listeners), or even to transform the DOM element and its children. AngularJS comes with a set of these directives built-in, like ngBind, ngModel, and ngClass. Much like you create controllers and services, you can create your own directives for AngularJS to use. When AngularJS bootstraps your application, the HTML compiler traverses the DOM matching directives against the DOM elements. 在高的层面上讲，指令是DOM元素中的标记(例如一个属性，一个节点名，注释或者CSS类)，它告诉angularjs编译器去给这个元素附加一个指令的行为或者转换DOM元素和它的子元素。 Angularjs拥有一些内建的指令，像ngBind、ngModel和ngClass。非常类似于你创建自己的controller和service，你可以创建你自己的指令个angularjs使用，当angular初始化启动你的应用程序，html编译器将遍历你的DOM元素并且去匹配指令。 实例解析expander 实例解析accordion 指令的运行原理 compile和link restrict匹配模式 A 属性 &lt;div hello&gt;&lt;/div&gt; E element 元素 &lt;hello&gt;&lt;/hello&gt; M 注释 &lt;!-- directive:hello --&gt; 要加空格 &lt;div&gt;&lt;/div&gt; C 样式类 &lt;div class=&quot;hello&quot;&gt;&lt;/div&gt; 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt;&lt;/hello&gt; &lt;div hello&gt;&lt;/div&gt; &lt;div class=\"hello\"&gt;&lt;/div&gt; &lt;!-- directive:hello --&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"HelloAngular_Directive.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict: 'AEMC', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', replace: true &#125;&#125;); templateUrl:模板 12345678910111213141516var myModule = angular.module(\"MyModule\", []);//注射器加载完所有模块时，此方法执行一次myModule.run(function($templateCache)&#123; //把内容缓存起来 $templateCache.put(\"hello.html\",\"&lt;div&gt;Hello everyone!!!!!!&lt;/div&gt;\");&#125;);myModule.directive(\"hello\", function($templateCache) &#123; return &#123; restrict: 'AECM', //把缓存取出来 template: $templateCache.get(\"hello.html\"), replace: true &#125;&#125;); replace开启的话，就会把我们模板里面的内容替换掉 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt; //当我们的页面启动后就会把这段内容替换掉 &lt;div&gt;这里是指令内部的内容。&lt;/div&gt; &lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"replace.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict:\"AE\", template:\"&lt;div&gt;Hello everyone!&lt;/div&gt;\", replace:true &#125; &#125;); ng-transclude只有这个指令可以使用多个多个指令之前多层嵌套，所以很重要 12345678910111213&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt; &lt;div&gt;这里是指令内部的内容。&lt;/div&gt; &lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"transclude.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict:\"AE\", transclude:true, // ng-transclude告诉angular被替换的内容填充到哪里去 template:\"&lt;div&gt;Hello everyone!&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;\" &#125; &#125;); link取属性的方式添加监听事件，以及实现指令与多个控制器之间进行交互 1234567891011121314151617&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; &lt;loader howToLoad=\"loadData()\"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;div ng-controller=\"MyCtrl2\"&gt; //定义属性这样让我们的directive去调用 &lt;loader howToLoad=\"loadData2()\"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Directive&amp;Controller.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.loadData=function()&#123; console.log(\"加载数据中...\"); &#125;&#125;]);myModule.controller('MyCtrl2', ['$scope', function($scope)&#123; $scope.loadData2=function()&#123; console.log(\"加载数据中...22222\"); &#125;&#125;]);myModule.directive(\"loader\", function() &#123; return &#123; restrict:\"AE\", link:function(scope,element,attrs)&#123; //这里和jquery一样，给这个loader directive元素添加一个mouseenter事件，然后去调用上面的函数 element.bind('mouseenter', function(event) &#123; //scope.loadData(); //强制刷新以及调用上面的函数 // scope.$apply(\"loadData()\"); // 注意这里的坑，howToLoad会被转换成小写的howtoload //给我们的页面上的指令加了属性，然后通过不同的属性来调用不同函数，这样子也实现了指令的 //复用，指令就是为了复用，就可以在不同的控制器中去复用指令，以及实现数据交互 scope.$apply(attrs.howtoload); &#125;); &#125; &#125; &#125;); link实现多个指令之间的通信1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Directive&amp;Directive.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength&gt;动感超人---力量&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength speed&gt;动感超人2---力量+敏捷&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength speed light&gt;动感超人3---力量+敏捷+发光&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var myModule = angular.module(\"MyModule\", []);myModule.directive(\"superman\", function() &#123; return &#123; //创建独立作用域，下面一个例子会讲解独立scope scope: &#123;&#125;, restrict: 'AE', //指令内部的controller，作用是我们的指令暴露出public方法供外部使用 controller: function($scope) &#123; $scope.abilities = []; this.addStrength = function() &#123; $scope.abilities.push(\"strength\"); &#125;; this.addSpeed = function() &#123; $scope.abilities.push(\"speed\"); &#125;; this.addLight = function() &#123; $scope.abilities.push(\"light\"); &#125;; &#125;, //link是指令内部的一些方法 link: function(scope, element, attrs) &#123; //给我们的元素增加classname element.addClass('btn btn-primary'); //绑定事件 element.bind(\"mouseenter\", function() &#123; console.log(scope.abilities); &#125;); &#125; &#125;&#125;);myModule.directive(\"strength\", function() &#123; return &#123; //require是说strength指令依赖于superman这个指令 require: '^superman', //当有了依赖之后，我们就可以注入第四个参数了，这样子我们就可以访问到supermanCtrl里面暴露出来的公用方法了 link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addStrength(); &#125; &#125;&#125;);myModule.directive(\"speed\", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addSpeed(); &#125; &#125;&#125;);myModule.directive(\"light\", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addLight(); &#125; &#125;&#125;); 独立scpe123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"IsolateScope.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict: 'AE', // scope:&#123;&#125;,// 如果不加这个参数的话，我们页面中所有的指令都会同时发生改变互相影响，这显然是不是我们想要的 template: '&lt;div&gt;&lt;input type=\"text\" ng-model=\"userName\"/&gt;&#123;&#123;userName&#125;&#125;&lt;/div&gt;', replace: true &#125;&#125;); scope绑定策略 @绑定 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; //需要注意的是@绑定传递的是字符串，而不是对象 &lt;drink flavor=\"&#123;&#123;ctrlFlavor&#125;&#125;\"&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeAt.js\"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314151617181920var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; //控制器上面加个一个属性 $scope.ctrlFlavor=\"百威\";&#125;])myModule.directive(\"drink\", function() &#123; return &#123; restrict:'AE', scope:&#123; //而这种方式angular则会帮我们自动绑定数据 flavor:'@' &#125;, template:\"&lt;div&gt;&#123;&#123;flavor&#125;&#125;&lt;/div&gt;\" // , //下面这种方式指定我们的flavor的数据是我们的控制器中的数据 // link:function(scope,element,attrs)&#123; // scope.flavor=attrs.flavor; // &#125; &#125;&#125;); ScopeEqual绑定 进行双向数据绑定，也就是我们控制器与指令之间进行双向的数据绑定 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; Ctrl: &lt;br&gt; //这儿是我们控制器中的ctrlFlavor &lt;input type=\"text\" ng-model=\"ctrlFlavor\"&gt; &lt;br&gt; Directive: &lt;br&gt; //这儿展示我们指令中的flavor &lt;drink flavor=\"ctrlFlavor\"&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeEqual.js\"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.ctrlFlavor=\"百威\";&#125;])myModule.directive(\"drink\", function() &#123; return &#123; restrict:'AE', scope:&#123; //用=绑定就可以只要改变我们指令中的flavor就可以改变我们的控制器中的ctrlFlavor，反之我们改变控制器中的也可以改变指令中的 flavor:'=' &#125;, template:'&lt;input type=\"text\" ng-model=\"flavor\"/&gt;' &#125;&#125;); &amp;scope 实现控制器与指令之间的交互，比link要方便,传递一个来自父scope的函数，稍后调用 1234567891011121314151617&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; //这里我们传递的参数是对象，跟上面说的@scope不同 &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeAnd.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819var myModule = angular.module(\"MyModule\", [] ;myModule.controller('MyCtrl', ['$scope', function($scope)&#123; //暴露出一个方法就可以被我们的指令进行调用 $scope.sayHello=function(name)&#123; alert(\"Hello \"+name); &#125;&#125;])myModule.directive(\"greeting\", function() &#123; return &#123; restrict:'AE', scope:&#123; greet:'&amp;' &#125;, //在下面我们添加一个方法进行调用我们上面的控制器暴露出来的sayHello方法 //传递参数的形式是对象的形式 template:'&lt;input type=\"text\" ng-model=\"userName\" /&gt;&lt;br/&gt;'+ '&lt;button class=\"btn btn-default\" ng-click=\"greet(&#123;name:userName&#125;)\"&gt;Greeting&lt;/button&gt;&lt;br/&gt;' &#125;&#125;); angular内置指令在我用的1.3.11中共计63个 form指令 FormBasic 12345678910111213141516&lt;html ng-app='TestFormModule'&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormBasic.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form name=\"myForm\" ng-submit=\"save()\" ng-controller=\"TestFormModule\"&gt; //required属性就是我们的angular帮我们自动校验 &lt;input name=\"userName\" type=\"text\" ng-model=\"user.userName\" required/&gt; &lt;input name=\"password\" type=\"password\" ng-model=\"user.password\" required/&gt; //ng-disabled把它绑定到myForm.$invalid上就可以判断我们的按钮是否可用的状态 &lt;input type=\"submit\" ng-disabled=\"myForm.$invalid\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345678910var appModule = angular.module('TestFormModule', []);appModule.controller(\"TestFormModule\",function($scope)&#123; $scope.user=&#123; userName:'damoqiongqiu', password:'' &#125;; $scope.save=function()&#123; alert(\"保存数据!\"); &#125;&#125;); formadv1 下面是复杂一点的表单 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html ng-app&gt; &lt;head&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormAdv1.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"Controller\"&gt; &lt;form name=\"form\" class=\"css-form\" novalidate&gt; Name: &lt;input type=\"text\" ng-model=\"user.name\" name=\"uName\" required /&gt;&lt;br/&gt; E-mail: &lt;input type=\"email\" ng-model=\"user.email\" name=\"uEmail\" required /&gt;&lt;br/&gt; //校验我们的Email是否合法form.uEmail.$dirty &amp;&amp; form.uEmail.$invalid &lt;div ng-show=\"form.uEmail.$dirty &amp;&amp; form.uEmail.$invalid\"&gt; Invalid: &lt;span ng-show=\"form.uEmail.$error.required\"&gt;Tell us your email.&lt;/span&gt; &lt;span ng-show=\"form.uEmail.$error.email\"&gt;This is not a valid email.&lt;/span&gt; &lt;/div&gt; Gender:&lt;br/&gt; &lt;input type=\"radio\" ng-model=\"user.gender\" value=\"male\" /&gt; male &lt;input type=\"radio\" ng-model=\"user.gender\" value=\"female\" /&gt; female&lt;br/&gt; &lt;input type=\"checkbox\" ng-model=\"user.agree\" name=\"userAgree\" required /&gt; I agree: &lt;input ng-show=\"user.agree\" type=\"text\" ng-model=\"user.agreeSign\" required /&gt; &lt;div ng-show=\"!user.agree || !user.agreeSign\"&gt; Please agree and sign. &lt;/div&gt; &lt;br/&gt; &lt;button ng-click=\"reset()\" ng-disabled=\"isUnchanged(user)\"&gt; RESET &lt;/button&gt; &lt;button ng-click=\"update(user)\" ng-disabled=\"form.$invalid || isUnchanged(user)\"&gt; SAVE &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617function Controller($scope) &#123; $scope.master = &#123;&#125;; $scope.update = function(user) &#123; $scope.master = angular.copy(user); &#125;; $scope.reset = function() &#123; $scope.user = angular.copy($scope.master); &#125;; $scope.isUnchanged = function(user) &#123; return angular.equals(user, $scope.master); &#125;; $scope.reset();&#125; 下面说一个比较酷的功能 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html ng-app=\"form-example2\"&gt; &lt;head&gt; &lt;link href=\"../bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\" media=\"screen\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormCustom.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div[contentEditable] &#123; cursor: pointer; background-color: #D0D0D0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; //开启contentEditable可以让我们的div有input的功能 &lt;div contentEditable=\"true\" ng-model=\"content\" title=\"Click to edit\"&gt;Some&lt;/div&gt; &lt;pre&gt;model = &#123;&#123;content&#125;&#125;&lt;/pre&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021angular.module('form-example2', []).directive('contenteditable', function() &#123; return &#123; require : 'ngModel', link : function(scope, elm, attrs, ctrl) &#123; // view -&gt; model elm.bind('keyup', function() &#123; scope.$apply(function() &#123; ctrl.$setViewValue(elm.text()); &#125;); &#125;); // model -&gt; view ctrl.$render = function() &#123; elm.html(ctrl.$viewValue); &#125;; // load init value from DOM ctrl.$setViewValue(elm.html()); &#125; &#125;;&#125;); 自定义指令 123456789101112131415&lt;html ng-app='expanderModule'&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"ExpanderSimple.css\"/&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ExpanderSimple.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller='SomeController'&gt; &lt;expander class='expander' expander-title='title'&gt; &#123;&#123;text&#125;&#125; &lt;/expander&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031var expanderModule=angular.module('expanderModule', []);expanderModule.directive('expander', function() &#123; return &#123; //这里我们的匹配模式定义的是也可以用元素也可以用属性 restrict : 'EA', // 替换 replace : true, //内部的内容是可以变换的 transclude : true, scope : &#123; //用=号进行scope双向数据绑定 title : '=expanderTitle' &#125;, //ng-click=\"toggle()这里的click只能调用我们内部的toggle template : '&lt;div&gt;' + '&lt;div class=\"title\" ng-click=\"toggle()\"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' + '&lt;div class=\"body\" ng-show=\"showMe\" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', link : function(scope, element, attrs) &#123; scope.showMe = false; //这里我们定义的toggle只能在指令内部进行调用 scope.toggle = function() &#123; scope.showMe = !scope.showMe; &#125; &#125; &#125;&#125;);expanderModule.controller('SomeController',function($scope) &#123; $scope.title = '点击展开'; $scope.text = '这里是内部的内容。';&#125;); 123456789101112131415.expander &#123; border: 1px solid black; width: 250px;&#125;.expander&gt;.title &#123; background-color: black; color: white; padding: .1em .3em; cursor: pointer;&#125;.expander&gt;.body &#123; padding: .1em .3em;&#125; 再来一个 123456789101112131415&lt;html ng-app=\"expanderModule\"&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"Accordion.css\"/&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Accordion.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-controller='SomeController' &gt; &lt;accordion&gt; &lt;expander class='expander' ng-repeat='expander in expanders' expander-title='expander.title'&gt; &#123;&#123;expander.text&#125;&#125; &lt;/expander&gt; &lt;/accordion&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var expModule=angular.module('expanderModule',[])expModule.directive('accordion', function() &#123; return &#123; restrict : 'EA', replace : true, transclude : true, template : '&lt;div ng-transclude&gt;&lt;/div&gt;', //对外暴露方法 controller : function() &#123; var expanders = []; this.gotOpened = function(selectedExpander) &#123; angular.forEach(expanders, function(expander) &#123; if (selectedExpander != expander) &#123; expander.showMe = false; &#125; &#125;); &#125; this.addExpander = function(expander) &#123; expanders.push(expander); &#125; &#125; &#125;&#125;);expModule.directive('expander', function() &#123; return &#123; restrict : 'EA', replace : true, transclude : true, //依赖于accordion指令 require : '^?accordion', scope : &#123; title : '=expanderTitle' &#125;, template : '&lt;div&gt;' + '&lt;div class=\"title\" ng-click=\"toggle()\"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' + '&lt;div class=\"body\" ng-show=\"showMe\" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', link : function(scope, element, attrs, accordionController) &#123; scope.showMe = false; accordionController.addExpander(scope); scope.toggle = function toggle() &#123; scope.showMe = !scope.showMe; accordionController.gotOpened(scope); &#125; &#125; &#125;&#125;);expModule.controller(\"SomeController\",function($scope) &#123; $scope.expanders = [&#123; title : 'Click me to expand', text : 'Hi there folks, I am the content that was hidden but is now shown.' &#125;, &#123; title : 'Click this', text : 'I am even better text than you have seen previously' &#125;, &#123; title : 'Test', text : 'test' &#125;];&#125;); 123456789101112131415.expander &#123; border: 1px solid black; width: 250px;&#125;.expander&gt;.title &#123; background-color: black; color: white; padding: .1em .3em; cursor: pointer;&#125;.expander&gt;.body &#123; padding: .1em .3em;&#125; 看到没，其实编写自定义指令还是比较困难的，所以我们可以去引入一些第三方的指令库 这样子，就可以极大地方便实现我们想要的功能了 再来个难一点的自定义指令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"framework/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;link rel=\"stylesheet\" href=\"common.css\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"framework/ui-bootstrap-tpls-0.11.0.js\"&gt;&lt;/script&gt; &lt;script src=\"Accordion-ngui.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;div ng-controller=\"AccordionDemoCtrl\"&gt; &lt;p&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"status.open = !status.open\"&gt;Toggle last panel&lt;/button&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"status.isFirstDisabled = ! status.isFirstDisabled\"&gt;Enable / Disable first panel&lt;/button&gt; &lt;/p&gt; &lt;label class=\"checkbox\"&gt; &lt;input type=\"checkbox\" ng-model=\"oneAtATime\"&gt;Open only one at a time &lt;/label&gt; &lt;accordion close-others=\"oneAtATime\"&gt; &lt;accordion-group heading=\"Static Header, initially expanded\" is-open=\"status.isFirstOpen\" is-disabled=\"status.isFirstDisabled\"&gt; This content is straight in the template. &lt;/accordion-group&gt; &lt;accordion-group heading=\"&#123;&#123;group.title&#125;&#125;\" ng-repeat=\"group in groups\"&gt; &#123;&#123;group.content&#125;&#125; &lt;/accordion-group&gt; &lt;accordion-group heading=\"Dynamic Body Content\"&gt; &lt;p&gt;The body of the accordion group grows to fit the contents&lt;/p&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"addItem()\"&gt;Add Item&lt;/button&gt; &lt;div ng-repeat=\"item in items\"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/accordion-group&gt; &lt;accordion-group is-open=\"status.open\"&gt; &lt;accordion-heading&gt; I can have markup, too! &lt;i class=\"pull-right glyphicon\" ng-class=\"&#123;'glyphicon-chevron-down': status.open, 'glyphicon-chevron-right': !status.open&#125;\"&gt;&lt;/i&gt; &lt;/accordion-heading&gt; This is just some content to illustrate fancy headings. &lt;/accordion-group&gt; &lt;/accordion&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627var myModule = angular.module('MyModule', ['ui.bootstrap']);myModule.controller('AccordionDemoCtrl', ['$scope', function($scope) &#123; $scope.oneAtATime = true; $scope.groups = [&#123; title: 'Dynamic Group Header - 1', content: 'Dynamic Group Body - 1' &#125;, &#123; title: 'Dynamic Group Header - 2', content: 'Dynamic Group Body - 2' &#125;]; $scope.items = ['Item 1', 'Item 2', 'Item 3']; $scope.addItem = function() &#123; var newItemNo = $scope.items.length + 1; $scope.items.push('Item ' + newItemNo); &#125;; $scope.status = &#123; isFirstOpen: true, isFirstDisabled: false &#125;; &#125;])","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"Sass方法指南","date":"2016-10-03T12:01:51.000Z","path":"2016/10/03/CSS预编译工具/Sass/Sass用法指南/","text":"原文：http://www.ruanyifeng.com/blog/2012/06/sass.html 一、什么是SASSSASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 本文总结了SASS的主要用法。我的目标是，有了这篇文章，日常的一般使用就不需要去看官方文档了。 二、安装和使用2.1 安装SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。 假定你已经安装好了Ruby，接着在命令行输入下面的命令： 1gem install sass 然后，就可以使用了。 2.2 使用SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。 下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。） 1234567sass test.scss``` 如果要将显示结果保存成文件，后面再跟一个.css文件名。```bashsass test.scss test.css SASS提供四个编译风格的选项： nested：嵌套缩进的css代码，它是默认值。 expanded：没有缩进的、扩展的css代码。 compact：简洁格式的css代码。 compressed：压缩后的css代码。 生产环境当中，一般使用最后一个选项。 1sass --style compressed test.sass test.css 你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。 1234# watch a filesass --watch input.scss:output.css# watch a directorysass --watch app/sass:public/stylesheets SASS的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 三、基本用法3.1 变量SASS允许使用变量，所有变量以$开头。 12345$blue : #1875e7;div &#123; color : $blue;&#125; 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。 1234$side : left;rounded &#123; border-#&#123;$side&#125;-radius: 5px;&#125; 3.2 计算功能SASS允许在代码中使用算式： 12345body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%;&#125; 3.3 嵌套SASS允许选择器嵌套。比如，下面的CSS代码： 123div h1 &#123; color : red;&#125; 可以写成： 12345div &#123; hi &#123; color:red; &#125;&#125; 属性也可以嵌套，比如border-color属性，可以写成： 12345p &#123; border: &#123; color: red; &#125;&#125; 注意，border后面必须加上冒号。 在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成： 123a &#123; &amp;:hover &#123; color: #ffb3ff; &#125;&#125; 3.4 注释SASS共有两种注释风格。 标准的CSS注释 / comment / ，会保留到编译后的文件。 单行注释 // comment，只保留在SASS源文件中，编译后被省略。 在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 123/*! 重要注释！*/ 四、代码的重用4.1 继承SASS允许一个选择器，继承另一个选择器。比如，现有class1： 123.class1 &#123; border: 1px solid #ddd;&#125; class2要继承class1，就要使用@extend命令： 1234.class2 &#123; @extend .class1; font-size:120%;&#125; 4.2 MixinMixin有点像C语言的宏（macro），是可以重用的代码块。 使用@mixin命令，定义一个代码块。 1234@mixin left &#123; float: left; margin-left: 10px;&#125; 使用@include命令，调用这个mixin。 123div &#123; @include left;&#125; mixin的强大之处，在于可以指定参数和缺省值。 123456789101112@mixin left($value: 10px) &#123; float: left; margin-right: $value;&#125;``` 使用的时候，根据需要加入参数：```scssdiv &#123; @include left(20px);&#125; 下面是一个mixin的实例，用来生成浏览器前缀。 123456789101112131415161718192021222324@mixin rounded($vert, $horz, $radius: 10px) &#123; border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -moz-border-radius-#&#123;$vert&#125;#&#123;$horz&#125;: $radius; -webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius;&#125;``` 使用的时候，可以像下面这样调用：```scss#navbar li &#123; @include rounded(top, left); &#125;#footer &#123; @include rounded(top, left, 5px); &#125;``` ### 4.3 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。```scsslighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c 4.4 插入文件@import命令，用来插入外部文件。 1@import \"path/filename.scss\"; 如果插入的是.css文件，则等同于css的import命令。 1@import \"foo.css\"; 五、高级用法5.1 条件语句@if可以用来判断： 1234567891011121314p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125;&#125;``` 配套的还有@else命令：```scss@if lightness($color) &gt; 30% &#123; background-color: #000;&#125; @else &#123; background-color: #fff;&#125; 5.2 循环语句SASS支持for循环： 12345@for $i from 1 to 10 &#123; .border-#&#123;$i&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125;&#125; 也支持while循环： 12345$i: 6;@while $i &gt; 0 &#123; item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; each命令，作用与for类似： 12345@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url(\"/image/#&#123;$member&#125;.jpg\"); &#125;&#125; 5.3 自定义函数SASS允许用户编写自己的函数。 1234567@function double($n) &#123; @return $n * 2;&#125;#sidebar &#123; width: double(5px);&#125;","tags":[{"name":"Sass,CSS预编译","slug":"Sass-CSS预编译","permalink":"http://yoursite.com/tags/Sass-CSS预编译/"}]},{"title":"深入理解javascript之编写高质量javascript代码的基本要点","date":"2016-10-01T13:50:52.000Z","path":"2016/10/01/JavaScript/深入理解javascript之编写高质量javascript代码的基本要点/","text":"才华横溢的Stoyan Stefanov，在他写的由O’Reilly初版的新书《JavaScript Patterns》(JavaScript模式)中，我想要是为我们的读者贡献其摘要，那会是件很美妙的事情。具体一点就是编写高质量JavaScript的一些要素，例如避免全局变量，使用单变量声明，在循环中预缓存length(长度)，遵循代码阅读，以及更多。 此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写API文档、执行同行评审以及运行JSLint。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码，这些代码在几个月或是几年之后再回过头看看也是会觉得很自豪的。 书写可维护的代码(Writing Maintainable Code )软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要： 花时间学习和理解这个问题 化时间是了解应该解决的问题代码 还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。 另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。 你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如： bug是暴露的 新功能被添加到应用程序 程序在新的环境下工作（例如，市场上出现新想浏览器） 代码改变用途 代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言 由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。 可维护的代码意味着： 可读的 一致的 可预测的 看上去就像是同一个人写的 已记录 最小全局变量(Minimizing Globals)JavaScript通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。 每个JavaScript环境有一个全局对象，当你在任意的函数外面使用this的时候可以访问到。你创建的每一个全部变量都成了这个全局对象的属 性。在浏览器中，方便起见，该全局对象有个附加属性叫做window，此window(通常)指向该全局对象本身。下面的代码片段显示了如何在浏览器环境 中创建和访问的全局变量： 12345myglobal = \"hello\"; // 不推荐写法console.log(myglobal); // \"hello\"console.log(window.myglobal); // \"hello\"console.log(window[\"myglobal\"]); // \"hello\"console.log(this.myglobal); // \"hello\" 全局变量的问题全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。 web页面包含不是该页面开发者所写的代码也是比较常见的，例如： 第三方的JavaScript库 广告方的脚本代码 第三方用户跟踪和分析脚本代码 不同类型的小组件，标志和按钮 比方说，该第三方脚本定义了一个全局变量，叫做result；接着，在你的函数中也定义一个名为result的全局变量。其结果就是后面的变量覆盖前面的，第三方脚本就一下子嗝屁啦！ 因此，要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。在书中后面提到的一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。 由于JavaScript的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码：1234function sum(x, y) &#123; // 不推荐写法: 隐式全局变量 result = x + y; return result;&#125; 此段代码中的result没有声明。代码照样运作正常，但在调用函数后你最后的结果就多一个全局命名空间，这可以是一个问题的根源。 经验法则是始终使用var声明变量，正如改进版的sum()函数所演示的：1234function sum(x, y) &#123; var result = x + y; return result;&#125; 另一个创建隐式全局变量的反例就是使用任务链进行部分var声明。下面的片段中，a是本地变量但是b确实全局变量，这可能不是你希望发生的：12345// 反例，勿使用 function foo() &#123; var a = b = 0; // ...&#125; 此现象发生的原因在于这个从右到左的赋值，首先，是赋值表达式b = 0，此情况下b是未声明的。这个表达式的返回值是0，然后这个0就分配给了通过var定义的这个局部变量a。换句话说，就好比你输入了： 1var a = (b = 0); 如果你已经准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量，如：1234function foo() &#123; var a, b; // ... a = b = 0; // 两个均局部变量&#125; 然而，另外一个避免全局变量的原因是可移植性。如果你想你的代码在不同的环境下（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心大胆地使用，实际上对于有些情况并不适用）。 忘记var的副作用(Side Effects When Forgetting var)隐式全局变量和明确定义的全局变量间有些小的差异，就是通过delete操作符让变量未定义的能力。 通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。 无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。 这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过delete操作符删除的，而变量是不能的：123456789101112131415// 定义三个全局变量var global_var = 1;global_novar = 2; // 反面教材(function () &#123; global_fromfunc = 3; // 反面教材&#125;());// 试图删除delete global_var; // falsedelete global_novar; // truedelete global_fromfunc; // true// 测试该删除typeof global_var; // \"number\"typeof global_novar; // \"undefined\"typeof global_fromfunc; // \"undefined\" 在ES5严格模式下，未声明的变量（如在前面的代码片段中的两个反面教材）工作时会抛出一个错误。 访问全局对象(Access to the Global Object)在浏览器中，全局对象可以通过window属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的window标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：123var global = (function () &#123; return this;&#125;()); 这种方法可以随时获得全局对象，因为其在函数中被当做函数调用了（不是通过new构造），this总 是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。 单var形式（Single var Pattern）在函数顶部使用单var语句是比较有用的一种形式，其好处在于： 提供了一个单一的地方去寻找功能所需要的所有局部变量 防止变量在定义之前使用的逻辑错误 帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的… 少代码（类型啊传值啊单线完成） 单var形式长得就像下面这个样子：123456789function func() &#123; var a = 1, b = 2, sum = a + b, myobject = &#123;&#125;, i, j; // function body...&#125; 您可以使用一个var语句声明多个变量，并以逗号分隔。像这种初始化变量同时初始化值的做法是很好的。这样子可以防止逻辑错误（所有未初始化但声明的变量的初始值是undefined）和增加代码的可读性。在你看到代码后，你可以根据初始化的值知道这些变量大致的用途，例如是要当作对象呢还是当作整数来使。 你也可以在声明的时候做一些实际的工作，例如前面代码中的sum = a + b这个情况，另外一个例子就是当你使用DOM（文档对象模型）引用时，你可以使用单一的var把DOM引用一起指定为局部变量，就如下面代码所示的：12345function updateElement() &#123; var el = document.getElementById(\"result\"), style = el.style; // 使用el和style干点其他什么事...&#125; 预解析：var散布的问题(Hoisting: A Problem with Scattered vars)JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。看下面这个例子：12345678// 反例myname = \"global\"; // 全局变量function func() &#123; alert(myname); // \"undefined\" var myname = \"local\"; alert(myname); // \"local\"&#125;func(); 在这个例子中，你可能会以为第一个alert弹出的是”global”，第二个弹出”loacl”。这种期许是可以理解的，因为在第一个alert 的时候，myname未声明，此时函数肯定很自然而然地看全局变量myname，但是，实际上并不是这么工作的。第一个alert会弹 出”undefined”是因为myname被当做了函数的局部变量（尽管是之后声明的），所有的变量声明当被悬置到函数的顶部了。因此，为了避免这种混 乱，最好是预先声明你想使用的全部变量。 上面的代码片段执行的行为可能就像下面这样：12345678myname = \"global\"; // global variablefunction func() &#123; var myname; // 等同于 -&gt; var myname = undefined; alert(myname); // \"undefined\" myname = \"local\"; alert(myname); // \"local\"&#125;func(); 为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文 的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了”hoisting”这个概念， 这种ECMAScript标准中并未定义，通常用来描述行为。 for循环(for Loops)在for循环中，你可以循环取得数组或是数组类似对象的值，譬如arguments和HTMLCollection对象。通常的循环形式如下：1234// 次佳的循环for (var i = 0; i &lt; myarray.length; i++) &#123; // 使用myarray[i]做点什么&#125; 这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当myarray不是数组，而是一个HTMLCollection对象的时候。 HTMLCollections指的是DOM方法返回的对象，例如：123document.getElementsByName()document.getElementsByClassName()document.getElementsByTagName() 还有其他一些HTMLCollections，这些是在DOM标准之前引进并且现在还在使用的。有：1234document.images: 页面上所有的图片元素document.links : 所有a标签元素document.forms : 所有表单document.forms[0].elements : 页面上第一个表单中的所有域 集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。 这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的：123for (var i = 0, max = myarray.length; i &lt; max; i++) &#123; // 使用myarray[i]做点什么&#125; 这样，在这个循环过程中，你只检索了一次长度值。 在所有浏览器下，循环获取内容时缓存HTMLCollections的长度是更快的，2倍(Safari3)到190倍(IE7)之间。//zxx:此数据貌似很老，仅供参考 注意到，当你明确想要修改循环中的集合的时候（例如，添加更多的DOM元素），你可能更喜欢长度更新而不是常量。 伴随着单var形式，你可以把变量从循环中提出来，就像下面这样：123456789function looper() &#123; var i = 0, max, myarray = []; // ... for (i = 0, max = myarray.length; i &lt; max; i++) &#123; // 使用myarray[i]做点什么 &#125;&#125; 这种形式具有一致性的好处，因为你坚持了单一var形式。不足在于当重构代码的时候，复制和粘贴整个循环有点困难。例如，你从一个函数复制了一个循环到另一个函数，你不得不去确定你能够把i和max引入新的函数（如果在这里没有用的话，很有可能你要从原函数中把它们删掉）。 最后一个需要对循环进行调整的是使用下面表达式之一来替换i++。12i = i + 1i += 1 JSLint提示您这样做，原因是++和–-促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手如果你直接无视它，JSLint的plusplus选项会是false（默认是default）。 还有两种变化的形式，其又有了些微改进，因为： 少了一个变量(无max) 向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率123456789101112//第一种变化的形式：var i, myarray = [];for (i = myarray.length; i–-;) &#123; // 使用myarray[i]做点什么&#125;//第二种使用while循环：var myarray = [], i = myarray.length;while (i–-) &#123; // 使用myarray[i]做点什么&#125; 这些小的改进只体现在性能上，此外JSLint会对使用i–-加以抱怨。 for-in循环(for-in Loops)for-in循环应该用在非数组对象的遍历上，使用for-in进行循环也被称为“枚举”。 从技术上将，你可以使用for-in循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。 有个很重要的hasOwnProperty()方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。 思考下面一段代码：123456789101112// 对象var man = &#123; hands: 2, legs: 2, heads: 1&#125;;// 在代码的某个地方// 一个方法添加给了所有对象if (typeof Object.prototype.clone === \"undefined\") &#123; Object.prototype.clone = function () &#123;&#125;;&#125; 在这个例子中，我们有一个使用对象字面量定义的名叫man的对象。在man定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举man的时候出现clone()方法，你需要应用hasOwnProperty()方法过滤原型属性。如果不做过滤，会导致clone()函数显示出来，在大多数情况下这是不希望出现的。123456789101112131415161718192021222324// 1.// for-in 循环for (var i in man) &#123; if (man.hasOwnProperty(i)) &#123; // 过滤 console.log(i, \":\", man[i]); &#125;&#125;/* 控制台显示结果hands : 2legs : 2heads : 1*/// 2.// 反面例子:// for-in loop without checking hasOwnProperty()for (var i in man) &#123; console.log(i, \":\", man[i]);&#125;/*控制台显示结果hands : 2legs : 2heads : 1clone: function()*/ 另外一种使用hasOwnProperty()的形式是取消Object.prototype上的方法。像是：12345for (var i in man) &#123; if (Object.prototype.hasOwnProperty.call(man, i)) &#123; // 过滤 console.log(i, \":\", man[i]); &#125;&#125; 其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。123456var i, hasOwn = Object.prototype.hasOwnProperty;for (i in man) &#123; if (hasOwn.call(man, i)) &#123; // 过滤 console.log(i, \":\", man[i]); &#125;&#125; 严格来说，不使用hasOwnProperty()并不是一个错误。根据任务以及你对代码的自信程度，你可以跳过它以提高些许的循环速度。但是当你对当前对象内容（和其原型链）不确定的时候，添加hasOwnProperty()更加保险些。 格式化的变化（通不过JSLint）会直接忽略掉花括号，把if语句放到同一行上。其优点在于循环语句读起来就像一个完整的想法（每个元素都有一个自己的属性”X”，使用”X”干点什么）：12345// 警告： 通不过JSLint检测var i, hasOwn = Object.prototype.hasOwnProperty;for (i in man) if (hasOwn.call(man, i)) &#123; // 过滤 console.log(i, \":\", man[i]);&#125; （不）扩展内置原型((Not) Augmenting Built-in Prototypes)扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。 增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。 另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。 因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外： 可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。 如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。 你清楚地文档记录并和团队交流了变化。 如果这三个条件得到满足，你可以给原型进行自定义的添加，形式如下：12345if (typeof Object.protoype.myMethod !== \"function\") &#123; Object.protoype.myMethod = function () &#123; // 实现... &#125;;&#125; switch模式(switch Pattern)你可以通过类似下面形式的switch语句增强可读性和健壮性：123456789101112var inspect_me = 0, result = '';switch (inspect_me) &#123;case 0: result = \"zero\"; break;case 1: result = \"one\"; break;default: result = \"unknown\";&#125; 这个简单的例子中所遵循的风格约定如下： 每个case和switch对齐（花括号缩进规则除外） 每个case中代码缩进 每个case以break清除结束 避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。 以default结束switch：确保总有健全的结果，即使无情况匹配。 避免隐式类型转换(Avoiding Implied Typecasting )JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。123456789var zero = 0;if (zero === false) &#123; // 不执行，因为zero为0, 而不是false&#125;// 反面示例if (zero == false) &#123; // 执行了...&#125; 还有另外一种思想观点认为==就足够了===是多余的。例如，当你使用typeof你就知道它会返回一个字符串，所以没有使用严格相等的理由。然而，JSLint要求严格相等，它使代码看上去更有一致性，可以降低代码阅读时的精力消耗。（“==是故意的还是一个疏漏？”） 避免(Avoiding) eval()如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单：1234567// 反面示例var property = \"name\";alert(eval(\"obj.\" + property));// 更好的var property = \"name\";alert(obj[property]); 使用eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理Ajax请求得到的JSON 相应的时候。在这些情况下，最好使用JavaScript内置方法来解析JSON相应，以确保安全和有效。若浏览器不支持JSON.parse()，你可 以使用来自JSON.org的库。 同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。在幕后，JavaScript仍需要评估和执行你给程序传递的字符串：123456789// 反面示例setTimeout(\"myFunc()\", 1000);setTimeout(\"myFunc(1, 2, 3)\", 1000);// 更好的setTimeout(myFunc, 1000);setTimeout(function () &#123; myFunc(1, 2, 3);&#125;, 1000); 使用新的Function()构造就类似于eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用eval()，你 可以考虑使用new Function()代替。有一个小的潜在好处，因为在新Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。 考虑下面这个例子，这里仅un作为全局变量污染了命名空间。1234567891011121314console.log(typeof un); // \"undefined\"console.log(typeof deux); // \"undefined\"console.log(typeof trois); // \"undefined\"var jsstring = \"var un = 1; console.log(un);\";eval(jsstring); // logs \"1\"jsstring = \"var deux = 2; console.log(deux);\";new Function(jsstring)(); // logs \"2\"jsstring = \"var trois = 3; console.log(trois);\";(function () &#123; eval(jsstring);&#125;()); // logs \"3\"console.log(typeof un); // numberconsole.log(typeof deux); // \"undefined\"console.log(typeof trois); // \"undefined\" 另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。在下面这个例子中，eval()可以访问和修改它外部作用域中的变量，这是 Function做不来的（注意到使用Function和new Function是相同的）。12345678910(function () &#123; var local = 1; eval(\"local = 3; console.log(local)\"); // logs \"3\" console.log(local); // logs \"3\"&#125;());(function () &#123; var local = 1; Function(\"console.log(typeof local);\")(); // logs undefined&#125;()); parseInt()下的数值转换(Number Conversions with parseInt())使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数。1234var month = \"06\", year = \"09\";month = parseInt(month, 10);year = parseInt(year, 10); 此例中，如果你忽略了基数参数，如parseInt(year)，返回的值将是0，因为“09”被当做8进制（好比执行 parseInt( year, 8 )），而09在8进制中不是个有效数字。 替换方法是将字符串转换成数字，包括：12+\"08\" // 结果是 8Number(\"08\") // 8 这些通常快于parseInt()，因为parseInt()方法，顾名思意，不是简单地解析与转换。但是，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以NaN告终。 编码规范(Coding Conventions)建立和遵循编码规范是很重要的，这让你的代码保持一致性，可预测，更易于阅读和理解。一个新的开发者加入这个团队可以通读规范，理解其它团队成员书写的代码，更快上手干活。 许多激烈的争论发生会议上或是邮件列表上，问题往往针对某些代码规范的特定方面（例如代码缩进，是Tab制表符键还是space空格键）。如果你是 你组织中建议采用规范的，准备好面对各种反对的或是听起来不同但很强烈的观点。要记住，建立和坚定不移地遵循规范要比纠结于规范的细节重要的多。 缩进(Indentation)代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。 一些开发人员更喜欢用tab制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，使用四个空格缩进，这也是JSLint中默认的缩进。 什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do, while, for, for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例：12345678910111213141516171819function outer(a, b) &#123; var c = 1, d = 2, inner; if (a &gt; b) &#123; inner = function () &#123; return &#123; r: c - d &#125;; &#125;; &#125; else &#123; inner = function () &#123; return &#123; r: c + d &#125;; &#125;; &#125; return inner;&#125; 花括号{}(Curly Braces)花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在in或是for中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。 想象下你有一个只有一条语句的for循环，你可以忽略花括号，而没有解析的错误。123// 糟糕的实例for (var i = 0; i &lt; 10; i += 1) alert(i);&lt;/pre&gt; 但是，如果，后来，主体循环部分又增加了行代码？1234// 糟糕的实例for (var i = 0; i &lt; 10; i += 1) alert(i); alert(i + \" is \" + (i % 2 ? \"odd\" : \"even\")); 第二个alert已经在循环之外，缩进可能欺骗了你。为了长远打算，最好总是使用花括号，即时值一行代码：1234// 好的实例for (var i = 0; i &lt; 10; i += 1) &#123; alert(i);&#125; if条件类似：123456789101112// 坏if (true) alert(1);else alert(2);// 好if (true) &#123; alert(1);&#125; else &#123; alert(2);&#125; 左花括号的位置(Opening Brace Location)开发人员对于左大括号的位置有着不同的偏好——在同一行或是下一行。123456789if (true) &#123; alert(\"It's TRUE!\");&#125;//或if (true)&#123; alert(\"It's TRUE!\");&#125; 这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript是不挑剔的，当你选择不使用分号结束一行代码时JavaScript会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候：1234567// 警告： 意外的返回值function func() &#123; return // 下面代码不执行 &#123; name : \"Batman\" &#125;&#125; 如果你希望函数返回一个含有name属性的对象，你会惊讶。由于隐含分号，函数返回undefined。前面的代码等价于：1234567// 警告： 意外的返回值function func() &#123; return undefined; // 下面代码不执行 &#123; name : \"Batman\" &#125;&#125; 总之，总是使用花括号，并始终把在与之前的语句放在同一行：12345function func() &#123; return &#123; name : \"Batman\" &#125;;&#125; 关于分号注：就像使用花括号，你应该总是使用分号，即使他们可由JavaScript解析器隐式创建。这不仅促进更科学和更严格的代码，而且有助于解决存有疑惑的地方，就如前面的例子显示。 空格(White Space)空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在JavaScript中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。 适合使用空格的地方包括： for循环分号分开后的的部分：如for (var i = 0; i &lt; 10; i += 1) {...} for循环中初始化的多变量(i和max)：for (var i = 0, max = 10; i &lt; max; i += 1) {...} 分隔数组项的逗号的后面：var a = [1, 2, 3]; 对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = {a: 1, b: 2}; 限定函数参数：myFunc(a, b, c) 函数声明的花括号的前面：function myFunc() {} 匿名函数表达式function的后面：var myFunc = function () {}; 使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=等前后都需要空格。12345678910111213141516171819// 宽松一致的间距// 使代码更易读// 使得更加“透气”var d = 0, a = b + 1;if (a &amp;&amp; b &amp;&amp; c) &#123; d = a % c; a += d;&#125;// 反面例子// 缺失或间距不一// 使代码变得疑惑var d = 0, a = b + 1;if (a&amp;&amp;b&amp;&amp;c) &#123; d=a % c; a+= d;&#125; 最后需要注意的一个空格——花括号间距。最好使用空格： 函数、if-else语句、循环、对象字面量的左花括号的前面({) else或while之间的右花括号(}) 空格使用的一点不足就是增加了文件的大小，但是压缩无此问题。 有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。 命名规范(Naming Conventions)另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。 下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。 以大写字母写构造函数(Capitalizing Constructors)JavaScript并没有类，但有new调用的构造函数：1var adam = new Person(); 因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。 命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用：12function MyConstructor() &#123;...&#125;function myFunction() &#123;...&#125; 分隔单词(Separating Words)当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。 对于构造函数，可以使用大驼峰式命名法(upper camel case)，如MyConstructor()。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是myFunction(),calculateArea()和getFirstName()。 要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，first_name, favorite_bands,和old_company_name，这种标记法帮你直观地区分函数和其他标识——原型和对象。 ECMAScript的属性和方法均使用Camel标记法，尽管多字的属性名称是罕见的（正则表达式对象的lastIndex和ignoreCase属性）。 其它命名形式(Other Naming Patterns)有时，开发人员使用命名规范来弥补或替代语言特性。 例如，JavaScript中没有定义常量的方法（尽管有些内置的像Number, MAX_VALUE），所以开发者都采用全部单词大写的规范来命名这个程序生命周期中都不会改变的变量，如：123// 珍贵常数，只可远观var PI = 3.14, MAX_WIDTH = 800; 还有另外一个完全大写的惯例：全局变量名字全部大写。全部大写命名全局变量可以加强减小全局变量数量的实践，同时让它们易于区分。 另外一种使用规范来模拟功能的是私有成员。虽然可以在JavaScript中实现真正的私有，但是开发者发现仅仅使用一个下划线前缀来表示一个私有属性或方法会更容易些。考虑下面的例子：123456789101112var person = &#123; getName: function () &#123; return this._getFirst() + ' ' + this._getLast(); &#125;, _getFirst: function () &#123; // ... &#125;, _getLast: function () &#123; // ... &#125;&#125;; 在此例中，getName()就表示公共方法，部分稳定的API。而_getFirst()和_getLast()则表明了私有。它们仍然是正常的公共方法，但是使用下划线前缀来警告person对象的使用者这些方法在下一个版本中时不能保证工作的，是不能直接使用的。注意，JSLint有些不鸟下划线前缀，除非你设置了noman选项为:false。 下面是一些常见的_private规范： 使用尾下划线表示私有，如name_和getElements_() 使用一个下划线前缀表_protected（保护）属性，两个下划线前缀表示__private （私有）属性 Firefox中一些内置的变量属性不属于该语言的技术部分，使用两个前下划线和两个后下划线表示，如：__proto__和__parent__。 注释(Writing Comments)你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。 很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。 最重要的习惯，然而也是最难遵守的，就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。 关于作者（About the Author ）Stoyan Stefanov是Yahoo!web开发人员，多个O’Reilly书籍的作者、投稿者和技术评审。他经常在会议和他的博客www.phpied.com上发表web开发主题的演讲。Stoyan还是smush.it图片优化工具的创造者，YUI贡献者，雅虎性能优化工具YSlow 2.0的架构设计师。 本文转自：http://www.zhangxinxu.com/wordpress/?p=1173 英文原文：http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"node的安装和npm的简单介绍","date":"2016-03-05T16:00:00.000Z","path":"2016/03/06/Framework/Node/node的安装和npm的简单介绍/","text":"下载nodejs打开nodejs官网，你会看到两个绿色的按钮，一个是目前大多数人在用的，一个是目前最新的版本，的需要下载即可，它会根据系统信息选择对应版本（.msi文件）。然后像安装QQ一样安装它就可以了（安装路径随意） 检测nodejs是否安装上了打开命令提示符执行下列命令（打开方式：window + r 输入cmd回车）： node -v查看安装的nodejs版本，出现版本号，说明刚刚已正确安装nodejs。 npm -v查看npm的版本号，npm是在安装nodejs时一同安装的nodejs包管理器。 如果输入命令后告诉你node不是内部命令，那么请看下步配置环境变量 如果上述都能正常执行，恭喜你，安装成功了 配置环境变量 找到nodejs的安装目录，拷贝路径地址，默认是（C:\\Program Files\\nodejs） 找到桌面我的电脑图标，右键点击属性菜单弹出系统面板 点击系统面板的高级系统设置，弹出系统属性面板 点击属性面板的环境变量按钮，弹出环境变量面板 找到系统变量的path，双击，将nodejs的bin目录url添加到后面即可注意：在添加的时候确保前面有一个英文的分号 配置完之后继续输入命令，查看node和npm的版本npm介绍npm官网 说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）； 使用npm安装插件：命令提示符执行npm install &lt;name&gt; [-g] [--save-dev]； &lt;name&gt;：node插件名称。例：npm install gulp-less --save-dev -g：全局安装。将会安装C:\\Users\\Administrator\\AppData\\Roaming\\npm，并且写入系统环境变量； 非全局安装：将会安装在当前定位目录； 全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用； --save：将保存配置信息至package.json（package.json是nodejs项目配置文件）； -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；一般保存在dependencies的像这些express/ejs/body-parser等等。 为什么要保存至package.json？因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install --production 只下载dependencies节点的包）。 使用npm卸载插件：npm uninstall &lt;name&gt; [-g] [--save-dev] PS：不要直接删除本地插件包 删除全部插件：npm uninstall gulp-less gulp-uglify gulp-concat ……???太麻烦，请看下一个 借助rimraf：npm install rimraf -g 用法：rimraf node_modules 使用npm更新插件：npm update &lt;name&gt; [-g] [--save-dev] 更新全部插件：npm update [--save-dev] 查看npm帮助：npm help 当前目录已安装插件：npm listPS：npm安装插件过程：从 http://registry.npmjs.org 下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法往下看↓↓↓↓↓↓。 选装cnpm 说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。32个赞！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”； 官方网址：http://npm.taobao.org； 安装：命令提示符执行npm install cnpm -g --registry=https://registry.npm.taobao.org； 注意：安装完后最好查看其版本号 cnpm -v 或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"hexo图片链接问题","date":"2015-03-14T13:03:08.000Z","path":"2015/03/14/Hexo/hexo图片链接问题/","text":"文章转载自 http://www.tuicool.com/articles/umEBVfI 1. 起因在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。 这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。 hexo 下插入图片现在大概有几个方案 1.1 放在根目录早期大部分的方案是把图片放在 source/img 下，然后在 markdown 里写 ![img](/source/img/img.png) 。显然这样在本地的编辑器里完全不能正确识别图片的位置。 1.2 asset-image在 hexo 2.x 时出现的插件，后来被吸纳进 hexo 3 core ，用法的介绍见 资源文件夹 | Hexo 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 的语法。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。 2. 解决方案CodeFalling/hexo-asset-image 2.1 使用首先确认_config.yml 中有 post_asset_folder:true 。 在 hexo 目录，执行1npm install https://github.com/CodeFalling/hexo-asset-image --save 假设在 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg) 就可以插入图片。 生成的结构为12345public/2015/10/18/MacGesture2-Publish├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是1&lt;img src=\"/2015/10/18/MacGesture2-Publish/logo.jpg\" alt=\"logo\"&gt; 而不是愚蠢的1&lt;img src=\"MacGesture2-Publish/logo.jpg\" alt=\"logo\"&gt; 值得一提的是，这个插件对于 CodeFalling/hexo-renderer-org 同样有效。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"javascript之变量","date":"2015-03-10T13:40:20.000Z","path":"2015/03/10/JavaScript/javascript之变量/","text":"变量的定义在javascript中定义变脸是通过关键字 var、function 定义的，在ES6中还可以用let、const 的方式定义变量123456var str = &quot;hello world&quot;; // 定义了一个值为“hello world”的String类型变量var num = 10; // 定义了一个值为10的Number类型变量var boolean = true; // 定义了一个值为true的Boolean类型变量function ()&#123; // 定义一个Function类型，名为fn的函数 // 函数体&#125; javascript变量命名规范 规则（必须遵守） 由字母、数字、下划线、$组成 不能是关键字和保留字 区分大小写 规范（建议遵守） 变量的名称要有意义 变量的命名遵守驼峰命名法，首字母小写，第二个单词的首字母大写（eg：userName） 变量类型基本数据类型Number类型 整数 十进制 八进制 1) 如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当做十进制数值解析 十六进制 浮点数 小数 科学计数法 浮点数的最高精度是17位小数，但在进行算数计算时其精度远远不如整数 var result = 0.1 + 0.2;//结果不等于0.3，而是0.300000000000000004 永远不要测试某个特定的浮点数值（不要判断两个浮点数是否相等） 数值范围 最小值：Number.MIN_VALUE，这个值为：5e-324 最大值：Number.MAX_VALUE，这个值为：1.7976931348623157e+308 无穷大：Infinity 无穷小：-infinity 数值检测 NaN非数值（Not a Number） NaN与任何值都不相等，包括自身 isNaN( 值 )：任何不能被转换为数值的值都会导致这个函数返回true String类型 字符串字面量 字符串要用引号引起，单引号和双引号的作用是等效的 字符串是由一个个字符组成的，获取一个字符串的长度可以使用length属性 转义符 字符串的不可变—-&gt;其他类型重新赋值直接在内存上修改，字符串的修改要重新申请内存 ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变 要改变某个变量保存的字符串，需要重新开辟内存空间，然后修改变量的地址指向，之前的地址会被javascript垃圾回收机制不定时回收 如果两个字符串变量值相同，则指向相同的内存地址 123var a = \"hello\";var b = \"hello\";console.log(a === b); //true 把字符串当做数组看的话，修改字符串的某个字符（按下标访问），并不能够修改该字符串，说明字符串不可变 字符串类型是存储在堆内存中的 字符串拼接，字符串变量相加会把变量的值连接起来 Boolean类型 false、true 区分大小写 虽然只有两个值，但是所有类型中都有有着两个值等价的值 其他类型转换为布尔值 Undefined类型 表示变量未赋值 只有一种值就是undefined undefined是Undefined类型的字面量 类型转换 目标：掌握三种类型的转换 转换成字符串类型 转换成数值类型 转换成布尔类型 转换成字符串类型 toString()方法——变量.toString() 变量.toString()，转换成字符串 数值类型的toString(进制数)—&gt;将数值类型转换成几进制数值字符串 null和undefined没有toString()方法 String()方法——String（变量）- 存在的意义：有些值没有toString()方法，这个时候可以用String()方法，比如undefined和null 字符串拼接—&gt; + 转换成数值类型 Number()：可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN 可以把true和false转换成 1和0 如果是空字符串，会转换成0 parseInt()：把字符串转换成整数 会忽略前面的空格，直到找到第一个字符串为止，还会将后面的非数字字符串去掉 “ 123abc”会转换成123， 如果第一个字符不是数字或者正负号，返回NaN “abc123”会转换成NaN “-123”会转换为-123-“+123”会转换为123 可以传递两个参数 要转换的字符串 第二个是要转换的数原先为几进制数，在2到36之间，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 parseFloat()：把字符串转换成浮点数 转换方式与parseInt一样 parseInt()和parseFloat()的区别 parseFloat()会解析第一个，遇到第二个或者非数字结束 parseFloat()不支持第二个参数，只能解析10进制数 parseFloat()如果解析的内容里只有整数，解析成整数 10.00会被解析成10 转换成布尔类型——Boolean（变量） Boolean()方法 流程控制语句会把后面的值隐式转换成布尔类型 “ ！ ”运算符 转换成为false的值：false、””、0、和NaN、null、undefined 隐式转换 转number +、-、*、/、%都会把变量转换成number类型 +号的隐式转换必须写在变量的前面：eg: +”a” 、 +”undefined”、+”NaN” 转string var a = 123; a = a + “”; 转boolean var a = 123; a = !a; 复杂数据类型ObjectFunction####","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript之基本介绍","date":"2015-03-05T13:23:08.000Z","path":"2015/03/05/JavaScript/javascript之基本介绍/","text":"javascript语言特点 javascript是一门弱类型、动态类型、解析型的脚本语言 弱类型：定义变量不需要指定变量类型 动态类型： 执行时才知道变量到底是什么类型 对象想要有属性或方法，直接 . 或者[“属性名”]就可以 解析型：一行一行解析，解析一行执行一行 脚本语言：不需要编译，直接运行时边解析边执行的语言 编译：一次性把代码转换成cpu可以看懂的语言，一行一行执行，执行速度快 解释：一行一行解析，解析一行执行一行，执行速度慢 javascript是一种客户端的脚本语言 浏览器的工作原理 浏览器基本组成 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的你请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。 渲染引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码，比如chrome的javascript解释器是V8。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5)定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 详细文章请移步 javascript组成部分 ECMAScript： javascript的语法规范 DOM： javascript操作网页上元素的API BOM： javascript操作浏览器部分功能的API javascript的使用方式 内嵌式（html页面编写javascript代码） 123&lt;script type=\"text/javascript\"&gt; // 你的javascript代码&lt;/script&gt; 外联式（在js文件中编写javascript代码，在html页面中引入js文件） src：引入文件的地址 type：引入的文件类型 写法一：type=”text/javascript” 写法二：language=”javascript” async：异步 交给浏览器去异步下载，不会阻塞程序的执行 js文件下载完就可以立马执行 sync：同步 只能一个任务一个任务的执行会阻塞程序的执行 defer： 等html文档加载并显示完之后才执行下载完的js代码 只有外部脚本才可以使用 1&lt;script src=\"/javascripts/application.js\" type=\"text/javascript\" charset=\"utf-8\" async defer&gt;&lt;/script&gt; 内联式（在html标签中编写javascript代码）1&lt;input type=\"buttom\" onclick=\"function()&#123;&#125;\"&gt; javascript注释注释的应用 - 一般用于解释某些复杂代码的逻辑，方便后期的维护与开发 - 用于对整个模块进行分割划分，方便于代码查找和维护 - 用于：模块、函数、复杂逻辑注释、文件注解、维护记录等 12345//单行注释/*多行注释*//** * 注解内容 */ 好了，现在你可以开始编写你的javascript代码了","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"Hello World","date":"2015-03-01T13:50:52.000Z","path":"2015/03/01/Hexo/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]