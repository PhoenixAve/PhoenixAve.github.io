[{"title":"Gulp和Webpack对比","date":"2017-03-18T13:50:52.000Z","path":"2017/03/18/Framework/Webpack/Gulp和Webpack对比/","text":"原文 http://chping.website/2016/10/18/gulp和webpack对比/ 在现在的前端开发中，前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等等一些原本后端的思想开始逐渐渗透到“大前端”的开发中。前端开发过程越来越繁琐，当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且Webapp通常是一个单页面应用(SPA)，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。 前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 本文需要有一定的 Gulp 和 Webpack 的基本概念，对Gulp和Webpack的使用有一定的了解。 同时还需要对npm或者cnpm有一定的的了解，对ComonJS、AMD规范有一定的的了解。 GulpGulp 就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。说的形象点，“Gulp就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。” 另外，Gulp是通过task对整个开发过程进行构建。 WebpackWebpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS 等。 Gulp和Webpack功能实现对比简单介绍了一下Gulp和Webpack的概念性的问题和大环境，接下来进入本文的主题，对比一下Gulp和Webpack的优缺点。将从基本概念、启动本地Server、sass/less预编译、模块化开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。 基本概念首先从概念上，我们可以清楚的看出，Gulp和Webpack的侧重点是不同的。 Gulp侧重于前端开发的 整个过程 的控制管理（像是流水线），我们可以通过给gulp配置不通的task（通过Gulp中的gulp.task()方法配置，比如启动server、sass/less预编译、文件的合并压缩等等）来让gulp实现不同的功能，从而构建整个前端开发流程。 Webpack有人也称之为 模块打包机 ，由此也可以看出Webpack更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js文件、css文件等）都可以看成模块，最初Webpack本身就是为前端JS代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack是通过loader（加载器）和plugins（插件）对资源进行处理的。 另外我们知道Gulp是对整个过程进行控制，所以在其配置文件（gulpfile.js）中配置的每一个task对项目中 该task配置路径下所有的资源 都可以管理。 比如，对sass文件进行预编译的task可以对其配置路径下的所有sass文件进行预编译处理：12345gulp.task('sass',function()&#123; gulp.src('src/styles/*.scss') .pipe(sass().on('error',sass.logError)) .pipe(gulp.dest('./build/prd/styles/'));//编译后的输出路径&#125;); 上面这个task可以对 &#39;src/styles/*.scss&#39; 目录下的所有以 .scss 结尾的文件进行预处理。 Webpack则不是这样管理资源的，它是根据模块的 依赖关系 进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源(如下图)。 通俗的说，Webpack就是需要通过其配置文件（webpack.config.js）中 entry 配置的一个入口文件（JS文件）,如下图123entry: &#123; app:__dirname + \"/src/scripts/app.js\",&#125; 然后Webpack进入该 app.js 文件进行解析， app.js 文件如下图：123456//引入scss文件import'../style/app.scss';//引入依赖模块vargreeter =require('./Greeter.js');document.getElementById('root').appendChild(greeter()); 解析过程中，发现一个 app.scss 文件，然后根据 webpack.config.js 配置文件中的 module.loaders 属性去查找处理 .scss 文件的loader进行处理，处理 app.scss 文件过程中，如果发现该文件还有其他依赖文件，则继续处理 app.scss 文件的依赖文件，直至处理完成该“链路”上的依赖文件，然后又遇到一个 Greeter.js 模块，于是像之前一样继续去查找对应的loader去处理… 所以，Webpack中对资源文件的处理是通过入口文件产生的依赖形成的，不会像Gulp那样，配置好路径后，该路径下所有规定的文件都会受影响。 模块化开发所谓的前端模块化开发，我的理解就是，在开发的时候，把不通的资源文件按照他的具体用途进行分类管理，在使用的时候利用CommonJS、AMD、CMD等规范将这些资源文件引入到当前文件中。然后在测试或者最后上线的时候，将这些资源文件按照一定的要求进行压缩合并再加上版本控制处理。 可能这样的理解或者说法值得商榷，但是个人还是觉得模块化就是对内容的管理，是为了解耦合。 首先从Gulp入手，看看在项目中，怎样利用模块化的思想进行开发。下面是一个gulp项目的目录结构： 123456789101112131415161718192021Gulp |——build: 项目输出路径 | |——prd: css、js文件输出路径 | |——scripts: js文件的输出路径 | |——styles: css文件的输出路径 | |——ver: 版本号相关文件 | |——index.html: 编译后的index.html |——images: 图片文件夹 |——mock: mock数据文件夹 |——node_modules: npm包管理文件夹 |——src: 工作目录 | |——scripts | |——libs: 第三方依赖库（jQuery等） | |——tpls: 模板文件 | |——utils: 工具类文件夹 | |——views: 页面自定义js文件 | |——app.js: index.html文件的入口js | |——styles：文件和scripts文件夹下基本一致（本例中我引用了第三方框架，目录更深，不在展示） |——gulpfile.js: gulp的配置文件 |——index.html: 主页html文件 |——package.json: npm包管理配置文件 在实际开发过程中，在src目录下工作，html、js和css等文件通过gulp的task配置，执行合并和压缩后输出到build目录下（下面会详细介绍合并压缩的实现）。在详细一点就是： 创建主页html文件 创建与之对应的app.js入口文件和app.scss入口文件。这两个文件只通过CommonJS规范 引入各自views文件中自定义的js(或scss)文件 ，具体逻辑不写此文件中。 在views目录下编写js（或css）文件的逻辑代码，其中如果多个文件需要公共逻辑或者工具方法，就可以抽离出来在util文件夹下创建对应的公共方法，然后在views中需要的js（或css）文件中通过CommonJS规范引入使用。libs目录下的第三方库或框架也是这个思想去引用。 scripts目录下的tpls文件是用来放置html模板的，引用方式和引用libs相同。 大体介绍了一下我理解的模块化的思想，但是需要指出的是Gulp对js文件的模块化工作是通过Webpack实现的，具体来说是通过安装 gulp-webpack 模块和相关的 loader 模块进行js模块化管理的。具体步骤如下： 在项目中通过npm安装一个 gulp-webpack 、 vinyl-named 、 imports-loader 和 string-loader 模块(压缩合并模块后面再介绍) 1$ npm install gulp-webpack vinyl-named -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-webpack 模块，并进行简单配置 123456789101112131415161718192021222324252627282930313233343536//1.引入 gulp-webpack和vinyl-named模块varwebpack=require('gulp-webpack');varwebpack=require('vinyl-named');//2.js 模块化配置varjsFiles = ['./src/scripts/*.js', ]; gulp.task('packjs',function()&#123; gulp.src(jsFiles) .pipe(uglify().on('error',function(err)&#123;console.log('\\x07',err.lineNumber,err.message);returnthis.end(); &#125;))//Webpack 对js模块化部分 start .pipe(webpack(&#123; output:&#123; filename:'[name].js' &#125;,module:&#123; loaders:[&#123; test: /\\.js$/, loader:'imports?define=&gt;false' &#125;, &#123; test:/\\.string$/, loader:'string' &#125; ] &#125; &#125;));//Webpack 对js模块化部分 end .pipe(concat('all.js')) .pipe(gulp.dest('./build/prd/scripts/'));&#125;); 对css文件我们也采用同js文件一样的模块化思想，利用sass进行模块化开发，至于对scss文件的合并压缩配置，下面还会详细介绍。 接下来应该介绍一下Webpack的模块化实现了，其实也就没什么可以说的了，文件目录和Gulp的基本相同，只不过实现过程中使用到的插件或者说模块不同，配置不同而已。另外需要注意的是，Webpack对于资源文件的模块化打包处理都是按js文件的处理方式处理的，例如还是上一小节中，你可能发现了，我在 app.js 入口文件中有这样一行代码1import'../style/app.scss'; 你当时可能产生疑问，为什么在js文件中引入scss文件呢？ 这是因为Webpack是通过依赖关系进行文件管理的，所以，想要对样式文件进行模块化管理则必须与 app.js 入口文件建立依赖关系，因此我们将样式文件的入口 app.scss 文件引入到了 app.js 中（其他资源想要被管理，也需要这样与 app.js 入口文件建立依赖关系）。 但是这样做很明显的就是样式文件通过 app.js 入口文件全部都合并压缩到js文件中了，这很显然不是我们想要的结果，所以我们需要将样式文件从js文件中剥离出来。 在项目中通过npm安装一个 extract-text-webpack-plugin 的模块 1$ npm install extract-text-webpack-plugin -D 然后在Webpack的配置文件webpack.config.js中进行简单配置 1234567891011121314151617181920212223242526272829303132333435//1.引入extract-text-webpack-plugin模块varEt =require('extract-text-webpack-plugin');module.exports = &#123;//source-map调试 devtool: 'eval-source-map',//webpack入口文件配置 entry: &#123; app:__dirname + \"/src/scripts/app.js\", &#125;,//webpack出口文件配置 output: &#123; path: __dirname + \"/prd/scripts/\",//输出文件路径配置 filename: \"bundle.js\"//输出文件名配置 &#125;,module:&#123; loaders:[ &#123; test: /\\.scss$/, loader: Et.extract('style','css!sass')//从js中抽离scss文件 &#125; ] &#125;, plugins: [newEt('./styles/bundle.css'),//从js中抽离scss文件输出目录设置 ],//本地server配置 devServer: &#123; contentBase: __dirname + '/prd/',//本地服务器所加载的页面所在的目录 port:8089,//本地服务端口配置 colors: true,//终端中输出结果为彩色 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;&#125; 上面有些配置信息并不完全，下面的小节中会逐渐介绍到。这样我们就实现了将css文件从js文件中剥离出来的目的。Webpack不但可以对css文件可以进行模块化管理，还可以对图片进行模块管理，有兴趣的可以自己去尝试一下。 文件合并与压缩上面的模块化中，我们提到了模块化其实很大一部分是在做文件的合并与压缩操作，所以我们马上来看看Gulp和Webpack是怎样是想文件的合并和压缩的。 先来看看大背景，由于现在前端越来越庞大，页面文件依赖也越来越多，所以对这些文件进行合理的合并和压缩就志在必得。根据前面的了解，Webpack应该比Gulp更擅长文件合并和压缩，毕竟人家被称为 模块打包机 吗。 结论是正确的，Gulp可以对css文件以及js文件进行合并压缩处理，而Webpack可以实现对css文件，js文件，html文件等进行合并压缩和图片的压缩，还可以对js文件进行编译（如es6–&gt;es5，react jsx）等等，这些都是通过Webpack的 loader 实现的，当然这些也可以加入到Gulp中，毕竟Gulp把Webpack当做一个模块，通过 gulp-webpack 都引入了。 Gulp合并压缩文件css的压缩要想实现Gulp对css文件的压缩只需要安装一个 gulp-minify-css 模块即可。 在项目中通过npm安装一个 gulp-minify-css 的模块 1$ npm install gulp-minify-css -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-minify-css模块，并进行简单配置 12345678910111213//1.引入 gulp-minify-css模块varminifyCSS =require('gulp-minify-css');//2.css 预处理varcssFiles = ['./src/styles/usage/page/index.scss']gulp.task('sass',function()&#123; gulp.src(cssFiles) .pipe(sass().on('error',sass.logError)) .pipe(minifyCSS())//执行压缩处理在一行 .pipe(gulp.dest('./build/prd/styles/'));&#125;); 这样一个简单的css压缩就实现了。 js合并压缩要想实现Gulp对js文件的合并压缩需要安装一个 gulp-uglify 和 gulp-concat 两个模块，前者是用于压缩的模块，后者是一个合并的模块。 在项目中通过npm安装 gulp-uglify 和 gulp-concat 模块 1$ npm install gulp-uglify gulp-concat -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入 gulp-uglify 和 gulp-concat 模块，并进行简单配置 1234567891011121314151617181920212223242526272829303132333435//1.引入**gulp-uglify**和**gulp-concat**模块varuglify =require('gulp-uglify');varconcat =require('gulp-concat');//js 合并压缩varjsFiles = ['./src/scripts/*.js', ]; gulp.task('packjs',function()&#123; gulp.src(jsFiles)//js文件的压缩 .pipe(uglify().on('error',function(err)&#123;console.log('\\x07',err.lineNumber,err.message);returnthis.end(); &#125;)) .pipe(webpack(&#123; output:&#123; filename:'[name].js' &#125;,module:&#123; loaders:[&#123; test: /\\.js$/, loader:'imports?define=&gt;false' &#125;, &#123; test:/\\.string$/, loader:'string' &#125; ] &#125; &#125;));//js文件的合并 .pipe(concat('all.js')) .pipe(gulp.dest('./build/prd/scripts/'));&#125;); js的文件合并压缩也完成了。我们再来看一下Webpack的合并压缩。 Webpack的合并压缩压缩js和css针对js和css文件的压缩，Webpack已经内嵌了uglifyJS来完成对js与css的压缩混淆，无需引用额外的插件。我们只需要在Webpack配置文件中的plugins属性中做如下配置：12345678plugins: [ newwebpack.optimize.UglifyJsPlugin(&#123;//压缩代码 compress: &#123; warnings: false &#125;, except: ['$super','/pre&gt;,'exports','require']//排除关键字 &#125;)] 需要注意的是：压缩的时候需要排除一些关键字，不能混淆，比如$或者require，如果混淆的话就会影响到代码的正常运行。 html的压缩想要对html进行压缩，同样也是需要配置Webpack的配置文件，并且需要下载两个插件 HtmlWebpackPlugin 和 html-minifier 插件： 1.在项目中通过npm安装 HtmlWebpackPlugin 和 html-minifier 模块12$ npm install HtmlWebpackPlugin -D$ npm install html-minifier -D 2.然后在Webpack的配置文件webpack.config.js进行如下配置：12345678910111213plugins: [ newHtmlWebpackPlugin(&#123;//根据模板插入css/js等生成最终HTML favicon:'./src/img/favicon.ico',//favicon路径 filename:'/view/index.html',//生成的html存放路径 template:'./src/view/index.html',//html模板路径 inject:true,//允许插件修改哪些内容，包括head与body hash:true,//为静态资源生成hash值 minify:&#123; //压缩HTML文件 removeComments:true,//移除HTML中的注释 collapseWhitespace:true//删除空白符与换行符 &#125; &#125;)] HtmlWebpackPlugin插件在生成HTML时调用了 html-minifier 插件来完成对HTML的压缩，这里我们使用两个配置完成来移除HTML中的注释以及空白符达到压缩的效果。 sass/less预编译我们再来看看sass/less预编译，其实就sass/less的预编译来说，两者区别不是很大。Gulp是通过 gulp-sass 、 gulp-less 模块进行预处理；而Webpack是通过 scss-loader 、 less-loader 加载器（loader）进行预处理。我们还是分别来看一下两者对此的实现。 Gulp预编译sass/less以sass为例子： 在项目中通过npm安装一个 gulp-sass 的模块 1$ npm install gulp-sass -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-sass模块，并进行简单配置 1234567891011121314151617181920212223//1.引入 gulp-sass模块var sass=require('gulp-sass');//2.css 预处理var cssFiles = [ './src/styles/usage/page/**/*' //./src/styles/usage/page目录下的所有文件];gulp.task('sass',function()&#123; gulp.src(cssFiles) .pipe(sass().on('error',sass.logError)) .pipe(minifyCSS()) .pipe(gulp.dest('./build/prd/styles/'));//编译后的输出路径 &#125;);//3.对sass文件的修改添加监听事件gulp.task('watch',function()&#123; gulp.watch('./src/styles/**/*',['sass']);&#125;);gulp.task('default',['watch','webserver'],function()&#123; console.log('所有任务队列执行完毕');&#125;); 这样，一个简单的sass预处理的task就配置完成了，然后我们还将该task加到gulp.watch()上实现了自动编译（即修改sass文件后保存，则立即执行sass预处理），配合Gulp启动的server则可以实现sass文件修改保存即可在浏览器中查看效果的目的，下一小节会介绍启动本地server。 Webpack预编译sass/less同样以sass为例子： 在项目中通过npm安装一个 sass-loader 和 node-sass 模块，前者是用来加载sass相关文件的，后者是用来编译sass文件的。另外还需要安装另外两个模块 css-loader 和 style-loader ，前者是用来加载css相关文件的，后者是用来将css样式装填到html中的内联样式。 1$ npm install sass-loader node-sass css-loader style-sass -D 然后在Webpack的配置文件webpack.config.js中进行简单配置 123456789101112module:&#123; loaders:[ &#123; test: /\\.css$/,//匹配以.css结尾的文件，如果你项目不需要刻意不配置 loader: 'style!css'//这里顺序必须这样 &#125;, &#123; test: /\\.scss$/,//匹配以.scss结尾的文件 loader: 'style!css!sass' &#125; ]&#125; 前面提到过，Webpack是通过文件的依赖关系进行加载分析的，所以当程序从主入口（js文件）进入后，在依赖的资源文件中发现有sass文件后，就会利用我们配置的 sass-loader 去加载，然后用 node-sass 去解析编译成普通的css语法的样式文件，在然后就是利用 style-loader 将样式以内联样式的形式配置到html中（这里有一个问题，就是css-loader有什么用?我也没搞明白，但是不添加会报错，有知道的可以留言交流一下）。这样Webpack就完成了sass的预处理。 启动server我们都知道在前端开发中，ajax请求是需要启动一个server的。特别是在前后端分离思想中，前端开发不再像以前一样过分依赖于后端开发，以前的那种前端测试ajax请求需要装个tomcat或者其它服务器来启动server的现象已经成为过去式，现在我们可以使用像Gulp这类前端自动构建工具启动一个本地server进行测试，再也不收后端程序员钳制了（开个玩笑，和后端好好沟通才能让前端开发更方便）。那么，我们来分别看一下Gulp和Webpack是怎样实现这个功能的。 Gulp启动server在Gulp中想要启动一个本地serve，只需要以下几步： 在项目中通过npm安装一个 gulp-webserver 的模块 1$ npm install gulp-webserver -D 然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-webserver模块，并进行简单配置 1234567891011121314151617181920212223//1.引入 gulp-webserver 模块varwebserver =require('gulp-webserver');//2.配置server taskgulp.task('webserver',function()&#123; gulp.src('./') .pipe(webserver(&#123; host:'localhost', port:80, //浏览器自动刷新 livereload:true, //显示文件目录 directoryListing:&#123; enable: true, path:'./' &#125;, &#125;));&#125;);//3.配置默认taskgulp.task('default',['webserver'],function()&#123; console.log('启动任务队列执行完毕');&#125;) 在命令行中启动server 1$ gulp 启动成功： 在浏览器地址栏中输入 localhost 打开页面验证。 经过以上这三步，我们就在Gulp中启动了一个server了。在Gulp中启动本地服务有一个很方便的配置，就是 livereload:true 属性的设置，设置后浏览器会根据你项目中资源的变化自动刷新浏览器（如果你的chrome浏览器设置该属性后在你修改文件并保存时仍没有自动刷新，可能是你的chrome浏览器不支持，可以chrome扩展程序中搜索并安装LiveReload插件），比如： 我的gulp测试目录结构： index.html1234567891011&lt;!DOCTYPE html&gt;&lt;htmllang=\"en\"&gt; &lt;head&gt; &lt;metacharset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;scriptsrc=\"/src/scripts/app.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我在app.js文件中输入以下内容，然后保存。1console.log('gulp-webserver livereload'); 浏览器中控制台上会立刻打印出一下信息： 说明浏览器自动刷新工程，这个小功能在我们开发中屡试不爽。但是，这个功能是需要结合上一小节中的 gulp.watch() 实时监控文件变化，然后执行合并压缩和sass/less编译等操作后，浏览器再刷新时才能保证是我们修改后的内容。所以， livereload:true 属性只是监控到我们修改文件后刷新浏览器重新请求文件，如果我们不重新编译修改后的文件，浏览器获取到的还是原文件，并不会展示变化。 Webpack启动server在Webpack中也可以通过插件的形式安装一个 webpack-dev-server 来实现达到启动本地server的目的，具体步骤如下： 在项目中通过npm安装一个 webpack-dev-server 的模块 1$ npm install -g webpack-dev-server -D 然后在Webpack的配置文件webpack.config.js中进行简单配置 1234567891011121314151617181920module.exports = &#123; devtool: 'eval-source-map', //webpack入口文件配置 entry: &#123; app:__dirname + \"/src/scripts/app.js\", &#125;, //webpack出口文件配置 output: &#123; path: __dirname + \"/prd/scripts/\",//输出文件路径配置 filename: \"bundle.js\"//输出文件名配置 &#125;, //本地server配置 devServer: &#123; contentBase: __dirname,//本地服务器所加载的页面所在的目录 port:8089,//本地服务端口配置 colors: true,//终端中输出结果为彩色 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;&#125; 在命令行中启动server 1$ webpack-dev-server 然后你就会看见命令行输出内容很多，只要看看保证没有Error就说明成功了。 在浏览器地址栏中输入 localhost：8089 测试一下。 Webpack的启动本地服务也顺利实现了，是不是也想实现像Gulp一样浏览器自动刷新呀？那Webpack能不能实现呢？答案是肯定的，Webpack官方提供了一个辅助开发工具，它可以自动监控项目下的文件，一旦有修改保存操作，开发服务器就会自动运行Webpack 打包命令，帮我们自动将开发的代码重新打包。而且，如果需要的话，还能自动刷新浏览器，重新加载资源。理论上好像是这样，但是实现好像有不少限制，比如，HTML文件的自动刷新问题（html-webpack-plugin插件使用老是报错），当本地server启动在非output.path路径之外时则不能自动刷新等问题，等我再学习学习再说，或者有知道的可以留言讨论。 而这个辅助工具就是 webpack-dev-server ，它主要提供两个功能：一是为静态文件提供server服务，二是自动刷新和热替换(HMR)。所以想实现如Gulp一样的功能也是可以的，只需要在 $ webpack-dev-server 后面添加 --inline --hot 即可。需要注意的是 --inline 是自动刷新，同时在第二部中的devServer属性中有一个 inline:true 需要配置；而 --hot 是热替换（ 详细了解热替换、 了解webpack-dev-server 、 webpack-dev-server ）。 通过对比来看，好像Webpack的 webpack-dev-server 比Gulp的 gulp-server 功能要强一些。因为通过上面可以看出 webpack-dev-server 有两个大功能：一是为静态文件提供server服务，二是自动刷新（ 自动刷新其实需要两步：1.修改文件后，文件自动编译{包括合并压缩或者语法编译等}，2.刷新浏览器请求最新编译后的文件 ）和热替换(HMR)；而 gulp-server 虽然提供了启动本地server的能力和仅自动刷新浏览器的能力，缺少一个文件自动编译的能力，这需要借助其他模块实现（上一小节已介绍，结合gulp.watch()实时监控文件变化，并编译）。 另外需要注意的是，实际开发中发现 webpack-dev-server 实现自动刷新的时候，并没有执行自动编译，只是将修改的内容合并压缩等处理后发送给了浏览器，并造成了已经编译的现象，但是通过build/prd/scripts目录下的bundle.js(合并压缩后的输出文件)文件，可以发现内容并没有编译（对于Webpack还是不熟悉，好多问题等待解决）。 mock数据在现在前后端分离的思想中，前端和后端耦合度越来越小，现在唯一需要前后端密切联系的就是借口的定义和数据格式的确定。一般在项目开始前，前端和后端将项目中的接口和数据格式全部确定下来（当然项目需求变更就需要临时确立这些共识了），然后前端就可以自己mock数据了。 Gulp实现mock数据Gulp中对mock数据的实现使通过NodeJS内置的fs模块和url模块实现的，因为Gulp本身就是基于NodeJS的。还记得第一小节“模块化开发”中目录结构中的那个mock目录吗？那就是用来储存 .json 文件的mock数据目录。 配置Gulp的gulpfile.js文件1234567891011121314151617181920212223242526272829303132333435//1.引入 fs 和 url 模块varfs =require('fs');varurl =require('url');//2.重新配置一下上一小节的servergulp.task('webserver',function()&#123; gulp.src('./') .pipe(webserver(&#123; host:'localhost', port:80, livereload:true, directoryListing:&#123; enable: true, path:'./' &#125;, //mock数据配置 middleware:function(req,res,next)&#123; varurlObj = url.parse(req.url,true); switch(urlObj.pathname) &#123; case'/pro/getPro': res.setHeader('Content-Type','application/json;charaset=utf-8'); fs.readFile('./mock/list.json',function(err,data)&#123; //上面list.json路径使用相对路径，绝对路径前台无法获取数据 res.end(data); &#125;); return; case'/web/getUser': //.... return; &#125; next(); &#125; &#125;));&#125;); 具体来说，就是通过NodeJS拦截http请求，根据请求URL来模拟后端做出处理后返回不同的数据。 Webpack实现mock数据完善中。。。 版本控制对于版本控制，我们在开发过程中，也是一个使用比较频繁的功能，特别是开发团队比较大的时候，这个功能就显得更加重要了。那么Gulp和Webpack是具体怎样实现的呢？ Gulp实现版本控制 在项目中通过npm安装 gulp-rev 和 gulp-rev-collector 模块，前者用于生成文件的MD5码文件和按MD5码命名的资源文件，后者是利用MD5码，对文件名进行替换。 1$ npm install gulp-rev gulp-rev-collector -D 然后在Gulp的配置文件gulpfile.js中进行简单配置 12345678910111213141516171819202122//1.引入连个模块varrev =require('gulp-rev');varrevCollector =require('gulp-rev-collector');// 2.版本号控制 gulp.task('ver',function()&#123; gulp.src(cssFiles) .pipe(rev())//产生MD5码 .pipe(gulp.dest('./build/prd/styles/'))//重命名文件 .pipe(rev.manifest())//产生版本信息的json文件 .pipe(gulp.dest('./build/ver/styles/')); gulp.src(jsFiles) .pipe(rev()) .pipe(gulp.dest('./build/prd/scripts/')) .pipe(rev.manifest()) .pipe(gulp.dest('./build/ver/scripts/')); &#125;)//动态修改html中对css和js文件的修改 gulp.task('html',function()&#123; gulp.src(['./build/ver/**/*','./build/*.html']) .pipe(revCollector()) .pipe(gulp.dest('./build/'));&#125;) Gulp实现版本控制很方便，将这两个task加入gulp.watch()中，即可实现修改保存文件实时自动修改版本的功能。 Webpack实现版本控制Webpack中需要版本控制的有css、js文件，不过Webpack的版本控制只实现了将css、js文件添加hash值方式命名的文件方式，修改引用路径中的文件名需手动实现。 不过实现确实很简单，只需要将webpack.config.js配置文件中的output.filename和plugins中的输出文件名称修改一下即可。12345678910111213module.exports = &#123; devtool: 'eval-source-map', entry: &#123; app: __dirname + \"/src/scripts/app.js\", &#125;, output: &#123; path: __dirname + \"/prd/scripts/\", filename: \"[name]-[hash].js\"//修改输出文件名 &#125;, plugins: [ newEt('./styles/[name]-[hash].css'),//修改输出文件名 ]&#125; 这样就解决了。 组件控制组件控制原本应该放在模块化小节或者前后小节，但是由于实在不知道该怎样比较，其实也没啥可比较的，就放在最后了。 Gulp和Webpack对各自组件的管理都是使用的npm进行的组件管理，想了解更多npm组件的管理的可自行百度，或者看看这篇文章入个门《npm介绍》。 总结通过以上八个方面的功能对比，Gulp和Webpack基本都能满足前端自动化构建工具的任务，但是还是看出两个工具的侧重点是不通的，Gulp侧重整个过程的控制，Webpack在模块打包方面有特别出众。所以，Gulp + Webpack 组合使用可能更方便。 很长的一篇总结文章，前前后后花了两天时间终于写完了，还有很多测试没做，并且还有很多疑问没解决。慢慢学习，慢慢在补充修改吧。","tags":[{"name":"Webpack,Gulp","slug":"Webpack-Gulp","permalink":"http://yoursite.com/tags/Webpack-Gulp/"}]},{"title":"CSS命名规范——BEM思想","date":"2017-03-15T13:40:20.000Z","path":"2017/03/15/Others/CSS命名规范——BEM思想/","text":"转载自CSS命名规范——BEM思想（非常赞的规范） 人们问我最多的问题之一是在CSS类名中--和__是什么意思？它们的出现是源于BEM和Nicolas Gallagher… BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。 重要的是要注意，我使用的基于BEM的命名方式是经过Nicolas Gallagher修改过的。这篇文章中介绍的这种命名技术并不是原始的BEM，但却是一个我更喜欢的改进版。无论实际使用了什么样的符号，它们其实都是基于同样的BEM原则。 命名约定的模式如下：123.block&#123;&#125; .block__element&#123;&#125; .block--modifier&#123;&#125; .block 代表了更高级别的抽象或组件。 .block__element 代表.block的后代，用于形成一个完整的.block的整体。 .block--modifier代表.block的不同状态或不同版本。 之所以使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定，如：123.site-search&#123;&#125; /* 块 */ .site-search__field&#123;&#125; /* 元素 */ .site-search--full&#123;&#125; /* 修饰符 */ BEM的关键是光凭名字就可以告诉其他开发者某个标记是用来干什么的。通过浏览HTML代码中的class属性，你就能够明白模块之间是如何关联的：有一些仅仅是组件，有一些则是这些组件的子孙或者是元素,还有一些是组件的其他形态或者是修饰符。我们用一个类比/模型来思考一下下面的这些元素是怎么关联的：12345.person&#123;&#125; .person__hand&#123;&#125; .person--female&#123;&#125; .person--female__hand&#123;&#125; .person__hand--left&#123;&#125; 顶级块是‘person’，它拥有一些元素，如‘hand’。一个人也会有其他形态，比如女性，这种形态进而也会拥有它自己的元素。下面我们把他们写成‘常规’CSS:12345.person&#123;&#125; .hand&#123;&#125; .female&#123;&#125; .female-hand&#123;&#125; .left-hand&#123;&#125; 这些‘常规’CSS都是有意义的，但是它们之间却有些脱节。就拿.female来说，是指女性人类还是某种雌性的动物？还有.hand，是在说一只钟表的指针（译注：英文中hand有指针的意思）？还是一只正在玩纸牌的手？使用BEM我们可以获得更多的描述和更加清晰的结构，单单通过我们代码中的命名就能知道元素之间的关联。BEM真是强大。 再来看一个之前用‘常规’方式命名的.site-search的例子：1234&lt;form class=\"site-search full\"&gt; &lt;input type=\"text\" class=\"field\"&gt; &lt;input type=\"Submit\" value =\"Search\" class=\"button\"&gt; &lt;/form&gt; 这些CSS类名真是太不精确了，并不能告诉我们足够的信息。尽管我们可以用它们来完成工作，但它们确实非常含糊不清。用BEM记号法就会是下面这个样子：1234&lt;form class=\"site-search site-search--full\"&gt; &lt;input type=\"text\" class=\"site-search__field\"&gt; &lt;input type=\"Submit\" value =\"Search\" class=\"site-search__button\"&gt; &lt;/form&gt; 我们能清晰地看到有个叫.site-search的块，他内部是一个叫.site-search__field的元素。并且.site-search还有另外一种形态叫.site-search–full。 我们再来举个例子…… 如果你熟悉OOCSS（面向对象CSS），那么你对media对象一定也不陌生。用BEM的方式，media对象就会是下面这个样子：1234.media&#123;&#125; .media__img&#123;&#125; .media__img--rev&#123;&#125; .media__body&#123;&#125; 从这种CSS的写法上我们就已经知道.mediaimg 和.mediabody一定是位于.media内部的，而且.mediaimg–rev是.mediaimg的另一种形态。仅仅通过CSS选择器的名字我们就能获取到以上全部信息。 BEM的另外一个好处是针对下面这种情况：1234567&lt;div class=\"media\"&gt; &lt;img src=\"logo.png\" alt=\"Foo Corp logo\" class=\"img-rev\"&gt; &lt;div class=\"body\"&gt; &lt;h3 class=\"alpha\"&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=\"lede\"&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 光从上面的代码来看，我们根本不明白.media和.alpha两个class彼此之间是如何相互关联的？同样我们也无从知晓.body和.lede之间，或者.img-rev 和.media之间各是什么关系？从这段HTML（除非你对那个media对象非常了解）中我们也不知道这个组件是由什么组成的和它还有什么其他的形态。如果我们用BEM方式重写这段代码：1234567&lt;div class=\"media\"&gt; &lt;img src=\"logo.png\" alt=\"Foo Corp logo\" class=\"media__img--rev\"&gt; &lt;div class=\"media__body\"&gt; &lt;h3 class=\"alpha\"&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=\"lede\"&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 我们立马就能明白.media是一个块，.media__img–rev是一个加了修饰符的.media__img的变体，它是属于.media的元素。而.media__body是一个尚未被改变过的也是属于.media的元素。所有以上这些信息都通过它们的class名称就能明白，由此看来BEM确实非常实用。 丑极了！通常人们会认为BEM这种写法难看。我敢说，如果你仅仅是因为这种代码看上去不怎么好看而羞于使用它，那么你将错失最重要的东西。除非使用BEM让代码增加了不必要的维护困难，或者这么做确实让代码更难读了，那么你在使用它之前就要三思而行了。但是，如果只是“看起来有点怪”而事实上是一种有效的手段，那么我们在开发之前当然应该充分考虑它。 是，BEM看上去确实怪怪的，但是它的好处远远超过它外观上的那点瑕疵。 BEM可能看上去有点滑稽，而且有可能导致我们输入更长的文本（大部分编辑器都有自动补全功能，而且gzip压缩将会让我们消除对文件体积的担忧），但是它依旧强大。 用还是不用BEM?我在我的所有项目中都使用了BEM记号法，因为它的有效性已经被它自己一次又一次地证明。我也极力地建议别人使用BEM，因为它让所有东西之间的联系变得更加紧密，让团队甚至是你个人都能够更加容易地维护代码。 然而，当你真正使用BEM的时候，重要的是，请记住你没必要真的在每个地方都用上它。比如：1.caps&#123; text-transform:uppercase; &#125; 这条CSS不属于任何一个BEM范畴，它仅仅只是一条单独的样式。 另一个没有使用BEM的例子是：1.site-logo&#123;&#125; 这是一个logo，我们可以把它写成BEM格式，像下面这样：12.header&#123;&#125; .header__logo&#123;&#125; 但我们没必要这么做。使用BEM的诀窍是，你要知道什么时候哪些东西是应该写成BEM格式的。因为某些东西确实是位于一个块的内部，但这并不意味它就是BEM中所说的元素。这个例子中，网站logo完全是恰巧在.header的内部，它也有可能在侧边栏或是页脚里面。一个元素的范围可能开始于任何上下文，因此你要确定只在你需要用到BEM的地方你才使用它。再看一个例子：123&lt;div class=\"content\"&gt; &lt;h1 class=\"content__headline\"&gt;Lorem ipsum dolor...&lt;/h1&gt; &lt;/div&gt; 在这个例子里，我们也许仅仅只需要另一个class，可以叫它.headline；它的样式取决于它是如何被层叠的，因为它在.content的内部；或者它只是恰巧在.content的内部。如果它是后者（即恰巧在.content的内部，而不总是在）我们就不需要使用BEM。 然而，一切都有可能潜在地用到BEM。我们再来看一下.site-logo的例子，想象一下我们想要给网站增加一点圣诞节的气氛，所以我们想有一个圣诞版的logo。于是我们有了下面的代码：12.site-logo&#123;&#125; .site-logo--xmas&#123;&#125; 我们可以通过使用–修饰符来快速地为我们的代码构建另一个版本。 BEM最难的部分之一是明确作用域是从哪开始和到哪结束的，以及什么时候使用（不使用）它。随着接触的多了，有了经验积累，你慢慢就会知道怎么用，这些问题也不再是问题。 结束语所以，BEM（或BEM的变体）是一个非常有用，强大，简单的命名约定，以至于让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确而且更加严密。 尽管BEM看上去多少有点奇怪，但是无论什么项目，它对前端开发者都是一个巨有价值的工具。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"webpack的使用","date":"2017-03-12T16:00:00.000Z","path":"2017/03/13/Framework/Webpack/webpack/","text":"原文地址 Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 前言现状伴随着移动互联的大潮，当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。 前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 模块系统的演进模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统。 &lt;script&gt;标签1234&lt;script src=\"module1.js\"&gt;&lt;/script&gt;&lt;script src=\"module2.js\"&gt;&lt;/script&gt;&lt;script src=\"libraryA.js\"&gt;&lt;/script&gt;&lt;script src=\"module3.js\"&gt;&lt;/script&gt; 这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 YUI 库。 这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突 文件只能按照&lt;script&gt; 的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonJS服务器端的 Node.js 遵循 CommonJS规范，该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。1234require(\"module\");require(\"../file.js\");exports.doStuff = function() &#123;&#125;;module.exports = someValue; 优点： 服务器端模块便于重用 NPM 中已经有将近20万个可以使用模块包 简单并容易使用 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 实现： 服务器端的 Node.js Browserify，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大 modules-webmake，类似Browserify，还不如 Browserify 灵活 wreq，Browserify 的前身 AMDAsynchronous Module Definition 规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。1234define(\"module\", [\"dep1\", \"dep2\"], function(d1, d2) &#123; return someExportedValue;&#125;);require([\"module\", \"../file\"], function(module, file) &#123; /* ... */ &#125;); 优点： 适合在浏览器环境中异步加载模块 可以并行加载多个模块 缺点： 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅 不符合通用的模块化思维方式，是一种妥协的实现 实现： RequireJS curl CMDCommon Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。123456define(function(require, exports, module) &#123; var $ = require('jquery'); var Spinning = require('./spinning'); exports.doSomething = ... module.exports = ...&#125;) 优点： 依赖就近，延迟执行 可以很容易在 Node.js 中运行 缺点： 依赖 SPM 打包，模块的加载逻辑偏重 实现： Sea.js coolie UMDUniversal Module Definition 规范类似于兼容 CommonJS 和 AMD 的语法糖，是模块定义的跨平台解决方案。 ES6 模块EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。123import \"jquery\";export function doStuff() &#123;&#125;module \"localModule\" &#123;&#125; 优点： 容易进行静态分析 面向未来的 EcmaScript 标准 缺点： 原生浏览器端还没有实现该标准 全新的命令字，新版的 Node.js才支持 实现： Babe 期望的模块系统可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。 前端模块加载前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。 模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。 分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。 要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。 所有资源都是模块在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。 如果他们都可以视作模块，并且都可以通过require的方式来加载，将带来优雅的开发体验，比如：1234require(\"./style.css\");require(\"./style.less\");require(\"./template.jade\");require(\"./image.png\"); 那么如何做到让 require 能加载各种资源呢？ 静态分析在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用 LESS 写的样式模块，可以先用 LESS 加载器将它转成一个CSS 模块，在通过 CSS 模块把他插入到页面的 &lt;style&gt; 标签中执行。Webpack 就是在这样的需求中应运而生。 同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们还需要一个模块加载的兼容策略，来避免重写所有的模块。 那么接下来，让我们开始 Webpack 的神奇之旅吧。 什么是webpackWebpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 为什么重复造轮子市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。 这些已有的模块化工具并不能很好的完成如下的目标： 将依赖树拆分成按需加载的块 初始化加载的耗时尽量少 各种静态资源都可以视作模块 将第三方库整合成模块的能力 可以自定义打包逻辑的能力 适合大项目，无论是单页还是多页的 Web 应用 Webpack 的特点Webpack 和其他模块化工具有什么区别呢？ 代码拆分Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 LoaderWebpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。 插件系统Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 准备开始我们通过具体案例来快速上手 Webpack。以下章节中的案例源码可以在 https://github.com/zhaoda/webpack-handbook/tree/master/examples/start 查看。 安装首先要安装 Node.js， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。 用 npm 安装 Webpack：1$ npm install webpack -g 此时 Webpack 已经安装到了全局环境下，可以通过命令行 webpack -h 试试。 通常我们会将 Webpack 安装到项目的依赖中，这样就可以使用项目本地版本的 Webpack。1234# 进入项目目录# 确定已经有 package.json，没有就通过 npm init 创建# 安装 webpack 依赖$ npm install webpack --save-dev Webpack 目前有两个主版本，一个是在 master 主干的稳定版，一个是在 webpack-2 分支的测试版，测试版拥有一些实验性功能并且和稳定版不兼容，在正式项目中应该使用稳定版。12345# 查看 webpack 版本信息$ npm info webpack# 安装指定版本的 webpack$ npm install webpack@1.12.x --save-dev 如果需要使用 Webpack 开发工具，要单独安装：1$ npm install webpack-dev-server --save-dev 使用首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：123456789&lt;!-- index.html --&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12// entry.jsdocument.write('It works.') 然后编译 entry.js 并打包到 bundle.js：1$ webpack entry.js bundle.js 打包过程会显示日志：123456Hash: e964f90ec65eb2c29bb9Version: webpack 1.12.2Time: 54ms Asset Size Chunks Chunk Namesbundle.js 1.42 kB 0 [emitted] main [0] ./entry.js 27 bytes &#123;0&#125; [built] 用浏览器打开 index.html 将会看到 It works. 。 接下来添加一个模块 module.js 并修改入口 entry.js：12// module.jsmodule.exports = 'It works from module.js.' 123// entry.jsdocument.write('It works.')document.write(require('./module.js')) // 添加模块 重新打包 webpack entry.js bundle.js 后刷新页面看到变化 It works.It works from module.js.1234567Hash: 279c7601d5d08396e751Version: webpack 1.12.2Time: 63ms Asset Size Chunks Chunk Namesbundle.js 1.57 kB 0 [emitted] main [0] ./entry.js 66 bytes &#123;0&#125; [built] [1] ./module.js 43 bytes &#123;0&#125; [built] Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。 LoaderWebpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。 先来看看 loader 有哪些特性？ Loader 可以通过管道方式链式调用，每个 loader 可以把资源转换成任意格式并传递给下一个 loader ，但是最后一个 loader 必须返回 JavaScript。 Loader 可以同步或异步执行。 Loader 运行在 node.js 环境中，所以可以做任何可能的事情。 Loader 可以接受参数，以此来传递配置项给 loader。 Loader 可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。 Loader 可以通过 npm 发布和安装。 除了通过 package.json 的 main 指定，通常的模块也可以导出一个 loader 来使用。 Loader 可以访问配置。 插件可以让 loader 拥有更多特性。 Loader 可以分发出附加的任意文件。 Loader 本身也是运行在 node.js 环境中的 JavaScript 模块，它通常会返回一个函数。大多数情况下，我们通过 npm 来管理 loader，但是你也可以在项目中自己写 loader 模块。 按照惯例，而非必须，loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。 在引用 loader 的时候可以使用全名 json-loader，或者使用短名 json。这个命名规则和搜索优先级顺序在 webpack 的 resolveLoader.moduleTemplates api 中定义。1Default: [&quot;*-webpack-loader&quot;, &quot;*-web-loader&quot;, &quot;*-loader&quot;, &quot;*&quot;] Loader 可以在 require() 引用模块的时候添加，也可以在 webpack 全局配置中进行绑定，还可以通过命令行的方式使用。 接上一节的例子，我们要在页面中引入一个 CSS 文件 style.css，首页将 style.css 也看成是一个模块，然后用 css-loader 来读取它，再用 style-loader 把它插入到页面中。12/* style.css */body &#123; background: yellow; &#125; 修改 entry.js：123require(\"!style-loader!css-loader!./style.css\") // 载入 style.cssdocument.write('It works.')document.write(require('./module.js')) 安装 loader：1npm install css-loader style-loader 重新编译打包，刷新页面，就可以看到黄色的页面背景了。 如果每次 require CSS 文件的时候都要写 loader 前缀，是一件很繁琐的事情。我们可以根据模块类型（扩展名）来自动绑定需要的 loader。 将 entry.js 中的 require(&quot;!style!css!./style.css&quot;) 修改为 require(&quot;./style.css&quot;) ，然后执行：1234$ webpack entry.js bundle.js --module-bind 'css=style-loader!css-loader'# 有些环境下可能需要使用双引号$ webpack entry.js bundle.js --module-bind \"css=style-loader!css-loader\" 显然，这两种使用 loader 的方式，效果是一样的。 配置文件Webpack 在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的 webpack.config.js 文件，这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 –config 选项来指定配置文件。 继续我们的案例，在根目录创建 package.json 来添加 webpack 需要的依赖：12345678910111213141516171819&#123; \"name\": \"webpack-example\", \"version\": \"1.0.0\", \"description\": \"A simple webpack example.\", \"main\": \"bundle.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"webpack\" ], \"author\": \"zhaoda\", \"license\": \"MIT\", \"devDependencies\": &#123; \"css-loader\": \"^0.21.0\", \"style-loader\": \"^0.13.0\", \"webpack\": \"^1.12.2\" &#125;&#125; 123# 如果没有写入权限，请尝试如下代码更改权限chflags -R nouchg .sudo chmod 775 package.json 别忘了运行 npm install。 然后创建一个配置文件 webpack.config.js：1234567891011121314var webpack = require('webpack')module.exports = &#123; entry: './entry.js', output: &#123; path: \\_\\_dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;&#125; 同时简化 entry.js 中的 style.css 加载方式： require(‘./style.css’)最后运行 webpack，可以看到 webpack 通过配置文件执行的结果和上一章节通过命令行 webpack entry.js bundle.js --module-bind &#39;css=style-loader!css-loader&#39; 执行的结果是一样的。 插件插件可以完成更多 loader 不能完成的功能。 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。 Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件。 接下来，我们利用一个最简单的 BannerPlugin 内置插件来实践插件的配置和运行，这个插件的作用是给输出的文件头部添加注释信息。 修改 webpack.config.js，添加 plugins：1234567891011121314151617var webpack = require('webpack')module.exports = &#123; entry: './entry.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;, plugins: [ new webpack.BannerPlugin('This file is created by zhaoda') ]&#125; 然后运行 webpack，打开 bundle.js，可以看到文件头部出现了我们指定的注释信息：12345/*! This file is created by zhaoda *//******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;// 后面代码省略 开发环境当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。1$ webpack --progress --colors 如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。1$ webpack --progress --colors --watch 当然，使用 webpack-dev-server 开发服务是一个更好的选择。它将在 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开 http://localhost:8080/ 或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。12345# 安装$ npm install webpack-dev-server -g# 运行$ webpack-dev-server --progress --colors 故障处理Webpack 的配置比较复杂，很容出现错误，下面是一些通常的故障处理手段。 一般情况下，webpack 如果出问题，会打印一些简单的错误信息，比如模块没有找到。我们还可以通过参数 --display-error-details 来打印错误详情。12345678910111213141516171819202122232425262728$ webpack --display-error-detailsHash: a40fbc6d852c51fceadbVersion: webpack 1.12.2Time: 586ms Asset Size Chunks Chunk Namesbundle.js 12.1 kB 0 [emitted] main [0] ./entry.js 153 bytes &#123;0&#125; [built] [1 error] [5] ./module.js 43 bytes &#123;0&#125; [built] + 4 hidden modulesERROR in ./entry.jsModule not found: Error: Cannot resolve 'file' or 'directory' ./badpathmodule in /Users/zhaoda/data/projects/webpack-handbook/examplesresolve file /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json doesn't existresolve directory /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist (directory default file) /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule/package.json doesn't exist (directory description file)[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json] @ ./entry.js 3:0-26 Webpack 的配置提供了 resolve 和 resolveLoader 参数来设置模块解析的处理细节，resolve 用来配置应用层的模块（要被打包的模块）解析，resolveLoader 用来配置 loader 模块的解析。 当引入通过 npm 安装的 node.js 模块时，可能出现找不到依赖的错误。Node.js 模块的依赖解析算法很简单，是通过查看模块的每一层父目录中的 node_modules 文件夹来查询依赖的。当出现 Node.js 模块依赖查找失败的时候，可以尝试设置 resolve.fallback 和 resolveLoader.fallback 来解决问题。1234module.exports = &#123; resolve: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;, resolveLoader: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;&#125;; Webpack 中涉及路径配置最好使用绝对路径，建议通过 path.resolve(__dirname, &quot;app/folder&quot;) 或 path.join(__dirname, &quot;app&quot;, &quot;folder&quot;) 的方式来配置，以兼容 Windows 环境。 高级以下章节是进阶内容。 CommonJS 规范CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。 这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 ServerJS。 我在这里描述的并不是一个技术问题，而是一件重大的事情，让大家走到一起来做决定，迈出第一步，来建立一个更大更酷的东西。 —— Kevin Dangoor’s What Server Side JavaScript needs 2009年8月，这个项目改名为 CommonJS，以显示其 API 的更广泛实用性。CommonJS 是一套规范，它的创建和核准是开放的。这个规范已经有很多版本和具体实现。CommonJS 并不是属于 ECMAScript TC39 小组的工作，但 TC39 中的一些成员参与 CommonJS 的制定。2013年5月，Node.js 的包管理器 NPM 的作者 Isaac Z. Schlueter 说 CommonJS 已经过时，Node.js 的内核开发者已经废弃了该规范。 CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。 一个直观的例子：1234// moduleA.jsmodule.exports = function( value )&#123; return value * 2;&#125; 123// moduleB.jsvar multiplyBy2 = require('./moduleA');var result = multiplyBy2(4); CommonJS 是同步加载模块，但其实也有浏览器端的实现，其原理是现将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 的源码来理解其解析（resolve）的过程。 更多关于 CommonJS 规范的内容请查看 http://wiki.commonjs.org/wiki/CommonJS。 AMD 规范AMD（异步模块定义）是为浏览器环境设计的，因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件。 AMD 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。 模块通过 define 函数定义在闭包中，格式如下：1define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。1define(function(require, exports, module) &#123;&#125;） factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 一些用例： 定义一个名为 myModule 的模块，它依赖 jQuery 模块：123456define('myModule', ['jquery'], function($) &#123; // $ 是 jquery 模块的输出 $('body').text('hello world');&#125;);// 使用define(['myModule'], function(myModule) &#123;&#125;); 注意：在 webpack 中，模块名只有局部作用域，在 Require.js 中模块名是全局作用域，可以在全局引用。 定义一个没有 id 值的匿名模块，通常作为应用的启动函数：123define(['jquery'], function($) &#123; $('body').text('hello world');&#125;); 依赖多个模块的定义：1234define(['jquery', './math.js'], function($, math) &#123; // $ 和 math 一次传入 factory $('body').text('hello world');&#125;); 模块输出：123456789define(['jquery'], function($) &#123; var HelloWorldize = function(selector)&#123; $(selector).text('hello world'); &#125;; // HelloWorldize 是该模块输出的对外接口 return HelloWorldize;&#125;); 在模块定义内部引用依赖：1234define(function(require) &#123; var $ = require('jquery'); $('body').text('hello world');&#125;); 参考链接模块规范CommonJS 规范Asynchronous Module DefinitionCommon Module DefinitionCMD 模块定义规范Universal Module DefinitionECMAScript 6 Module什么是 AMD、 CommonJS、 UMD关于 CommonJS AMD CMD UMD为什么我推荐 requirejs 而不是 seajsAMD 和 CMD 的区别有哪些前端模块化开发的价值What Server Side JavaScript needs 模块系统RequireJScurlSea.jscoolieBrowserifymodules-webmakewreq WebpackWebpack 官方文档React Webpack cookbook 编译Babel","tags":[{"name":"webpack,打包工具","slug":"webpack-打包工具","permalink":"http://yoursite.com/tags/webpack-打包工具/"}]},{"title":"mongodb的安装、配置与基本使用","date":"2017-03-11T16:00:00.000Z","path":"2017/03/12/DataBase/mongodb/mongodb的安装、配置与基本使用/","text":"相关网址MongoDB官网:https://www.mongodb.com/下载地址:https://www.mongodb.com/download-center?jmp=nav#community菜鸟教程：http://www.runoob.com/mongodb/mongodb-tutorial.html 为什么选择MongoDB?1.只要会js/json就会mongodb(学习成本低)2.mongodb对js的兼容性最好3.mongodb存数据就是存json 安装与配置 MongoDB 数据库环境安装mongodb在官网下载，直接安装即可，默认下一步直到完成 验证安装成功：在cmd终端中输入： mongo --version 或是 mongod --version ,能看到版本好,说明安装成功如果终端中输入 mongo –version 提示找不到命令,一定要看看是不是没有配置mongodb的环境变量,并且配置环境变量之后一定要记得重启cmd 配置环境变量我的电脑右键–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量–&gt;path添加mongodb的安装目录的bin目录到最后即可 window7安装MongoDB存在的问题建议:升级到window10解决步骤: 将你的操作系统升级到window7最新版 安装 vc_redist.x64.exe 如果你的电脑是32位的,再安装32位的mongodb软件 mongodb-win32-i386-3.2.11-signed.msi mongodb配置创建数据目录(必须)我们在安装完成MongoDB后需要创建一个存放数据的目录。请注意，数据目录应该放在根目录下（(如： C:\\ 或者 D:\\ 等 ),数据目录的命名随意,比如我就命名 mongodb_datas 启动服务器(必须) 启动MongoDB服务器的方式一：通过终端指令去启动 首先在终端切换到你的MongoDB的安装目录的bin目录下(当然如果配置了环境变量在哪个目录下都可以了) 在终端执行: mongod.exe –dbpath c:\\mongodb_datas ,如果成功启动就表示一切都OK了 注意点: 32位版本使用下面的命令启动数据服务：1mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1 - 执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了， - 千万不要关闭，否则无法连接，如果对数据库的操作结束，可以打开该控制台通过 `Ctrl + C` 关闭。 启动MongoDB服务器的方式二:方式一的延续,把上面的指令做成一个批处理文件.bat 新建一个文本文件修改后缀为.bat，以记事本的方式打开，输入mongod.exe --dbpath c:\\mongodb_datas 启动MongoDB服务器的方式三:将MongoDB服务器作为Windows服务运行 以管理员的身份打开命令行输入下面的 1mongod.exe --bind_ip 127.0.0.1 --logpath \"C:/mongodb_datas/server_log/mongodb.log\" --logappend --dbpath \"c:/mongodb_datas\" --port 27017 --serviceName \"MongoDBServer\" --serviceDisplayName \"MongoDBServerDisplayName\" --install 补充:从Windows服务中卸载 MongoDB 服务 先停止要删除的服务(比如MongoDBServer) 以管理员身份运行cmd,在cmd中输入: sc delete 服务名称(比如MongoDBServer) 千万不要删错了，不然你的系统可能就挂了 注意点: mongodb.log 这个日志文件一定要先创建好,才能执行指令 必须要以管理员的身份打开cmd窗口,并运行 MongoDB 数据库存储结构 和Excel对比一下即可明 Excel MongoDB 创建工作簿 创建数据库 创建一个sheet(工作表单) 创建集合 确立表头,插入数据 插入文档(确立表头) 核心思想: 1. 分门别类的存储数据 2. mongodb是以`集合`的概念来区分不同数据的,比如用户集合,商品集合,订单集合等等,不同的数据要放在不同的集合中去统一管理 3. 集合里面存储的可以认为是一个数组 4. 数组中的每一个对象,可以认为就是JSON对象,在mongodb中我们称之为 `文档` 5. 文档的结构可以随意,但是必须统一,也就是说,同一个集合中,所有的文档一定要遵守相同的数据结构 其他: 集合的作用就是用来隔离数据,分门别类的存储数据 操作MongoDB的步骤1.创建数据库中数据的存储目录2.启动MongoDB的服务实例3.创建数据库4.创建集合5.创建文档 如何连接到MongoDB服务器并且操作它？注意：在进行连接之前请确保你的服务实例是开启状态的（不要关闭刚才开启的数据服务实例）。 可以使用两种方式来连接到MongoDB服务器并且操作它 连接方式1:使用MongoDB自带的MongoDB后台管理 Shell 在终端中输入 `mongo` 或是 `mongo --host 127.0.0.1 --port 27017` mongo 命令默认去连接本机上的 MongoDB 服务实例：`127.0.0.1:27017`，可以通过下面的命令 指定连接的主机名和端口号： 1mongo --host 127.0.0.1 --port 27017 如果看到类似于如下的字样说明连接成功： 123456789MongoDB shell version v3.4.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.2Server has startup warnings:2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten]2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten]&gt; 如果提示 “无法连接主机”，请检查你的 MongoDB 数据服务实例是否开启。 操作方式1:在终端中使用mongodb的指令进行操作 常见指令：见下一个知识点 连接及操作方式2:使用图形化客户端工具： robomongo(跨平台) : https://robomongo.org/download 基本操作命令可以参考: http://www.yiibai.com/mongodb/mongodb_create_collection.html http://www.runoob.com/mongodb/mongodb-tutorial.html show dbs 查看当前服务实例上所有的数据库 use 数据库名称 如果数据库不存在，则创建数据库，否则切换到指定数据库。 db.dropDatabase() 删除数据库,注意,要在切换的数据库中删除 db 查看当前所处的数据库 show collections 查看当前数据库中所有的集合 db.createCollection(&quot;集合名称&quot;) 创建集合 db.集合名称.drop() 删除集合 db.集合名称.insert({数据文档}) 插入的每一条文档会自动帮我们生成一个_id字段,它是mongodb自动维护的,不需要我们关心 db.集合名称.find() 查询指定集合中所有的数据 可以通过 db.集合名称.find().pretty() 美化输出格式 默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据 模糊查询的条件 {要查询的字段:{$regex: ‘关键字’}} db.集合名称.update({更新条件}, {要更新的字段}) 更新指定集合数据,注意点,要更新的字段一定要这样写 {$set:{字段的名称:字段的值}}, db.集合名称.remove({删除条件}) 删除指定集合中的数据 exit 退出当前操作 cls 清屏 注意点：更新和删除时一般都需要带条件，除非是全部更新与全部删除，不过全部更新与全部删除这样很危险,实际操作过程中很少 使用 Node 操作 MongoDB安装 MongoDB 官方提供的驱动包：1npm install --save mongodb 具体操作方式请参考官方文档：https://www.npmjs.com/package/mongodb","tags":[{"name":"mongodb,数据库","slug":"mongodb-数据库","permalink":"http://yoursite.com/tags/mongodb-数据库/"}]},{"title":"nodejs","date":"2017-03-06T16:00:00.000Z","path":"2017/03/07/Framework/Node/node/","text":"##","tags":[{"name":"nodejs,node,javascript","slug":"nodejs-node-javascript","permalink":"http://yoursite.com/tags/nodejs-node-javascript/"}]},{"title":"express的基本使用","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/Framework/Express/express的基本使用/","text":"安装首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。12$ mkdir myapp$ cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。1$ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外：1entry point: (index.js) 键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。 接下来安装 Express 并将其保存到依赖列表中：1$ npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可：1$ npm install express 安装 Node 模块时，如果指定了 –save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。 路由路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。 路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback…], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。 下面是一个基本的路由示例：123456789101112var express = require('express');var app = express();// 当以GET方法请求根路径，服务器返回hello worldapp.get('/', function(req, res) &#123; res.send('hello world');&#125;);app.listen(3000, '127.0.0.1', function(err)&#123; if (err) return console.error(err) console.log('start ok!!!')&#125;); //开启服务器，监听3000端口，网址和回调函数可以省略 路由方法123456789// GET method routeapp.get('/', function (req, res) &#123; res.send('GET request to the homepage');&#125;);// POST method routeapp.post('/', function (req, res) &#123; res.send('POST request to the homepage');&#125;); Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。 有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如： app[‘m-search’](‘/‘, function … app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 在下面的例子中，来自 “/secret” 的请求，不管使用 GET、POST、PUT、DELETE 或其他任何 http 模块支持的 HTTP 请求，句柄都会得到执行。1234app.all('/secret', function (req, res, next) &#123; console.log('Accessing the secret section ...'); next(); // pass control to the next handler&#125;); 查询字符串的处理 get请求：express的req.query可以获取到查询字符串，并且默认就是对象的形式 1234567// http://localhost:3000/login?username=zhangsan&amp;password=123app.get('/login', (req, res, next) =&gt; &#123; console.log(req.query) //&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;) post请求：需要使用body-parser第三方插件 12345678910111213141516const bodyParser = require('body-parser')app.use(bodyParser.urlencoded(&#123;extended: false&#125;))app.post('/login', (req, res, next) =&gt; &#123; console.log(`req.body`)//&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;)// 或者下面这种凡事方式const bodyParser = require('body-parser')app.post('/login', bodyParser.urlencoded(&#123;extended: false&#125;), (req, res, next) =&gt; &#123; console.log(`req.body`)//&#123; username: 'zhangsan', password: '123' &#125; next()&#125;, (req, res) =&gt; &#123; res.send('恭喜你')&#125;) 路由路径路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。 Express 使用 path-to-regexp 匹配路由路径，请参考文档查阅所有定义路由路径的方法。 Express Route Tester 是测试基本 Express 路径的好工具，但不支持模式匹配。查询字符串不是路由路径的一部分。 使用字符串的路由路径示例： 1234567891011121314// 匹配根路径的请求app.get('/', function (req, res) &#123; res.send('root');&#125;);// 匹配 /about 路径的请求app.get('/about', function (req, res) &#123; res.send('about');&#125;);// 匹配 /random.text 路径的请求app.get('/random.text', function (req, res) &#123; res.send('random.text');&#125;); 使用字符串模式的路由路径示例： 12345678910111213141516171819// 匹配 acd 和 abcdapp.get('/ab?cd', function(req, res) &#123; res.send('ab?cd');&#125;);// 匹配 abcd、abbcd、abbbcd等app.get('/ab+cd', function(req, res) &#123; res.send('ab+cd');&#125;);// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等app.get('/ab*cd', function(req, res) &#123; res.send('ab*cd');&#125;);// 匹配 /abe 和 /abcdeapp.get('/ab(cd)?e', function(req, res) &#123; res.send('ab(cd)?e');&#125;); 字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。 使用正则表达式的路由路径示例：123456789// 匹配任何路径中含有 a 的路径：app.get(/a/, function(req, res) &#123; res.send('/a/');&#125;);// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res) &#123; res.send('/.*fly$/');&#125;); 路由句柄可以为请求处理提供多个回调函数，其行为类似 中间件。唯一的区别是这些回调函数有可能调用 next(‘route’) 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。 路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合，如下所示. 使用一个回调函数处理路由： 123app.get('/example/a', function (req, res) &#123; res.send('Hello from A!');&#125;); 使用多个回调函数处理路由（记得指定 next 对象）： 123456app.get('/example/b', function (req, res, next) &#123; console.log('response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from B!');&#125;); 使用回调函数数组处理路由： 123456789101112131415var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/example/c', [cb0, cb1, cb2]); 混合使用函数和函数数组处理路由： 12345678910111213141516var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;app.get('/example/d', [cb0, cb1], function (req, res, next) &#123; console.log('response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from D!');&#125;); 相应方法下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。 方法 描述 res.download() 提示下载文件。 res.end() 终结响应处理流程。 res.json() 发送一个 JSON 格式的响应。 res.jsonp() 发送一个支持 JSONP 的 JSON 格式的响应。 res.redirect() 重定向请求。 res.render() 渲染视图模板。 res.send() 发送各种类型的响应。 res.sendFile 以八位字节流的形式发送文件。 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 app.route()可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。请参考 Router() 文档 了解更多有关路由的信息。 下面这个示例程序使用 app.route() 定义了链式路由句柄。12345678910app.route('/book') .get(function(req, res) &#123; res.send('Get a random book'); &#125;) .post(function(req, res) &#123; res.send('Add a book'); &#125;) .put(function(req, res) &#123; res.send('Update the book'); &#125;); express.Router可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。 下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。 在 app 目录下创建名为 birds.js 的文件，内容如下：123456789101112131415161718var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 然后在应用中加载路由模块：123var birds = require('./birds');...app.use('/birds', birds); 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。 使用中间件Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。中间件的功能包括： 执行任何代码。 修改请求和响应对象。 终结请求-响应循环。 调用堆栈中的下一个中间件。 如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。Express 应用可使用如下几种中间件： 应用级中间件] 路由级中间件 错误处理中间件 内置中间件 第三方中间件 使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。 应用级中间件应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如：123456789101112131415161718var app = express();// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use('/user/:id', function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; res.send('USER');&#125;); 下面这个例子展示了在一个挂载点装载一组中间件。12345678// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息app.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;); 作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。123456789101112// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; console.log('ID:', req.params.id); next();&#125;, function (req, res, next) &#123; res.send('User Info'); // 终止了请求-响应循环&#125;);// 处理 /user/:id， 打印出用户 id，该路由永远不会被执行app.get('/user/:id', function (req, res, next) &#123; res.end(req.params.id);&#125;); 如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由。 注意： next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效。123456789101112131415// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 否则将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面app.get('/user/:id', function (req, res, next) &#123; res.render('special');&#125;); 路由级中间件路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。1var router = express.Router(); 路由级使用 router.use() 或 router.VERB() 加载。上述在应用级创建的中间件系统，可通过如下代码改写为路由级：12345678910111213141516171819202122232425262728293031323334353637var app = express();var router = express.Router();// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 负责将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面router.get('/user/:id', function (req, res, next) &#123; console.log(req.params.id); res.render('special');&#125;);// 将路由挂载至应用app.use('/', router); 错误处理中间件 错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 请参考 错误处理 一章了解更多关于错误处理中间件的内容。 内置中间件从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。 express.static(root, [options])express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。 参数 root 指提供静态资源的根目录。 可选的 options 参数拥有如下属性。 属性 描述 类型 缺省值 dotfiles 是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore” String “ignore” etag 是否启用 etag 生成 Boolean true extensions 设置文件扩展名备份选项 Array [] index 发送目录索引文件，设置为 false 禁用目录索引。 Mixed “index.html” lastModified 设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false。 Boolean true maxAge 以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性。 Number 0 redirect 当路径为目录时，重定向至 “/”。 Boolean true setHeaders 设置 HTTP 头以提供文件的函数。 Function 下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。12345678910111213var options = &#123; dotfiles: 'ignore', etag: false, extensions: ['htm', 'html'], index: false, maxAge: '1d', redirect: false, setHeaders: function (res, path, stat) &#123; res.set('x-timestamp', Date.now()); &#125;&#125;app.use(express.static('public', options)); 每个应用可有多个静态目录。123app.use(express.static('public'));app.use(express.static('uploads'));app.use(express.static('files')); 更多关于 serve-static 和其参数的信息，请参考 serve-static 文档。 第三方中间件通过使用第三方中间件从而为 Express 应用增加更多功能。安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser1$ npm install cookie-parser 123456var express = require('express');var app = express();var cookieParser = require('cookie-parser');// 加载用于解析 cookie 的中间件app.use(cookieParser()); 请参考 第三方中间件 获取 Express 中经常用到的第三方中间件列表。 在 Express 中使用模板引擎需要在应用中进行如下设置才能让 Express 渲染模板文件： views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’) view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’)然后安装相应的模板引擎 npm 软件1$ npm install jade --save 和 Express 兼容的模板引擎，比如 Jade，通过 res.render() 调用其导出方法 __express(filePath, options, callback) 渲染模板。 有一些模板引擎不遵循这种约定，Consolidate.js 能将 Node 中所有流行的模板引擎映射为这种约定，这样就可以和 Express 无缝衔接。 一旦 view engine 设置成功，就不需要显式指定引擎，或者在应用中加载模板引擎模块，Express 已经在内部加载，如下所示。1app.set('view engine', 'jade'); 在 views 目录下生成名为 index.jade 的 Jade 模板文件，内容如下：12345html head title!= title body h1!= message 然后创建一个路由渲染 index.jade 文件。如果没有设置 view engine，您需要指明视图文件的后缀，否则就会遗漏它。123app.get('/', function (req, res) &#123; res.render('index', &#123; title: 'Hey', message: 'Hello there!'&#125;);&#125;); 此时向主页发送请求，“index.jade” 会被渲染为 HTML。 请阅读 “为 Express 开发模板引擎” 了解模板引擎在 Express 中是如何工作的。 错误处理定义错误处理中间件和定义其他中间件一样，除了需要 4 个参数，而不是 3 个，其格式如下 (err, req, res, next)。例如：1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 在其他 app.use() 和路由调用后，最后定义错误处理中间件，比如：12345678var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑&#125;); 中间件返回的响应是随意的，可以响应一个 HTML 错误页面、一句简单的话、一个 JSON 字符串，或者其他任何您想要的东西。 为了便于组织（更高级的框架），您可能会像定义常规中间件一样，定义多个错误处理中间件。比如您想为使用 XHR 的请求定义一个，还想为没有使用的定义一个，那么：12345678var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(logErrors);app.use(clientErrorHandler);app.use(errorHandler); logErrors 将请求和错误信息写入标准错误输出、日志或类似服务：1234function logErrors(err, req, res, next) &#123; console.error(err.stack); next(err);&#125; clientErrorHandler 的定义如下（注意这里将错误直接传给了 next）：1234567function clientErrorHandler(err, req, res, next) &#123; if (req.xhr) &#123; res.status(500).send(&#123; error: 'Something blew up!' &#125;); &#125; else &#123; next(err); &#125;&#125; errorHandler 能捕获所有错误，其定义如下：1234function errorHandler(err, req, res, next) &#123; res.status(500); res.render('error', &#123; error: err &#125;);&#125; 如果向 next() 传入参数（除了 ‘route’ 字符串），Express 会认为当前请求有错误的输出，因此跳过后续其他非错误处理和路由/中间件函数。如果需做特殊处理，需要创建新的错误处理路由，如下节所示。 如果路由句柄有多个回调函数，可使用 ‘route’ 参数跳到下一个路由句柄。比如：12345678910111213app.get('/a_route_behind_paywall', function checkIfPaidSubscriber(req, res, next) &#123; if(!req.user.hasPaid) &#123; // 继续处理该请求 next('route'); &#125; &#125;, function getPaidContent(req, res, next) &#123; PaidContent.find(function(err, doc) &#123; if(err) return next(err); res.json(doc); &#125;); &#125;); 在这个例子中，句柄 getPaidContent 会被跳过，但 app 中为 /a_route_behind_paywall 定义的其他句柄则会继续执行。 next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄。 缺省错误处理句柄Express 内置了一个错误处理句柄，它可以捕获应用中可能出现的任意错误。这个缺省的错误处理中间件将被添加到中间件堆栈的底部。 如果你向 next() 传递了一个 error ，而你并没有在错误处理句柄中处理这个 error，Express 内置的缺省错误处理句柄就是最后兜底的。最后错误将被连同堆栈追踪信息一同反馈到客户端。堆栈追踪信息并不会在生产环境中反馈到客户端。 设置环境变量 NODE_ENV 为 “production” 就可以让应用运行在生产环境模式下。 如果你已经开始向 response 输出数据了，这时才调用 next() 并传递了一个 error，比如你在将向客户端输出数据流时遇到一个错误，Express 内置的缺省错误处理句柄将帮你关闭连接并告知 request 请求失败。 因此，当你添加了一个自定义的错误处理句柄后，如果已经向客户端发送包头信息了，你还可以将错误处理交给 Express 内置的错误处理机制。1234567function errorHandler(err, req, res, next) &#123; if (res.headersSent) &#123; return next(err); &#125; res.status(500); res.render('error', &#123; error: err &#125;);&#125;","tags":[{"name":"express,node","slug":"express-node","permalink":"http://yoursite.com/tags/express-node/"}]},{"title":"gulp插件的使用","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/Framework/Gulp/gulp插件的使用/","text":"常用插件列表 插件名称 作用 del 删除文件或文件夹 gulp-less 编译LESS文件 gulp-rname 重命名文件 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 js 文件 gulp-concat-css 合并 css 文件 gulp-cssnano 压缩 css gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-load-plugins 依赖自动加载 gulp-useref 自动合并打包处理 gulp-wrap 包装内容 gulp-angular-templatecache AngularJS 模板缓存 browser-sync 和 gulp 配合使用实现文件改变执行某个任务后自动刷新 yargs 获取命令行参数 gulp-if 根据判断执行某个插件 gulp-angular-templatecache安装插件1npm install --save-dev gulp-angular-templatecache 基本使用ulpfile.js 连接模板目录中所有.html文件的内容，并保存到public / templates.js（默认文件名）。1234567var gulp = require('gulp');var templateCache = require('gulp-angular-templatecache');gulp.task('default', function () &#123; return gulp.src('templates/**/*.html') .pipe(templateCache()) .pipe(gulp.dest('public'));&#125;); 结果(public/templates.js) 输出样式（预处理）。1234567891011angular.module(\"templates\").run([$templateCache, function($templateCache) &#123; $templateCache.put(\"template1.html\", // template1.html content (escaped) ); $templateCache.put(\"template2.html\", // template2.html content (escaped) ); // etc. &#125;]); 将此文件包含在您的应用程序中，AngularJS将使用$ templateCache（如果可用）。注意：这个插件不会默认创建一个新的AngularJS模块，但需要调用templates模块。如果想要创建新模块，请将 options.standalone 设置为true。 注意：如果在Windows上使用Visual Studio，您可能会遇到此错误消息：ASPNETCOMPILER : error ASPRUNTIME: The specified path, file name, or both are too long. The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters.这很可能是由于路径名太长，可以通过在 lodash.bindpackage.json 中添加一个 dev dependecy 来修复。无论如何，如果你遇到这个错误，请在＃62中删除一个注释，我们可以合并＃63。 APIgulp-angular-templatecache(filename, options) filename - {string} [filename=’templates.js’] Name to use when concatenating. options root - {string} Prefix for template URLs. module - {string} [module=’templates’] Name of AngularJS module. standalone - {boolean} [standalone=false] Create a new AngularJS module, instead of using an existing. base {string | function} [base=file.base] Override file base path. moduleSystem {string} Wrap the templateCache in a module system. Currently supported systems: RequireJS, Browserify, ES6 and IIFE (Immediately-Invoked Function Expression). transformUrl {function} Transform the generated URL before it’s put into $templateCache. 123transformUrl: function(url) &#123; return url.replace(/\\.tpl\\.html$/, '.html')&#125; templateHeader {string} [templateHeader=see below] Override template header. 1var TEMPLATE_HEADER = 'angular.module(\"&lt;%= module %&gt;\"&lt;%= standalone %&gt;).run([\"$templateCache\", function($templateCache) &#123;'; templateBody {string} [templateBody=see below] Override template body. 1var TEMPLATE_BODY = '$templateCache.put(\"&lt;%= url %&gt;\",\"&lt;%= contents %&gt;\");'; templateFooter {string} [templateFooter=see below] Override template footer. 1var TEMPLATE_FOOTER = '&#125;]);';","tags":[{"name":"gulp，","slug":"gulp，","permalink":"http://yoursite.com/tags/gulp，/"}]},{"title":"Gulp构建工具的使用","date":"2017-03-04T13:50:52.000Z","path":"2017/03/04/Framework/Gulp/Gulp构建工具的使用/","text":"Automate and enhance your workflowgulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something. 简介本文主要是根据gulp中文网文档和gulp教程之gulp中文API的内容综合而成，方便自己理解与学习gulp自动化工具的基本使用 工具介绍 Gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。 常见处理任包括以下几方面： 模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。 使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件； 对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能； 以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack 等。 Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，其以简洁的配置和卓越的性能成为目前主流的构建工具。 相关链接 官方：http://gulpjs.com/中文官网：http://www.gulpjs.com.cn/npm：https://www.npmjs.com/package/gulpGithub：https://github.com/gulpjs/gulpGitbook：https://wizardforcel.gitbooks.io/gulp-doc/content/2.html 安装 首先要全局安装gulp-cli工具 1npm install --global gulp-cli 安装全局gulp 1npm install --global gulp 作为项目的开发依赖（devDependencies）安装 1npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 1234var gulp = require(&apos;gulp&apos;); // 引入gulp这个第三方包gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp 123gulp# 默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。# 想要单独执行特定的任务（task），请输入 gulp &lt;task&gt; &lt;othertask&gt;。 API文档 官方文档：https://github.com/gulpjs/gulp/blob/master/docs/API.md中文文档：http://www.gulpjs.com.cn/docs/gulp教程之gulp中文API：http://www.ydcss.com/archives/424 gulp.src(globs[,options])指定需要处理的源文件的路径，gulp借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，gulp.src返回当前文件流至可用插件；12345// 通过gulp.src()读取文件，经过pipe管道流到gulp.dest()指定的文件中gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) .pipe(gulp.dest('build/minified_templates')); globs类型： String 或StringArray需要处理的源文件匹配符路径，字符串或者数组通配符路径匹配示例： “src/a.js”：指定具体文件；“*“：匹配所有文件 例：src/*.js(包含src下的所有js文件)；“**“：匹配0个或多个子文件夹 例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；“{}“：匹配多个属性 例：src/{a,b}.js(包含a.js和b.js文件) src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；“!”：排除文件 例：!src/a.js(不包含src下的a.js文件)； 1234567891011var gulp = require('gulp'); // 导入第三方gulp插件var less = require('gulp-less'); // 导入第三方gulp-less插件 gulp.task('testLess', function () &#123; // 创建一个testLess任务 // 匹配单个文件 gulp.src('less/test/style.less') // 匹配多个文件（数组） gulp.src(['less/**/*.less','!less/&#123;extend,page&#125;/*.less']) // 匹配less文件夹下的所有.less文件，包括子文件夹下的.less，但是不包括less下的extend和page下的.less文件 .pipe(less()) // 使用gulp-less插件编译less文件 .pipe(gulp.dest('./css')); // 将编译后的css文件存放到当前目录的css文件夹下&#125;); options类型（可选）： Object options.buffer类型： Boolean 默认值： true如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。注意：插件可能并不会实现对 stream 的支持。 options.read类型： Boolean 默认值： true如果该项被设置为 false 那么 file.contents 会返回空值（null），也就是并不会去读取文件。 options.base类型String 默认值：’ ‘设置输出路径以某个路径的某个组成部分为基础向后拼接，将会加在 glob 之前如：请想像一下在一个路径为 client/js/somedir 的目录中，有一个文件叫 somefile.js 12345678// 没有设置base属性gulp.src('client/js/**/*.js') // 匹配 'client/js/somedir/somefile.js' .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/somedir/somefile.js' // 设置 base属性gulp.src('client/js/**/*.js', &#123; base: 'client' &#125;)//设置输出路径为client的js文件夹中，最终变成 'build/js' .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/js/somedir/somefile.js' gulp.dest(path[,options])指定处理后的文件的输出路径。如果某文件夹不存在，将会自动创建它。12345gulp.src('./client/templates/*.jade') .pipe(jade()) .pipe(gulp.dest('./build/templates')) // 将处理后的文件存放到当前文件夹下'build/templates'文件夹中 .pipe(minify()) // 使用gulp-minify插件对文件进行压缩 .pipe(gulp.dest('./build/minified_templates')); // 将处理后的文件存放到当前文件夹下'build/templates'文件夹中 文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。 请查看上述的 gulp.src 来了解更多信息。 path类型（必填）： String 或 Function指定文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。 options类型（可选）： Object options.cwd类型： String 默认值： process.cwd()输出目录的 cwd 参数（前脚本的工作路径），当输出目录是相对路径时候有效。 options.mode类型： String 默认值： 0777八进制权限字符，用以定义在输出目录中所创建的目录的权限。 gulp.task(name[, deps], fn)定义一个使用 Orchestrator 实现的任务（task）。123gulp.task('taskname', function() &#123; // 做一些事&#125;); name类型（必填）：String指定任务的名称，名称中不能包含空格 deps类型（可选）：StringArray指定该任务所依赖的其他任务（注意：被依赖的任务需要返回当前任务的事件流，从而保证任务的执行顺序，请参考如下示例）123456789101112gulp.task('testLess', function () &#123; // 返回事件流，确保该任务执行后才执行minicss任务 return gulp.src(['less/style.less']) .pipe(less()) .pipe(gulp.dest('./css'));&#125;);// minicss任务依赖testLess任务gulp.task('minicss', ['testLess'], function () &#123; //执行完testLess任务后再执行minicss任务 gulp.src(['css/*.css']) .pipe(minifyCss()) .pipe(gulp.dest('./dist/css'));&#125;); fn类型（必填）：Function该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。异步任务支持：任务可以异步执行，如果 fn 能做到以下其中一点 接受一个callback函数 123456789// 在 shell 中执行一个命令var exec = require('child_process').exec;gulp.task('jekyll', function(cb) &#123; // 编译 Jekyll exec('jekyll build', function(err) &#123; if (err) return cb(err); // 返回 error cb(); // 完成 task &#125;);&#125;); 返回一个 stream（事件流） 123456gulp.task('somename', function() &#123; var stream = gulp.src('client/**/*.js') .pipe(minify()) .pipe(gulp.dest('build')); return stream;&#125;); 返回一个 promise 123456789var Q = require('q');gulp.task('somename', function() &#123; var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 1); return deferred.promise;&#125;); 注意： 默认的，task 将以最大的并发数执行，也就是说，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，你需要做两件事： 给出一个提示，来告知 task 什么时候执行完毕， 并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。 对于这个例子，让我们先假定你有两个 task，”one”和 “two”，并且你希望它们按照这个顺序执行： 在 “one” 中，你加入一个提示，来告知什么时候它会完成：可以再完成时候返回一个 callback，或者返回一个 promise 或 stream，这样系统会去等待它完成。 在 “two” 中，你需要添加一个提示来告诉系统它需要依赖第一个 task 完成。 因此，这个例子的实际代码将会是这样：1234567891011var gulp = require('gulp');// 返回一个 callback，因此系统可以知道它什么时候完成gulp.task('one', function(cb) &#123; // 做一些事 -- 异步的或者其他的 cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了&#125;);// 定义一个所依赖的 task 必须在这个 task 执行之后完成gulp.task('two', ['one'], function() &#123; // task 'one' 完成后才执行这里的代码&#125;);gulp.task('default', ['one', 'two']); gulp.watch(glob[, opts], tasks) 与 gulp.watch(glob[, opts, cb])监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。 glob类型（必填）： String 或 StringArray指定需要处理的一个或多个源文件的一个路径匹配符或路径匹配符数组 opts类型（可选）：Object传给 gaze 的参数 ，具体参看 https://github.com/shama/gaze tasks类型(必填)：StringArray需要执行的任务的名称数组 cb(event)类型(可选)：Function每个文件变化执行的回调函数 12345678910111213141516var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); // gulp.watch(glob[, opts], tasks)gulp.task('watch1', function () &#123; gulp.watch('less/**/*.less', ['testLess']);&#125;);// gulp.watch(glob[, opts, cb])gulp.task('watch2', function () &#123; gulp.watch('js/**/*.js', function (event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...'); &#125;);&#125;); 常用插件 插件名称 作用 del 删除文件或文件夹 gulp-less 编译LESS文件 gulp-rname 重命名文件 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 js 文件 gulp-concat-css 合并 css 文件 gulp-cssnano 压缩 css gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-load-plugins 依赖自动加载 gulp-useref 自动合并打包处理 gulp-wrap 包装内容 gulp-angular-templatecache AngularJS 模板缓存 browser-sync 和 gulp 配合使用实现文件改变执行某个任务后自动刷新 yargs 获取命令行参数 gulp-if 根据判断执行某个插件","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"Vue开发遇到的问题","date":"2017-02-18T13:30:52.000Z","path":"2017/02/18/Framework/Vue/Vue开发遇到的问题/","text":"本文主要是记录学习及开发中遇到的一些问题，仅供自己学习所用，因此没有详细记录 router-link不能够添加绑定事件如果想要在添加点击事件，需要在router-link标签的内部或者外部标签上添加，不能直接在router-link上添加，没有效果详情请看 https://segmentfault.com/q/1010000007891457 返回按钮的显示隐藏在首页时候没有返回按钮，但是其他页面有返回按钮，因此设置了一个isShow属性为false让其隐藏，当跳转到其他页面的时候设置为true，这个时候刷新页面就没有返回按钮了，因为刷新页面会重新构建vue对象的此时isShow是初始值false，所以就隐藏了，这时候就可以考虑在created方法执行的时候直接监听$route.path的变化设置isShow的值从而控制返回按钮的显示和隐藏 新闻列表到详情的内容获取不正确现象：一个首页中有通过router-view组件显示新闻列表以及新闻详情页面，当从列表页跳转到详情页时，第一次详情页数据没有问题，但是以后列表页到详情页的每次跳转都是第一次跳转得到的数据，只有手动刷新详情页才能实现新数据的加载 原因：由于在router-view组件的外层包裹了keep-alive组件，因此router-view中的所有组件都会被缓存起来，所以组件只被创建了一次（即只会执行一次生命周期钩子函数），一直没有被销毁，也就是没有执行destroyed生命周期钩子，而新闻页数据的获取是在新闻页的created生命周期钩子中执行的，所以详情页的数据只获取了一次，即第一次访问时候的数据，因此以后的每次都是第一次获取的数据。而刷新页面相当于重新创建了一次该组件，因此会显示正确的新闻内容 解决办法： 方法一：去掉外层包裹的keep-live组件，即不缓存组件 方法二：使用路由钩子beforeRouteEnter处理数据请求问题 总结：keep-alive组件会把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染，因此不能在经常需要变化的地方用，否则就会出现数据显示不正确的情况，总之根据实际需求来决定需不需要使用keep-alive 相关网址： vue2.0 中keep-alive内容不刷新的问题 vue-router导航钩子 给组件绑定事件无效现象：给组件绑定事件无效解决办法：加上.native修饰符即可 $refs获取DOM元素的问题$refs是在那个时候获取DOM元素的，为什么在组件的beforeCreate和created钩子函数中都可以获取到DOM元素，此时DOM不是应该还没有被渲染吗 拉钩中seller滚动问题涉及到生命周期函数不同的阶段调用初始化betterScroll的初始化 props接受数据但是在js中无法获取现象：在接受数据的组建中无法通过js访问props的属性原因：数据是异步获取的，当组件创建的时候，可能数据还没有获取过来，此时访问props的属性是设置的初始值，而不是最终的值解决办法：通过在updated钩子函数访问props的属性，当异步获取数据之后，会自动触发updated钩子函数，此时props的属性就是最终设置的值 v-for循环需要添加key属性当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有唯一 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值（在这里使用简写）：123&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能使用 v-for 来提供 key ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。因为它是 Vue 识别节点的一个通用机制， key 并不特别与 v-for 关联，key 还具有其他用途，详情请看https://cn.vuejs.org/v2/guide/conditional.html#用-key-管理可复用的元素 数组的更新由于 JavaScript 的限制， Vue 不能检测以下变动的数组：当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue当你修改数组的长度时，例如： vm.items.length = newLength 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果， 同时也将触发状态更新：1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// Array.prototype.splice`example1.items.splice(indexOfItem, 1, newValue) 为了解决第二类问题，你也同样可以使用 splice：1example1.items.splice(newLength) 设置值受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：1var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的&lt;/pre&gt; Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：1Vue.set(vm.someObject, 'b', 2) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名： 1this.$set(this.someObject,'b',2) 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性： 12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 也有一些数组相关的问题，之前已经在列表渲染中讲过。 异步更新队列可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。例如：1&lt;div id=\"example\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue ，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：1234567891011121314151617Vue.component('example', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: function () &#123; return &#123; message: 'not updated' &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = 'updated' console.log(this.$el.textContent) // =&gt; '没有更新' this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; '更新完成' &#125;) &#125; &#125;&#125;)","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"angular 容易遇到的坑","date":"2017-02-11T16:00:00.000Z","path":"2017/02/12/Framework/AngularJS/angular容易遇到的坑/","text":"angular 容易遇到的坑进行遍历ng-repeat的时候要注意是否有重复数据F：我们在进行ng-repeat遍历数组的时候当我们的数据有重复的时候，我们的NG会报错， Q：处理办法是，在我们的要进行数据遍历的地方加入 track by $index 我们在进行事件广播的时候一定要切记的事项我们在进行数据广播的时候，要注意的是我们要进行调用的事件是否已经初始化完毕， 一般处理办法，是进行一个延时广播的操作，这样子就可以就可以避免这个问题了 还有就是我们在进行事件广播的时候一定要避免的是我们的emit和我们的broadcast的事件名称不能相同，不然的话，我们的事件广播会进入一个死循环 还有就是切记不要在我们的controller中操作我们的dom如果必须要进行操作dom的话，我们也要在我们的指令directive 中进行操作，我们在操作过dom之后要进行$scope.$digest()的调用，这样子就可以同步我们的视图和数据了，简单来说，当我们的双向数据绑定发生失效的时候，我们就要调用我们的$scope.$digest()函数，进行数据和视图之间的同步 $scope.$digest()一般情况下，调用这个函数会报错的 为什么不能直接在我们的controller中直接操作我们的dom呢， 因为我们的dom被我们直接操作以后，很容易与我们的NG产生冲突，这样子的话，可能是我们的整个NG模块出现不可预知的问题 当我们的自己调用我们自己写的jsonp的时候，我们的怎么进行数据的刷新$scope. $apply $timeout和我们js的timeout用法基本一致 只是我们在把时间设为0之后，并不会立即执行，只是把我们的匿名函数，放在我们队列的最后面（因为我们的js语言的原理所导致的，因为我们的js是单线程的） 在使用directive（指令）的时候，当我们对外界暴露一个接口的注意事项我们不可以直接在我们的当我们要给我们的接口直接赋值的情况下我们的不要直接给接口一个等于，而是间接地给一个@ 因为我们的如果直接给它赋值的话，如果不加单引号的情况下，会直接报错 例如下面这个指令 appHeadBar.js 123456789101112131415161718192021222324//这儿是我们定义的指令\"use strict\";angular.module(\"app\").directive(\"appHeadBar\",function()&#123; return&#123; restrict:\"A\", replace:true, templateUrl:\"views/template/headBar.html\", //当我们使用这种写法的时候，我们只需要使用下面的第一种写法进行引用即可 scope:&#123; text:\"@\" &#125;, //当我们使用这种写法的时候，我们要使用第二种写法，不然的话，会在浏览器中报错 scope:&#123; text:\"@\" &#125;, link:function($scope)&#123; $scope.back=function()&#123; //这儿window一定要小写 window.history.back(); &#125;; &#125; &#125;;&#125;); post.html 12345&lt;!--写法一--&gt; &lt;div app-head-bar text=\"我的收藏\"&gt;&lt;/div&gt;&lt;!--写法二--&gt;&lt;div app-head-bar text=\"'我的收藏'\"&gt;&lt;/div&gt; ERROR 1Error: [$parse:lexerr] Lexer Error: Unexpected next character at columns 0-0 [我] in expression [我的收藏].","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"gulp搭建静态项目结构","date":"2017-01-10T13:03:08.000Z","path":"2017/01/10/Framework/Gulp/gulp搭建静态项目结构/","text":"基本文件结构123456789├─dist├─node_modules└─src ├─app │ ├─login │ └─register ├─fonts ├─img └─less 安装相关的依赖包12npm install --save angularnpm install --save angular-route gulp del gulp-concat gulp-uglify gulp-yargs gulp-if gulp-less gulp-cssnano gulp-angular-templatecache browser-sync 扩展12# 当根据package.json文件下载安装依赖的时候，如果只想安装生产依赖npm install --production 对文件进行打包操作当写项目的时候需要对项目进行实时打包，合并成单个文件 将静态文件打包到dis中，并保存目录结构 123456789101112131415161718/** * 每次构建dist目录时先删除dist文件 */gulp.task('clear', function(callback) &#123; del(paths.dist) .then(function() &#123; callback() // 保证任务的执行顺序 &#125;)&#125;);/** * 拷贝静态文件到指定目录，每次拷贝前先删除dist文件夹中的内容 */gulp.task('static', ['clear'], function() &#123; return gulp.src(paths.staticPath, &#123; base: './src' //拷贝时，保留src下的目录结构不变 &#125;) .pipe(gulp.dest(paths.dist))&#125;); 将引入的css都打包成一个文件，如： app.css 123456789/** * 编译main.less文件 */gulp.task('less', function() &#123; return gulp.src(paths.lessPath) // lessPath: './src/less/main.less' .pipe(less()) .pipe(gulpif(argv.deploy, css())) .pipe(gulp.dest(paths.lessDist)) // lessPath: './src/less/main.less'&#125;); 将第三方的js文件打包合并成一个 vender.js 文件 123456789/** * 压缩合并第三方依赖的JS文件到指定目录 */gulp.task('vender', function() &#123; return gulp.src(paths.venders) // venders: ['./node_modules/angular/angular.js', './node_modules/angular-route/angular-route.js'], .pipe(concat('vender.js')) // 合并JS代码并取名为vender.js .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.venderDist)) // venderDist: './dist/js'&#125;); 将自己的js文件打包合并成一个 bundle.js 文件 123456789101112131415161718192021222324252627282930313233// html文件中的外部文件路径的引入问题// 使用angular的$templateCache将所有html文件读取出来生成一段js代码/** * 读取app文件夹中所有的html文件自动生成模板字符串缓存 * templatecache参数 * 参数一：fileName默认是templates.js * 参数二：options * root: 生成的路径名 * module：angularjs模块名，默认是templates，然后在主模块中引入该模块 * standalong：创建一个独立的模块 * transformUrl：(类型：function)转换路径，修改原有的生成规则，返回新的路径 * 利用node的内置模块==&gt;node.basename(path) */gulp.task('template', function() &#123; return gulp.src(paths.template) .pipe(templatecache(&#123; module: 'templates', standalong: true, transformUrl: function(url) &#123; return './' + path.basename(url) &#125; &#125;)) //将读取到的html文件生成一段js代码，以字符串的形式存储到缓存中 .pipe(gulpif.dest('./')) //将构建出来的文件存放到&#125;);/** * 压缩合并自己的JS文件到指定目录，包括templates.js文件 */gulp.task('script', ['template'], function() &#123; return gulp.src(paths.scripts) .pipe(concat('bundle.js')) // 合并JS代码 .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.scriptDist))&#125;); 开启服务监视文件改动自动刷新浏览器 123456789101112131415161718192021/** * 监视js文件的变动 */gulp.task('js-watch', function(done) &#123; browserSync.reload() done()&#125;);/** * 开启服务 */gulp.task('server', function() &#123; browserSync.init(&#123; server: &#123; baseDir: path.dist &#125; &#125;) gulp.watch(['./src/app/**/*.js', './src/app/**/*.less', './src/**/*.html' ], ['js-watch'])&#125;); 最终的gulpfile.js这里的代码任务之间的依赖性太强，有很大的优化空间，代码仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * 1. 拷贝静态资源 * 2. 压缩合并第三方JS文件 * 3. 压缩合并自己的JS文件 * 4. 编译压缩less文件 */var gulp = require('gulp')var del = require('del') // 删除文件var concat = require('gulp-concat') // 合并JS文件var uglify = require('gulp-uglify') // 压缩JS文件var argv = require('yargs').argv // 获取命令行参数var gulpif = require('gulp-if') // 根据判断执行某个插件var less = require('gulp-less') // 编译less文件var css = require('gulp-cssnano') // 压缩 cssvar templatecache = require('gulp-angular-templatecache') // 压缩 cssvar path = require('path') // 加载node内置的path方法，解析路径var browserSync = require('browser-sync').create() // 开启服务并和 gulp 配合使用实现文件改变执行某个任务后自动刷新var paths = &#123; staticPath: [ './src/index.html', './src/img/**/*.*', './src/fonts/**/*.*' ], dist: './dist' venders: [ './node_modules/angular/angular.js', './node_modules/angular-route/angular-route.js' ], venderDist: './dist/js', scripts: [ '/templates.js', // 放在前面，保证在合成的时候也是在文件内容的最上面 './src/app/**/*.js' ], scriptDist: './dist/js', lessPath: './src/less/main.less', //其他less文件都引入main.css文件中，最后编译成一个main.css文件 lessDist: './dist/css', template: './src/app/**/*.html'&#125;/** * 每次构建dist目录时先删除dist文件 */gulp.task('clear', function(callback) &#123; del(paths.dist) .then(function() &#123; callback() // 保证任务的执行顺序 &#125;)&#125;);/** * 拷贝静态文件到指定目录 */gulp.task('static', ['clear'], function() &#123; return gulp.src(paths.staticPath, &#123; base: './src' //拷贝时，保留src下的目录结构不变 &#125;) .pipe(gulp.dest(paths.dist))&#125;);/** * 压缩合并第三方依赖的JS文件到指定目录 */gulp.task('vender', ['less'], function() &#123; return gulp.src(paths.venders) .pipe(concat('vender.js')) // 合并JS代码并取名为vender.js .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.venderDist))&#125;);/** * 压缩合并自己的JS文件到指定目录，包括templates.js文件 */gulp.task('script', ['template'], function() &#123; return gulp.src(paths.scripts) .pipe(concat('bundle.js')) // 合并JS代码 .pipe(gulpif(argv.deploy, uglify())) // 当命令行包含参数-deploy时执行uglify()压缩JS代码 .pipe(gulp.dest(paths.scriptDist))&#125;);/** * 编译main.less文件 */gulp.task('less', ['static'], function() &#123; return gulp.src(paths.lessPath) .pipe(less()) .pipe(gulpif(argv.deploy, css())) .pipe(gulp.dest(paths.lessDist))&#125;);// html文件中的外部文件路径的引入问题// 使用angular的$templateCache将所有html文件读取出来生成一段js代码/** * 读取app文件夹中所有的html文件自动生成模板字符串缓存 * templatecache参数 * 参数一：fileName默认是templates.js * 参数二：options * root: 生成的路径名 * module：angularjs模块名，默认是templates，然后在主模块中引入该模块 * standalong：创建一个独立的模块 * transformUrl：(类型：function)转换路径，修改原有的生成规则，返回新的路径 * 利用node的内置模块==&gt;node.basename(path) */gulp.task('template', ['vender'], function() &#123; return gulp.src(paths.template) .pipe(templatecache(&#123; module: 'templates', standalong: true, transformUrl: function(url) &#123; return './' + path.basename(url) &#125; &#125;)) //将读取到的html文件生成一段js代码，以字符串的形式存储到缓存中 .pipe(gulpif.dest('./')) //将构建出来的文件存放到&#125;);/** * 监视js文件的变动 */gulp.task('js-watch', ['script'], function(done) &#123; browserSync.reload() done()&#125;);/** * 开启服务 */gulp.task('server', ['script'], function() &#123; browserSync.init(&#123; server: &#123; baseDir: path.dist &#125; &#125;) gulp.watch(['./src/app/**/*.js', './src/app/**/*.less', './src/**/*.html' ], ['js-watch'])&#125;);","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"windows 免费升级win10","date":"2016-11-11T16:00:00.000Z","path":"2016/11/12/Others/免费更新win10/","text":"windows 免费升级win10 下载win10安装软件 正常来说去年win10已经停止了免费更新，氮素！还是留了个后门的，就是— 面向使用辅助技术的客户的 Windows 10 免费升级优惠 （反正就是给不是正常人使用的，但是跟正常系统是一样的）； 点击【立即升级】按钮即可，官方版本不用担心有乱七八糟的东西； 然而有些电脑是需要激活才能升win10的，我是试过好多的激活码都不管用，当然网上还有一些其他激活的教程，我是选择了最简单的，下软件,用的是 oem7小马激活工具 一键傻瓜式操作； 后面就简单了，用前面下的win10工具下载呗，建议网速好的情况，最好是晚上下，差不多3g？下载完成后，也会自动安装的； 如果电脑内存不大，略卡的情况可以度娘一下，进行各种优化；实在卡的不行，也可以选择恢复的，在安装时已经帮你自动保存了以前的版本； PS：如果电脑原来是32bit的，升级了也还是32bit，想升64bit好像只能重装？反正直接升win10是不行的；","tags":[{"name":"windows,windows 10","slug":"windows-windows-10","permalink":"http://yoursite.com/tags/windows-windows-10/"}]},{"title":"前端跨域访问","date":"2016-11-03T12:01:51.000Z","path":"2016/11/03/Others/前端跨域访问/","text":"原文：http://blog.brucefeng.info/post/web-crossdomain-2016 1. JSONP 2. CORS（Cross-origin resource sharing） 2.1 运行模式 2.2 JQuery支持CORS 2.3 与JSONP相比 3. 跨域访问在点评的应用 References 在互联网应用中： 一个页面需要请求多个域名下的web服务端接口 同时一个web服务接口可能会被很多不同域名下的页面请求。 一个web应用如果支持为了支持以上模式而申请多个域名是不合算的，因为域名申请和管理所占用的资源比较大，因此服务端支持跨域就成了一个更合理的解决方案。 解决跨域的方式主要有两种： 1. JSONP关于JSONP的基本概念就不多介绍了，现在在网上已经有很多解释。JSONP模式下前端Client可以跨域请求JSON文件，进而实现前端跨域请求其他服务器资源的目的。目前在一些流行的JavaScript库中对JSONP和Ajax的支持方式在表现形式上非常相近，在代码中写法几乎都是相同的，但是JSONP与Ajax是完全不同的原理。JSONP是以请求文件数据的方式向服务器发出请求，而Ajax是使用XMLHttpRequest向服务器异步发出请求。 优点JSONP并不需要浏览器特殊支持，可以说所有的浏览器都是支持JSONP请求的。而且目前各流行JavaScript类库对JSONP的支持已经很全面，开发中也比较方便。 缺点但JSONP的请求只能是GET请求，因为在请求URL有长度限制，一般情况下只要不超过2000字符都是可以的(What is the maximum length of a URL?)，主流浏览器所支持的长度也越来越放宽，基本是可以满足条件的。JSONP的web服务端接口因为无法限制接收指定域名的请求，因此在实际应用中需要在安全性方面进行更多限制，以避免接口数据泄漏。 2. CORS（Cross-origin resource sharing）主要是通过定义浏览器与服务器之间共享内容的方式来实现跨域。CORS通过新增一系列 HTTP 头（Access-Control-Allow-Origin，Access-Control-Expose-Headers，Access-Control-Max-Age，Access-Control-Allow-Credentials，Access-Control-Allow-Methods，Access-Control-Allow-Headers等），让服务器能声明那些来源可以通过浏览器访问该服务器上的资源。另外，对那些会对服务器数据造成破坏性影响的 HTTP 请求方法（特别是 GET 以外的 HTTP 方法，或者搭配某些MIME类型的POST请求），标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求(preflight request)，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）。 2.1 运行模式 如果只使用简单请求向服务器发出请求，则浏览器就不需要向服务器发送预请求，服务器端只需要在response中增加Access-Control-Allow-Origin就可以了，开发非常简单，在代码上和Ajax请求几乎没有区别。 简单请求：只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。不会使用自定义请求头（类似于 X-Modified 这种）。但请求以如果 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求或者使用自定义请求头（比如添加诸如 X-PINGOTHER）时，浏览器就需要向服务器发送预请求，以确定服务器是否支持后续请求，如果支持，浏览器则继续发送后续Ajax请求。 2.2 JQuery支持CORS123456789101112$.ajax(&#123; //PUT 和DELETE 需要发送预请求 type: 'HTTP METHOD',//如GET ，POST url: 'cross-domain-url', contentType:, xhrFields: &#123; withCredentials: false &#125;, headers: &#123;&#125;, success: function () &#123;&#125;, error: function () &#123;&#125; &#125;); 详细的使用参见HTTP访问控制(CORS)。 2.3 与JSONP相比CORS的开发更为简单，对安全性的控制更为灵活，且目前所有的现代浏览器都已经支持了CORS模式，CORS支持所有的HTTP Method类型，在Restful请求中可以实现跨域。 3. 跨域访问在点评的应用在点评，很多功能采用动静分离的方式，在项目部署上也采用前端静态文件资源与后端web服务独立域名的方式进行；这种模式下，后端的HTTP 接口对于前端而言是一个服务接口；例如一个查询用户是否登录的接口，可能会被多个项目使用，因此就要求服务端接口支持跨域请求。目前在点评中主要使用JSONP的方式来实现跨域请求；因为CORS算是一个新技术，因此还没有大规模使用，只会在一些不重要的功能中使用过。 References JSONPWhat is the maximum length of a URL?CORS（Cross-origin resource sharing）Cross-Origin Resource SharingHTTP访问控制(CORS)JQuery CORS support IE’s XDomainRequest object plugin","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"webpack配置","date":"2016-11-03T12:01:51.000Z","path":"2016/11/03/Framework/Webpack/Webpack配置/","text":"全局安装webpack配置webpack.config.js文件1234567891011121314151617181920212223242526var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: &#123; app: './src/main.js' // 文件入口 &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js', // 最终编译后的js文件 &#125;, // 配置自动刷新相关内容 devtooll: 'eval', devServer: &#123; contentBase: __dirname + '/src', hot: true, inline: true, port: 8080, host: 'localhost', historyApiFallback: true, noInfo: false, // stats: 'minimal', // publicPath: publicPath &#125;, plugins: &#123; new webpack.HotModuleReplacementPlugin() &#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Directive的基本使用","date":"2016-10-03T13:50:52.000Z","path":"2016/10/03/Framework/AngularJS/directive/","text":"angular directive什么是指令呢？我们先看官方的说法 What are Directives?At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS’s HTML compiler ($compile) to attach a specified behavior to that DOM element (e.g. via event listeners), or even to transform the DOM element and its children. AngularJS comes with a set of these directives built-in, like ngBind, ngModel, and ngClass. Much like you create controllers and services, you can create your own directives for AngularJS to use. When AngularJS bootstraps your application, the HTML compiler traverses the DOM matching directives against the DOM elements. 在高的层面上讲，指令是DOM元素中的标记(例如一个属性，一个节点名，注释或者CSS类)，它告诉angularjs编译器去给这个元素附加一个指令的行为或者转换DOM元素和它的子元素。 Angularjs拥有一些内建的指令，像ngBind、ngModel和ngClass。非常类似于你创建自己的controller和service，你可以创建你自己的指令个angularjs使用，当angular初始化启动你的应用程序，html编译器将遍历你的DOM元素并且去匹配指令。 实例解析expander 实例解析accordion 指令的运行原理 compile和link restrict匹配模式 A 属性 &lt;div hello&gt;&lt;/div&gt; E element 元素 &lt;hello&gt;&lt;/hello&gt; M 注释 &lt;!-- directive:hello --&gt; 要加空格 &lt;div&gt;&lt;/div&gt; C 样式类 &lt;div class=&quot;hello&quot;&gt;&lt;/div&gt; 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt;&lt;/hello&gt; &lt;div hello&gt;&lt;/div&gt; &lt;div class=\"hello\"&gt;&lt;/div&gt; &lt;!-- directive:hello --&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"HelloAngular_Directive.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict: 'AEMC', template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', replace: true &#125;&#125;); templateUrl:模板 12345678910111213141516var myModule = angular.module(\"MyModule\", []);//注射器加载完所有模块时，此方法执行一次myModule.run(function($templateCache)&#123; //把内容缓存起来 $templateCache.put(\"hello.html\",\"&lt;div&gt;Hello everyone!!!!!!&lt;/div&gt;\");&#125;);myModule.directive(\"hello\", function($templateCache) &#123; return &#123; restrict: 'AECM', //把缓存取出来 template: $templateCache.get(\"hello.html\"), replace: true &#125;&#125;); replace开启的话，就会把我们模板里面的内容替换掉 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt; //当我们的页面启动后就会把这段内容替换掉 &lt;div&gt;这里是指令内部的内容。&lt;/div&gt; &lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"replace.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict:\"AE\", template:\"&lt;div&gt;Hello everyone!&lt;/div&gt;\", replace:true &#125; &#125;); ng-transclude只有这个指令可以使用多个多个指令之前多层嵌套，所以很重要 12345678910111213&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt; &lt;div&gt;这里是指令内部的内容。&lt;/div&gt; &lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"transclude.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict:\"AE\", transclude:true, // ng-transclude告诉angular被替换的内容填充到哪里去 template:\"&lt;div&gt;Hello everyone!&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;\" &#125; &#125;); link取属性的方式添加监听事件，以及实现指令与多个控制器之间进行交互 1234567891011121314151617&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; &lt;loader howToLoad=\"loadData()\"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;div ng-controller=\"MyCtrl2\"&gt; //定义属性这样让我们的directive去调用 &lt;loader howToLoad=\"loadData2()\"&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Directive&amp;Controller.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.loadData=function()&#123; console.log(\"加载数据中...\"); &#125;&#125;]);myModule.controller('MyCtrl2', ['$scope', function($scope)&#123; $scope.loadData2=function()&#123; console.log(\"加载数据中...22222\"); &#125;&#125;]);myModule.directive(\"loader\", function() &#123; return &#123; restrict:\"AE\", link:function(scope,element,attrs)&#123; //这里和jquery一样，给这个loader directive元素添加一个mouseenter事件，然后去调用上面的函数 element.bind('mouseenter', function(event) &#123; //scope.loadData(); //强制刷新以及调用上面的函数 // scope.$apply(\"loadData()\"); // 注意这里的坑，howToLoad会被转换成小写的howtoload //给我们的页面上的指令加了属性，然后通过不同的属性来调用不同函数，这样子也实现了指令的 //复用，指令就是为了复用，就可以在不同的控制器中去复用指令，以及实现数据交互 scope.$apply(attrs.howtoload); &#125;); &#125; &#125; &#125;); link实现多个指令之间的通信1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Directive&amp;Directive.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength&gt;动感超人---力量&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength speed&gt;动感超人2---力量+敏捷&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;superman strength speed light&gt;动感超人3---力量+敏捷+发光&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var myModule = angular.module(\"MyModule\", []);myModule.directive(\"superman\", function() &#123; return &#123; //创建独立作用域，下面一个例子会讲解独立scope scope: &#123;&#125;, restrict: 'AE', //指令内部的controller，作用是我们的指令暴露出public方法供外部使用 controller: function($scope) &#123; $scope.abilities = []; this.addStrength = function() &#123; $scope.abilities.push(\"strength\"); &#125;; this.addSpeed = function() &#123; $scope.abilities.push(\"speed\"); &#125;; this.addLight = function() &#123; $scope.abilities.push(\"light\"); &#125;; &#125;, //link是指令内部的一些方法 link: function(scope, element, attrs) &#123; //给我们的元素增加classname element.addClass('btn btn-primary'); //绑定事件 element.bind(\"mouseenter\", function() &#123; console.log(scope.abilities); &#125;); &#125; &#125;&#125;);myModule.directive(\"strength\", function() &#123; return &#123; //require是说strength指令依赖于superman这个指令 require: '^superman', //当有了依赖之后，我们就可以注入第四个参数了，这样子我们就可以访问到supermanCtrl里面暴露出来的公用方法了 link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addStrength(); &#125; &#125;&#125;);myModule.directive(\"speed\", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addSpeed(); &#125; &#125;&#125;);myModule.directive(\"light\", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addLight(); &#125; &#125;&#125;); 独立scpe123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"IsolateScope.js\"&gt;&lt;/script&gt;&lt;/html&gt; 123456789var myModule = angular.module(\"MyModule\", []);myModule.directive(\"hello\", function() &#123; return &#123; restrict: 'AE', // scope:&#123;&#125;,// 如果不加这个参数的话，我们页面中所有的指令都会同时发生改变互相影响，这显然是不是我们想要的 template: '&lt;div&gt;&lt;input type=\"text\" ng-model=\"userName\"/&gt;&#123;&#123;userName&#125;&#125;&lt;/div&gt;', replace: true &#125;&#125;); scope绑定策略 @绑定 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; //需要注意的是@绑定传递的是字符串，而不是对象 &lt;drink flavor=\"&#123;&#123;ctrlFlavor&#125;&#125;\"&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeAt.js\"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314151617181920var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; //控制器上面加个一个属性 $scope.ctrlFlavor=\"百威\";&#125;])myModule.directive(\"drink\", function() &#123; return &#123; restrict:'AE', scope:&#123; //而这种方式angular则会帮我们自动绑定数据 flavor:'@' &#125;, template:\"&lt;div&gt;&#123;&#123;flavor&#125;&#125;&lt;/div&gt;\" // , //下面这种方式指定我们的flavor的数据是我们的控制器中的数据 // link:function(scope,element,attrs)&#123; // scope.flavor=attrs.flavor; // &#125; &#125;&#125;); ScopeEqual绑定 进行双向数据绑定，也就是我们控制器与指令之间进行双向的数据绑定 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; Ctrl: &lt;br&gt; //这儿是我们控制器中的ctrlFlavor &lt;input type=\"text\" ng-model=\"ctrlFlavor\"&gt; &lt;br&gt; Directive: &lt;br&gt; //这儿展示我们指令中的flavor &lt;drink flavor=\"ctrlFlavor\"&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeEqual.js\"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314var myModule = angular.module(\"MyModule\", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.ctrlFlavor=\"百威\";&#125;])myModule.directive(\"drink\", function() &#123; return &#123; restrict:'AE', scope:&#123; //用=绑定就可以只要改变我们指令中的flavor就可以改变我们的控制器中的ctrlFlavor，反之我们改变控制器中的也可以改变指令中的 flavor:'=' &#125;, template:'&lt;input type=\"text\" ng-model=\"flavor\"/&gt;' &#125;&#125;); &amp;scope 实现控制器与指令之间的交互，比link要方便,传递一个来自父scope的函数，稍后调用 1234567891011121314151617&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"MyCtrl\"&gt; //这里我们传递的参数是对象，跟上面说的@scope不同 &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;greeting greet=\"sayHello(name)\"&gt;&lt;/greeting&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ScopeAnd.js\"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819var myModule = angular.module(\"MyModule\", [] ;myModule.controller('MyCtrl', ['$scope', function($scope)&#123; //暴露出一个方法就可以被我们的指令进行调用 $scope.sayHello=function(name)&#123; alert(\"Hello \"+name); &#125;&#125;])myModule.directive(\"greeting\", function() &#123; return &#123; restrict:'AE', scope:&#123; greet:'&amp;' &#125;, //在下面我们添加一个方法进行调用我们上面的控制器暴露出来的sayHello方法 //传递参数的形式是对象的形式 template:'&lt;input type=\"text\" ng-model=\"userName\" /&gt;&lt;br/&gt;'+ '&lt;button class=\"btn btn-default\" ng-click=\"greet(&#123;name:userName&#125;)\"&gt;Greeting&lt;/button&gt;&lt;br/&gt;' &#125;&#125;); angular内置指令在我用的1.3.11中共计63个 form指令 FormBasic 12345678910111213141516&lt;html ng-app='TestFormModule'&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormBasic.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form name=\"myForm\" ng-submit=\"save()\" ng-controller=\"TestFormModule\"&gt; //required属性就是我们的angular帮我们自动校验 &lt;input name=\"userName\" type=\"text\" ng-model=\"user.userName\" required/&gt; &lt;input name=\"password\" type=\"password\" ng-model=\"user.password\" required/&gt; //ng-disabled把它绑定到myForm.$invalid上就可以判断我们的按钮是否可用的状态 &lt;input type=\"submit\" ng-disabled=\"myForm.$invalid\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345678910var appModule = angular.module('TestFormModule', []);appModule.controller(\"TestFormModule\",function($scope)&#123; $scope.user=&#123; userName:'damoqiongqiu', password:'' &#125;; $scope.save=function()&#123; alert(\"保存数据!\"); &#125;&#125;); formadv1 下面是复杂一点的表单 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html ng-app&gt; &lt;head&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormAdv1.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"Controller\"&gt; &lt;form name=\"form\" class=\"css-form\" novalidate&gt; Name: &lt;input type=\"text\" ng-model=\"user.name\" name=\"uName\" required /&gt;&lt;br/&gt; E-mail: &lt;input type=\"email\" ng-model=\"user.email\" name=\"uEmail\" required /&gt;&lt;br/&gt; //校验我们的Email是否合法form.uEmail.$dirty &amp;&amp; form.uEmail.$invalid &lt;div ng-show=\"form.uEmail.$dirty &amp;&amp; form.uEmail.$invalid\"&gt; Invalid: &lt;span ng-show=\"form.uEmail.$error.required\"&gt;Tell us your email.&lt;/span&gt; &lt;span ng-show=\"form.uEmail.$error.email\"&gt;This is not a valid email.&lt;/span&gt; &lt;/div&gt; Gender:&lt;br/&gt; &lt;input type=\"radio\" ng-model=\"user.gender\" value=\"male\" /&gt; male &lt;input type=\"radio\" ng-model=\"user.gender\" value=\"female\" /&gt; female&lt;br/&gt; &lt;input type=\"checkbox\" ng-model=\"user.agree\" name=\"userAgree\" required /&gt; I agree: &lt;input ng-show=\"user.agree\" type=\"text\" ng-model=\"user.agreeSign\" required /&gt; &lt;div ng-show=\"!user.agree || !user.agreeSign\"&gt; Please agree and sign. &lt;/div&gt; &lt;br/&gt; &lt;button ng-click=\"reset()\" ng-disabled=\"isUnchanged(user)\"&gt; RESET &lt;/button&gt; &lt;button ng-click=\"update(user)\" ng-disabled=\"form.$invalid || isUnchanged(user)\"&gt; SAVE &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617function Controller($scope) &#123; $scope.master = &#123;&#125;; $scope.update = function(user) &#123; $scope.master = angular.copy(user); &#125;; $scope.reset = function() &#123; $scope.user = angular.copy($scope.master); &#125;; $scope.isUnchanged = function(user) &#123; return angular.equals(user, $scope.master); &#125;; $scope.reset();&#125; 下面说一个比较酷的功能 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html ng-app=\"form-example2\"&gt; &lt;head&gt; &lt;link href=\"../bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\" media=\"screen\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"FormCustom.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div[contentEditable] &#123; cursor: pointer; background-color: #D0D0D0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; //开启contentEditable可以让我们的div有input的功能 &lt;div contentEditable=\"true\" ng-model=\"content\" title=\"Click to edit\"&gt;Some&lt;/div&gt; &lt;pre&gt;model = &#123;&#123;content&#125;&#125;&lt;/pre&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021angular.module('form-example2', []).directive('contenteditable', function() &#123; return &#123; require : 'ngModel', link : function(scope, elm, attrs, ctrl) &#123; // view -&gt; model elm.bind('keyup', function() &#123; scope.$apply(function() &#123; ctrl.$setViewValue(elm.text()); &#125;); &#125;); // model -&gt; view ctrl.$render = function() &#123; elm.html(ctrl.$viewValue); &#125;; // load init value from DOM ctrl.$setViewValue(elm.html()); &#125; &#125;;&#125;); 自定义指令 123456789101112131415&lt;html ng-app='expanderModule'&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"ExpanderSimple.css\"/&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ExpanderSimple.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller='SomeController'&gt; &lt;expander class='expander' expander-title='title'&gt; &#123;&#123;text&#125;&#125; &lt;/expander&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031var expanderModule=angular.module('expanderModule', []);expanderModule.directive('expander', function() &#123; return &#123; //这里我们的匹配模式定义的是也可以用元素也可以用属性 restrict : 'EA', // 替换 replace : true, //内部的内容是可以变换的 transclude : true, scope : &#123; //用=号进行scope双向数据绑定 title : '=expanderTitle' &#125;, //ng-click=\"toggle()这里的click只能调用我们内部的toggle template : '&lt;div&gt;' + '&lt;div class=\"title\" ng-click=\"toggle()\"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' + '&lt;div class=\"body\" ng-show=\"showMe\" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', link : function(scope, element, attrs) &#123; scope.showMe = false; //这里我们定义的toggle只能在指令内部进行调用 scope.toggle = function() &#123; scope.showMe = !scope.showMe; &#125; &#125; &#125;&#125;);expanderModule.controller('SomeController',function($scope) &#123; $scope.title = '点击展开'; $scope.text = '这里是内部的内容。';&#125;); 123456789101112131415.expander &#123; border: 1px solid black; width: 250px;&#125;.expander&gt;.title &#123; background-color: black; color: white; padding: .1em .3em; cursor: pointer;&#125;.expander&gt;.body &#123; padding: .1em .3em;&#125; 再来一个 123456789101112131415&lt;html ng-app=\"expanderModule\"&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"Accordion.css\"/&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"Accordion.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-controller='SomeController' &gt; &lt;accordion&gt; &lt;expander class='expander' ng-repeat='expander in expanders' expander-title='expander.title'&gt; &#123;&#123;expander.text&#125;&#125; &lt;/expander&gt; &lt;/accordion&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var expModule=angular.module('expanderModule',[])expModule.directive('accordion', function() &#123; return &#123; restrict : 'EA', replace : true, transclude : true, template : '&lt;div ng-transclude&gt;&lt;/div&gt;', //对外暴露方法 controller : function() &#123; var expanders = []; this.gotOpened = function(selectedExpander) &#123; angular.forEach(expanders, function(expander) &#123; if (selectedExpander != expander) &#123; expander.showMe = false; &#125; &#125;); &#125; this.addExpander = function(expander) &#123; expanders.push(expander); &#125; &#125; &#125;&#125;);expModule.directive('expander', function() &#123; return &#123; restrict : 'EA', replace : true, transclude : true, //依赖于accordion指令 require : '^?accordion', scope : &#123; title : '=expanderTitle' &#125;, template : '&lt;div&gt;' + '&lt;div class=\"title\" ng-click=\"toggle()\"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' + '&lt;div class=\"body\" ng-show=\"showMe\" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', link : function(scope, element, attrs, accordionController) &#123; scope.showMe = false; accordionController.addExpander(scope); scope.toggle = function toggle() &#123; scope.showMe = !scope.showMe; accordionController.gotOpened(scope); &#125; &#125; &#125;&#125;);expModule.controller(\"SomeController\",function($scope) &#123; $scope.expanders = [&#123; title : 'Click me to expand', text : 'Hi there folks, I am the content that was hidden but is now shown.' &#125;, &#123; title : 'Click this', text : 'I am even better text than you have seen previously' &#125;, &#123; title : 'Test', text : 'test' &#125;];&#125;); 123456789101112131415.expander &#123; border: 1px solid black; width: 250px;&#125;.expander&gt;.title &#123; background-color: black; color: white; padding: .1em .3em; cursor: pointer;&#125;.expander&gt;.body &#123; padding: .1em .3em;&#125; 看到没，其实编写自定义指令还是比较困难的，所以我们可以去引入一些第三方的指令库 这样子，就可以极大地方便实现我们想要的功能了 再来个难一点的自定义指令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!doctype html&gt;&lt;html ng-app=\"MyModule\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"framework/bootstrap-3.0.0/css/bootstrap.css\"&gt; &lt;link rel=\"stylesheet\" href=\"common.css\"&gt; &lt;script src=\"framework/angular-1.3.0.14/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"framework/ui-bootstrap-tpls-0.11.0.js\"&gt;&lt;/script&gt; &lt;script src=\"Accordion-ngui.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;div ng-controller=\"AccordionDemoCtrl\"&gt; &lt;p&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"status.open = !status.open\"&gt;Toggle last panel&lt;/button&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"status.isFirstDisabled = ! status.isFirstDisabled\"&gt;Enable / Disable first panel&lt;/button&gt; &lt;/p&gt; &lt;label class=\"checkbox\"&gt; &lt;input type=\"checkbox\" ng-model=\"oneAtATime\"&gt;Open only one at a time &lt;/label&gt; &lt;accordion close-others=\"oneAtATime\"&gt; &lt;accordion-group heading=\"Static Header, initially expanded\" is-open=\"status.isFirstOpen\" is-disabled=\"status.isFirstDisabled\"&gt; This content is straight in the template. &lt;/accordion-group&gt; &lt;accordion-group heading=\"&#123;&#123;group.title&#125;&#125;\" ng-repeat=\"group in groups\"&gt; &#123;&#123;group.content&#125;&#125; &lt;/accordion-group&gt; &lt;accordion-group heading=\"Dynamic Body Content\"&gt; &lt;p&gt;The body of the accordion group grows to fit the contents&lt;/p&gt; &lt;button class=\"btn btn-default btn-md\" ng-click=\"addItem()\"&gt;Add Item&lt;/button&gt; &lt;div ng-repeat=\"item in items\"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/accordion-group&gt; &lt;accordion-group is-open=\"status.open\"&gt; &lt;accordion-heading&gt; I can have markup, too! &lt;i class=\"pull-right glyphicon\" ng-class=\"&#123;'glyphicon-chevron-down': status.open, 'glyphicon-chevron-right': !status.open&#125;\"&gt;&lt;/i&gt; &lt;/accordion-heading&gt; This is just some content to illustrate fancy headings. &lt;/accordion-group&gt; &lt;/accordion&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627var myModule = angular.module('MyModule', ['ui.bootstrap']);myModule.controller('AccordionDemoCtrl', ['$scope', function($scope) &#123; $scope.oneAtATime = true; $scope.groups = [&#123; title: 'Dynamic Group Header - 1', content: 'Dynamic Group Body - 1' &#125;, &#123; title: 'Dynamic Group Header - 2', content: 'Dynamic Group Body - 2' &#125;]; $scope.items = ['Item 1', 'Item 2', 'Item 3']; $scope.addItem = function() &#123; var newItemNo = $scope.items.length + 1; $scope.items.push('Item ' + newItemNo); &#125;; $scope.status = &#123; isFirstOpen: true, isFirstDisabled: false &#125;; &#125;])","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"深入理解javascript之编写高质量javascript代码的基本要点","date":"2016-10-01T13:50:52.000Z","path":"2016/10/01/JavaScript/深入理解javascript之编写高质量javascript代码的基本要点/","text":"才华横溢的Stoyan Stefanov，在他写的由O’Reilly初版的新书《JavaScript Patterns》(JavaScript模式)中，我想要是为我们的读者贡献其摘要，那会是件很美妙的事情。具体一点就是编写高质量JavaScript的一些要素，例如避免全局变量，使用单变量声明，在循环中预缓存length(长度)，遵循代码阅读，以及更多。 此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写API文档、执行同行评审以及运行JSLint。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码，这些代码在几个月或是几年之后再回过头看看也是会觉得很自豪的。 书写可维护的代码(Writing Maintainable Code )软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要： 花时间学习和理解这个问题 化时间是了解应该解决的问题代码 还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。 另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。 你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如： bug是暴露的 新功能被添加到应用程序 程序在新的环境下工作（例如，市场上出现新想浏览器） 代码改变用途 代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言 由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。 可维护的代码意味着： 可读的 一致的 可预测的 看上去就像是同一个人写的 已记录 最小全局变量(Minimizing Globals)JavaScript通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。 每个JavaScript环境有一个全局对象，当你在任意的函数外面使用this的时候可以访问到。你创建的每一个全部变量都成了这个全局对象的属 性。在浏览器中，方便起见，该全局对象有个附加属性叫做window，此window(通常)指向该全局对象本身。下面的代码片段显示了如何在浏览器环境 中创建和访问的全局变量： 12345myglobal = \"hello\"; // 不推荐写法console.log(myglobal); // \"hello\"console.log(window.myglobal); // \"hello\"console.log(window[\"myglobal\"]); // \"hello\"console.log(this.myglobal); // \"hello\" 全局变量的问题全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。 web页面包含不是该页面开发者所写的代码也是比较常见的，例如： 第三方的JavaScript库 广告方的脚本代码 第三方用户跟踪和分析脚本代码 不同类型的小组件，标志和按钮 比方说，该第三方脚本定义了一个全局变量，叫做result；接着，在你的函数中也定义一个名为result的全局变量。其结果就是后面的变量覆盖前面的，第三方脚本就一下子嗝屁啦！ 因此，要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。在书中后面提到的一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。 由于JavaScript的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码：1234function sum(x, y) &#123; // 不推荐写法: 隐式全局变量 result = x + y; return result;&#125; 此段代码中的result没有声明。代码照样运作正常，但在调用函数后你最后的结果就多一个全局命名空间，这可以是一个问题的根源。 经验法则是始终使用var声明变量，正如改进版的sum()函数所演示的：1234function sum(x, y) &#123; var result = x + y; return result;&#125; 另一个创建隐式全局变量的反例就是使用任务链进行部分var声明。下面的片段中，a是本地变量但是b确实全局变量，这可能不是你希望发生的：12345// 反例，勿使用 function foo() &#123; var a = b = 0; // ...&#125; 此现象发生的原因在于这个从右到左的赋值，首先，是赋值表达式b = 0，此情况下b是未声明的。这个表达式的返回值是0，然后这个0就分配给了通过var定义的这个局部变量a。换句话说，就好比你输入了： 1var a = (b = 0); 如果你已经准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量，如：1234function foo() &#123; var a, b; // ... a = b = 0; // 两个均局部变量&#125; 然而，另外一个避免全局变量的原因是可移植性。如果你想你的代码在不同的环境下（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心大胆地使用，实际上对于有些情况并不适用）。 忘记var的副作用(Side Effects When Forgetting var)隐式全局变量和明确定义的全局变量间有些小的差异，就是通过delete操作符让变量未定义的能力。 通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。 无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。 这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过delete操作符删除的，而变量是不能的：123456789101112131415// 定义三个全局变量var global_var = 1;global_novar = 2; // 反面教材(function () &#123; global_fromfunc = 3; // 反面教材&#125;());// 试图删除delete global_var; // falsedelete global_novar; // truedelete global_fromfunc; // true// 测试该删除typeof global_var; // \"number\"typeof global_novar; // \"undefined\"typeof global_fromfunc; // \"undefined\" 在ES5严格模式下，未声明的变量（如在前面的代码片段中的两个反面教材）工作时会抛出一个错误。 访问全局对象(Access to the Global Object)在浏览器中，全局对象可以通过window属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的window标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：123var global = (function () &#123; return this;&#125;()); 这种方法可以随时获得全局对象，因为其在函数中被当做函数调用了（不是通过new构造），this总 是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。 单var形式（Single var Pattern）在函数顶部使用单var语句是比较有用的一种形式，其好处在于： 提供了一个单一的地方去寻找功能所需要的所有局部变量 防止变量在定义之前使用的逻辑错误 帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的… 少代码（类型啊传值啊单线完成） 单var形式长得就像下面这个样子：123456789function func() &#123; var a = 1, b = 2, sum = a + b, myobject = &#123;&#125;, i, j; // function body...&#125; 您可以使用一个var语句声明多个变量，并以逗号分隔。像这种初始化变量同时初始化值的做法是很好的。这样子可以防止逻辑错误（所有未初始化但声明的变量的初始值是undefined）和增加代码的可读性。在你看到代码后，你可以根据初始化的值知道这些变量大致的用途，例如是要当作对象呢还是当作整数来使。 你也可以在声明的时候做一些实际的工作，例如前面代码中的sum = a + b这个情况，另外一个例子就是当你使用DOM（文档对象模型）引用时，你可以使用单一的var把DOM引用一起指定为局部变量，就如下面代码所示的：12345function updateElement() &#123; var el = document.getElementById(\"result\"), style = el.style; // 使用el和style干点其他什么事...&#125; 预解析：var散布的问题(Hoisting: A Problem with Scattered vars)JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。看下面这个例子：12345678// 反例myname = \"global\"; // 全局变量function func() &#123; alert(myname); // \"undefined\" var myname = \"local\"; alert(myname); // \"local\"&#125;func(); 在这个例子中，你可能会以为第一个alert弹出的是”global”，第二个弹出”loacl”。这种期许是可以理解的，因为在第一个alert 的时候，myname未声明，此时函数肯定很自然而然地看全局变量myname，但是，实际上并不是这么工作的。第一个alert会弹 出”undefined”是因为myname被当做了函数的局部变量（尽管是之后声明的），所有的变量声明当被悬置到函数的顶部了。因此，为了避免这种混 乱，最好是预先声明你想使用的全部变量。 上面的代码片段执行的行为可能就像下面这样：12345678myname = \"global\"; // global variablefunction func() &#123; var myname; // 等同于 -&gt; var myname = undefined; alert(myname); // \"undefined\" myname = \"local\"; alert(myname); // \"local\"&#125;func(); 为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文 的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了”hoisting”这个概念， 这种ECMAScript标准中并未定义，通常用来描述行为。 for循环(for Loops)在for循环中，你可以循环取得数组或是数组类似对象的值，譬如arguments和HTMLCollection对象。通常的循环形式如下：1234// 次佳的循环for (var i = 0; i &lt; myarray.length; i++) &#123; // 使用myarray[i]做点什么&#125; 这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当myarray不是数组，而是一个HTMLCollection对象的时候。 HTMLCollections指的是DOM方法返回的对象，例如：123document.getElementsByName()document.getElementsByClassName()document.getElementsByTagName() 还有其他一些HTMLCollections，这些是在DOM标准之前引进并且现在还在使用的。有：1234document.images: 页面上所有的图片元素document.links : 所有a标签元素document.forms : 所有表单document.forms[0].elements : 页面上第一个表单中的所有域 集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。 这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的：123for (var i = 0, max = myarray.length; i &lt; max; i++) &#123; // 使用myarray[i]做点什么&#125; 这样，在这个循环过程中，你只检索了一次长度值。 在所有浏览器下，循环获取内容时缓存HTMLCollections的长度是更快的，2倍(Safari3)到190倍(IE7)之间。//zxx:此数据貌似很老，仅供参考 注意到，当你明确想要修改循环中的集合的时候（例如，添加更多的DOM元素），你可能更喜欢长度更新而不是常量。 伴随着单var形式，你可以把变量从循环中提出来，就像下面这样：123456789function looper() &#123; var i = 0, max, myarray = []; // ... for (i = 0, max = myarray.length; i &lt; max; i++) &#123; // 使用myarray[i]做点什么 &#125;&#125; 这种形式具有一致性的好处，因为你坚持了单一var形式。不足在于当重构代码的时候，复制和粘贴整个循环有点困难。例如，你从一个函数复制了一个循环到另一个函数，你不得不去确定你能够把i和max引入新的函数（如果在这里没有用的话，很有可能你要从原函数中把它们删掉）。 最后一个需要对循环进行调整的是使用下面表达式之一来替换i++。12i = i + 1i += 1 JSLint提示您这样做，原因是++和–-促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手如果你直接无视它，JSLint的plusplus选项会是false（默认是default）。 还有两种变化的形式，其又有了些微改进，因为： 少了一个变量(无max) 向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率123456789101112//第一种变化的形式：var i, myarray = [];for (i = myarray.length; i–-;) &#123; // 使用myarray[i]做点什么&#125;//第二种使用while循环：var myarray = [], i = myarray.length;while (i–-) &#123; // 使用myarray[i]做点什么&#125; 这些小的改进只体现在性能上，此外JSLint会对使用i–-加以抱怨。 for-in循环(for-in Loops)for-in循环应该用在非数组对象的遍历上，使用for-in进行循环也被称为“枚举”。 从技术上将，你可以使用for-in循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。 有个很重要的hasOwnProperty()方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。 思考下面一段代码：123456789101112// 对象var man = &#123; hands: 2, legs: 2, heads: 1&#125;;// 在代码的某个地方// 一个方法添加给了所有对象if (typeof Object.prototype.clone === \"undefined\") &#123; Object.prototype.clone = function () &#123;&#125;;&#125; 在这个例子中，我们有一个使用对象字面量定义的名叫man的对象。在man定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举man的时候出现clone()方法，你需要应用hasOwnProperty()方法过滤原型属性。如果不做过滤，会导致clone()函数显示出来，在大多数情况下这是不希望出现的。123456789101112131415161718192021222324// 1.// for-in 循环for (var i in man) &#123; if (man.hasOwnProperty(i)) &#123; // 过滤 console.log(i, \":\", man[i]); &#125;&#125;/* 控制台显示结果hands : 2legs : 2heads : 1*/// 2.// 反面例子:// for-in loop without checking hasOwnProperty()for (var i in man) &#123; console.log(i, \":\", man[i]);&#125;/*控制台显示结果hands : 2legs : 2heads : 1clone: function()*/ 另外一种使用hasOwnProperty()的形式是取消Object.prototype上的方法。像是：12345for (var i in man) &#123; if (Object.prototype.hasOwnProperty.call(man, i)) &#123; // 过滤 console.log(i, \":\", man[i]); &#125;&#125; 其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。123456var i, hasOwn = Object.prototype.hasOwnProperty;for (i in man) &#123; if (hasOwn.call(man, i)) &#123; // 过滤 console.log(i, \":\", man[i]); &#125;&#125; 严格来说，不使用hasOwnProperty()并不是一个错误。根据任务以及你对代码的自信程度，你可以跳过它以提高些许的循环速度。但是当你对当前对象内容（和其原型链）不确定的时候，添加hasOwnProperty()更加保险些。 格式化的变化（通不过JSLint）会直接忽略掉花括号，把if语句放到同一行上。其优点在于循环语句读起来就像一个完整的想法（每个元素都有一个自己的属性”X”，使用”X”干点什么）：12345// 警告： 通不过JSLint检测var i, hasOwn = Object.prototype.hasOwnProperty;for (i in man) if (hasOwn.call(man, i)) &#123; // 过滤 console.log(i, \":\", man[i]);&#125; （不）扩展内置原型((Not) Augmenting Built-in Prototypes)扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。 增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。 另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。 因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外： 可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。 如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。 你清楚地文档记录并和团队交流了变化。 如果这三个条件得到满足，你可以给原型进行自定义的添加，形式如下：12345if (typeof Object.protoype.myMethod !== \"function\") &#123; Object.protoype.myMethod = function () &#123; // 实现... &#125;;&#125; switch模式(switch Pattern)你可以通过类似下面形式的switch语句增强可读性和健壮性：123456789101112var inspect_me = 0, result = '';switch (inspect_me) &#123;case 0: result = \"zero\"; break;case 1: result = \"one\"; break;default: result = \"unknown\";&#125; 这个简单的例子中所遵循的风格约定如下： 每个case和switch对齐（花括号缩进规则除外） 每个case中代码缩进 每个case以break清除结束 避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。 以default结束switch：确保总有健全的结果，即使无情况匹配。 避免隐式类型转换(Avoiding Implied Typecasting )JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。123456789var zero = 0;if (zero === false) &#123; // 不执行，因为zero为0, 而不是false&#125;// 反面示例if (zero == false) &#123; // 执行了...&#125; 还有另外一种思想观点认为==就足够了===是多余的。例如，当你使用typeof你就知道它会返回一个字符串，所以没有使用严格相等的理由。然而，JSLint要求严格相等，它使代码看上去更有一致性，可以降低代码阅读时的精力消耗。（“==是故意的还是一个疏漏？”） 避免(Avoiding) eval()如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单：1234567// 反面示例var property = \"name\";alert(eval(\"obj.\" + property));// 更好的var property = \"name\";alert(obj[property]); 使用eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理Ajax请求得到的JSON 相应的时候。在这些情况下，最好使用JavaScript内置方法来解析JSON相应，以确保安全和有效。若浏览器不支持JSON.parse()，你可 以使用来自JSON.org的库。 同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。在幕后，JavaScript仍需要评估和执行你给程序传递的字符串：123456789// 反面示例setTimeout(\"myFunc()\", 1000);setTimeout(\"myFunc(1, 2, 3)\", 1000);// 更好的setTimeout(myFunc, 1000);setTimeout(function () &#123; myFunc(1, 2, 3);&#125;, 1000); 使用新的Function()构造就类似于eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用eval()，你 可以考虑使用new Function()代替。有一个小的潜在好处，因为在新Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。 考虑下面这个例子，这里仅un作为全局变量污染了命名空间。1234567891011121314console.log(typeof un); // \"undefined\"console.log(typeof deux); // \"undefined\"console.log(typeof trois); // \"undefined\"var jsstring = \"var un = 1; console.log(un);\";eval(jsstring); // logs \"1\"jsstring = \"var deux = 2; console.log(deux);\";new Function(jsstring)(); // logs \"2\"jsstring = \"var trois = 3; console.log(trois);\";(function () &#123; eval(jsstring);&#125;()); // logs \"3\"console.log(typeof un); // numberconsole.log(typeof deux); // \"undefined\"console.log(typeof trois); // \"undefined\" 另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。在下面这个例子中，eval()可以访问和修改它外部作用域中的变量，这是 Function做不来的（注意到使用Function和new Function是相同的）。12345678910(function () &#123; var local = 1; eval(\"local = 3; console.log(local)\"); // logs \"3\" console.log(local); // logs \"3\"&#125;());(function () &#123; var local = 1; Function(\"console.log(typeof local);\")(); // logs undefined&#125;()); parseInt()下的数值转换(Number Conversions with parseInt())使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数。1234var month = \"06\", year = \"09\";month = parseInt(month, 10);year = parseInt(year, 10); 此例中，如果你忽略了基数参数，如parseInt(year)，返回的值将是0，因为“09”被当做8进制（好比执行 parseInt( year, 8 )），而09在8进制中不是个有效数字。 替换方法是将字符串转换成数字，包括：12+\"08\" // 结果是 8Number(\"08\") // 8 这些通常快于parseInt()，因为parseInt()方法，顾名思意，不是简单地解析与转换。但是，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以NaN告终。 编码规范(Coding Conventions)建立和遵循编码规范是很重要的，这让你的代码保持一致性，可预测，更易于阅读和理解。一个新的开发者加入这个团队可以通读规范，理解其它团队成员书写的代码，更快上手干活。 许多激烈的争论发生会议上或是邮件列表上，问题往往针对某些代码规范的特定方面（例如代码缩进，是Tab制表符键还是space空格键）。如果你是 你组织中建议采用规范的，准备好面对各种反对的或是听起来不同但很强烈的观点。要记住，建立和坚定不移地遵循规范要比纠结于规范的细节重要的多。 缩进(Indentation)代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。 一些开发人员更喜欢用tab制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，使用四个空格缩进，这也是JSLint中默认的缩进。 什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do, while, for, for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例：12345678910111213141516171819function outer(a, b) &#123; var c = 1, d = 2, inner; if (a &gt; b) &#123; inner = function () &#123; return &#123; r: c - d &#125;; &#125;; &#125; else &#123; inner = function () &#123; return &#123; r: c + d &#125;; &#125;; &#125; return inner;&#125; 花括号{}(Curly Braces)花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在in或是for中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。 想象下你有一个只有一条语句的for循环，你可以忽略花括号，而没有解析的错误。123// 糟糕的实例for (var i = 0; i &lt; 10; i += 1) alert(i);&lt;/pre&gt; 但是，如果，后来，主体循环部分又增加了行代码？1234// 糟糕的实例for (var i = 0; i &lt; 10; i += 1) alert(i); alert(i + \" is \" + (i % 2 ? \"odd\" : \"even\")); 第二个alert已经在循环之外，缩进可能欺骗了你。为了长远打算，最好总是使用花括号，即时值一行代码：1234// 好的实例for (var i = 0; i &lt; 10; i += 1) &#123; alert(i);&#125; if条件类似：123456789101112// 坏if (true) alert(1);else alert(2);// 好if (true) &#123; alert(1);&#125; else &#123; alert(2);&#125; 左花括号的位置(Opening Brace Location)开发人员对于左大括号的位置有着不同的偏好——在同一行或是下一行。123456789if (true) &#123; alert(\"It's TRUE!\");&#125;//或if (true)&#123; alert(\"It's TRUE!\");&#125; 这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript是不挑剔的，当你选择不使用分号结束一行代码时JavaScript会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候：1234567// 警告： 意外的返回值function func() &#123; return // 下面代码不执行 &#123; name : \"Batman\" &#125;&#125; 如果你希望函数返回一个含有name属性的对象，你会惊讶。由于隐含分号，函数返回undefined。前面的代码等价于：1234567// 警告： 意外的返回值function func() &#123; return undefined; // 下面代码不执行 &#123; name : \"Batman\" &#125;&#125; 总之，总是使用花括号，并始终把在与之前的语句放在同一行：12345function func() &#123; return &#123; name : \"Batman\" &#125;;&#125; 关于分号注：就像使用花括号，你应该总是使用分号，即使他们可由JavaScript解析器隐式创建。这不仅促进更科学和更严格的代码，而且有助于解决存有疑惑的地方，就如前面的例子显示。 空格(White Space)空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在JavaScript中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。 适合使用空格的地方包括： for循环分号分开后的的部分：如for (var i = 0; i &lt; 10; i += 1) {...} for循环中初始化的多变量(i和max)：for (var i = 0, max = 10; i &lt; max; i += 1) {...} 分隔数组项的逗号的后面：var a = [1, 2, 3]; 对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = {a: 1, b: 2}; 限定函数参数：myFunc(a, b, c) 函数声明的花括号的前面：function myFunc() {} 匿名函数表达式function的后面：var myFunc = function () {}; 使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=等前后都需要空格。12345678910111213141516171819// 宽松一致的间距// 使代码更易读// 使得更加“透气”var d = 0, a = b + 1;if (a &amp;&amp; b &amp;&amp; c) &#123; d = a % c; a += d;&#125;// 反面例子// 缺失或间距不一// 使代码变得疑惑var d = 0, a = b + 1;if (a&amp;&amp;b&amp;&amp;c) &#123; d=a % c; a+= d;&#125; 最后需要注意的一个空格——花括号间距。最好使用空格： 函数、if-else语句、循环、对象字面量的左花括号的前面({) else或while之间的右花括号(}) 空格使用的一点不足就是增加了文件的大小，但是压缩无此问题。 有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。 命名规范(Naming Conventions)另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。 下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。 以大写字母写构造函数(Capitalizing Constructors)JavaScript并没有类，但有new调用的构造函数：1var adam = new Person(); 因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。 命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用：12function MyConstructor() &#123;...&#125;function myFunction() &#123;...&#125; 分隔单词(Separating Words)当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。 对于构造函数，可以使用大驼峰式命名法(upper camel case)，如MyConstructor()。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是myFunction(),calculateArea()和getFirstName()。 要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，first_name, favorite_bands,和old_company_name，这种标记法帮你直观地区分函数和其他标识——原型和对象。 ECMAScript的属性和方法均使用Camel标记法，尽管多字的属性名称是罕见的（正则表达式对象的lastIndex和ignoreCase属性）。 其它命名形式(Other Naming Patterns)有时，开发人员使用命名规范来弥补或替代语言特性。 例如，JavaScript中没有定义常量的方法（尽管有些内置的像Number, MAX_VALUE），所以开发者都采用全部单词大写的规范来命名这个程序生命周期中都不会改变的变量，如：123// 珍贵常数，只可远观var PI = 3.14, MAX_WIDTH = 800; 还有另外一个完全大写的惯例：全局变量名字全部大写。全部大写命名全局变量可以加强减小全局变量数量的实践，同时让它们易于区分。 另外一种使用规范来模拟功能的是私有成员。虽然可以在JavaScript中实现真正的私有，但是开发者发现仅仅使用一个下划线前缀来表示一个私有属性或方法会更容易些。考虑下面的例子：123456789101112var person = &#123; getName: function () &#123; return this._getFirst() + ' ' + this._getLast(); &#125;, _getFirst: function () &#123; // ... &#125;, _getLast: function () &#123; // ... &#125;&#125;; 在此例中，getName()就表示公共方法，部分稳定的API。而_getFirst()和_getLast()则表明了私有。它们仍然是正常的公共方法，但是使用下划线前缀来警告person对象的使用者这些方法在下一个版本中时不能保证工作的，是不能直接使用的。注意，JSLint有些不鸟下划线前缀，除非你设置了noman选项为:false。 下面是一些常见的_private规范： 使用尾下划线表示私有，如name_和getElements_() 使用一个下划线前缀表_protected（保护）属性，两个下划线前缀表示__private （私有）属性 Firefox中一些内置的变量属性不属于该语言的技术部分，使用两个前下划线和两个后下划线表示，如：__proto__和__parent__。 注释(Writing Comments)你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。 很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。 最重要的习惯，然而也是最难遵守的，就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。 关于作者（About the Author ）Stoyan Stefanov是Yahoo!web开发人员，多个O’Reilly书籍的作者、投稿者和技术评审。他经常在会议和他的博客www.phpied.com上发表web开发主题的演讲。Stoyan还是smush.it图片优化工具的创造者，YUI贡献者，雅虎性能优化工具YSlow 2.0的架构设计师。 本文转自：http://www.zhangxinxu.com/wordpress/?p=1173 英文原文：http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"node的安装和npm的简单介绍","date":"2016-03-05T16:00:00.000Z","path":"2016/03/06/Framework/Node/node的安装和npm的简单介绍/","text":"下载nodejs打开nodejs官网，你会看到两个绿色的按钮，一个是目前大多数人在用的，一个是目前最新的版本，的需要下载即可，它会根据系统信息选择对应版本（.msi文件）。然后像安装QQ一样安装它就可以了（安装路径随意） 检测nodejs是否安装上了打开命令提示符执行下列命令（打开方式：window + r 输入cmd回车）： node -v查看安装的nodejs版本，出现版本号，说明刚刚已正确安装nodejs。 npm -v查看npm的版本号，npm是在安装nodejs时一同安装的nodejs包管理器。 如果输入命令后告诉你node不是内部命令，那么请看下步配置环境变量 如果上述都能正常执行，恭喜你，安装成功了 配置环境变量 找到nodejs的安装目录，拷贝路径地址，默认是（C:\\Program Files\\nodejs） 找到桌面我的电脑图标，右键点击属性菜单弹出系统面板 点击系统面板的高级系统设置，弹出系统属性面板 点击属性面板的环境变量按钮，弹出环境变量面板 找到系统变量的path，双击，将nodejs的bin目录url添加到后面即可注意：在添加的时候确保前面有一个英文的分号 配置完之后继续输入命令，查看node和npm的版本npm介绍npm官网 说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）； 使用npm安装插件：命令提示符执行npm install &lt;name&gt; [-g] [--save-dev]； &lt;name&gt;：node插件名称。例：npm install gulp-less --save-dev -g：全局安装。将会安装C:\\Users\\Administrator\\AppData\\Roaming\\npm，并且写入系统环境变量； 非全局安装：将会安装在当前定位目录； 全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用； --save：将保存配置信息至package.json（package.json是nodejs项目配置文件）； -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；一般保存在dependencies的像这些express/ejs/body-parser等等。 为什么要保存至package.json？因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install --production 只下载dependencies节点的包）。 使用npm卸载插件：npm uninstall &lt;name&gt; [-g] [--save-dev] PS：不要直接删除本地插件包 删除全部插件：npm uninstall gulp-less gulp-uglify gulp-concat ……???太麻烦，请看下一个 借助rimraf：npm install rimraf -g 用法：rimraf node_modules 使用npm更新插件：npm update &lt;name&gt; [-g] [--save-dev] 更新全部插件：npm update [--save-dev] 查看npm帮助：npm help 当前目录已安装插件：npm listPS：npm安装插件过程：从 http://registry.npmjs.org 下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法往下看↓↓↓↓↓↓。 选装cnpm 说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。32个赞！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”； 官方网址：http://npm.taobao.org； 安装：命令提示符执行npm install cnpm -g --registry=https://registry.npm.taobao.org； 注意：安装完后最好查看其版本号 cnpm -v 或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"hexo图片链接问题","date":"2015-03-14T13:03:08.000Z","path":"2015/03/14/Hexo/hexo图片链接问题/","text":"文章转载自 http://www.tuicool.com/articles/umEBVfI 1. 起因在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。 这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。 hexo 下插入图片现在大概有几个方案 1.1 放在根目录早期大部分的方案是把图片放在 source/img 下，然后在 markdown 里写 ![img](/source/img/img.png) 。显然这样在本地的编辑器里完全不能正确识别图片的位置。 1.2 asset-image在 hexo 2.x 时出现的插件，后来被吸纳进 hexo 3 core ，用法的介绍见 资源文件夹 | Hexo 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 的语法。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。 2. 解决方案CodeFalling/hexo-asset-image 2.1 使用首先确认_config.yml 中有 post_asset_folder:true 。 在 hexo 目录，执行1npm install https://github.com/CodeFalling/hexo-asset-image --save 假设在 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg) 就可以插入图片。 生成的结构为12345public/2015/10/18/MacGesture2-Publish├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是1&lt;img src=\"/2015/10/18/MacGesture2-Publish/logo.jpg\" alt=\"logo\"&gt; 而不是愚蠢的1&lt;img src=\"MacGesture2-Publish/logo.jpg\" alt=\"logo\"&gt; 值得一提的是，这个插件对于 CodeFalling/hexo-renderer-org 同样有效。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"javascript之变量","date":"2015-03-10T13:40:20.000Z","path":"2015/03/10/JavaScript/javascript之变量/","text":"变量的定义在javascript中定义变脸是通过关键字 var、function 定义的，在ES6中还可以用let、const 的方式定义变量123456var str = &quot;hello world&quot;; // 定义了一个值为“hello world”的String类型变量var num = 10; // 定义了一个值为10的Number类型变量var boolean = true; // 定义了一个值为true的Boolean类型变量function ()&#123; // 定义一个Function类型，名为fn的函数 // 函数体&#125; javascript变量命名规范 规则（必须遵守） 由字母、数字、下划线、$组成 不能是关键字和保留字 区分大小写 规范（建议遵守） 变量的名称要有意义 变量的命名遵守驼峰命名法，首字母小写，第二个单词的首字母大写（eg：userName） 变量类型基本数据类型Number类型 整数 十进制 八进制 1) 如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当做十进制数值解析 十六进制 浮点数 小数 科学计数法 浮点数的最高精度是17位小数，但在进行算数计算时其精度远远不如整数 var result = 0.1 + 0.2;//结果不等于0.3，而是0.300000000000000004 永远不要测试某个特定的浮点数值（不要判断两个浮点数是否相等） 数值范围 最小值：Number.MIN_VALUE，这个值为：5e-324 最大值：Number.MAX_VALUE，这个值为：1.7976931348623157e+308 无穷大：Infinity 无穷小：-infinity 数值检测 NaN非数值（Not a Number） NaN与任何值都不相等，包括自身 isNaN( 值 )：任何不能被转换为数值的值都会导致这个函数返回true String类型 字符串字面量 字符串要用引号引起，单引号和双引号的作用是等效的 字符串是由一个个字符组成的，获取一个字符串的长度可以使用length属性 转义符 字符串的不可变—-&gt;其他类型重新赋值直接在内存上修改，字符串的修改要重新申请内存 ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变 要改变某个变量保存的字符串，需要重新开辟内存空间，然后修改变量的地址指向，之前的地址会被javascript垃圾回收机制不定时回收 如果两个字符串变量值相同，则指向相同的内存地址 123var a = \"hello\";var b = \"hello\";console.log(a === b); //true 把字符串当做数组看的话，修改字符串的某个字符（按下标访问），并不能够修改该字符串，说明字符串不可变 字符串类型是存储在堆内存中的 字符串拼接，字符串变量相加会把变量的值连接起来 Boolean类型 false、true 区分大小写 虽然只有两个值，但是所有类型中都有有着两个值等价的值 其他类型转换为布尔值 Undefined类型 表示变量未赋值 只有一种值就是undefined undefined是Undefined类型的字面量 类型转换 目标：掌握三种类型的转换 转换成字符串类型 转换成数值类型 转换成布尔类型 转换成字符串类型 toString()方法——变量.toString() 变量.toString()，转换成字符串 数值类型的toString(进制数)—&gt;将数值类型转换成几进制数值字符串 null和undefined没有toString()方法 String()方法——String（变量）- 存在的意义：有些值没有toString()方法，这个时候可以用String()方法，比如undefined和null 字符串拼接—&gt; + 转换成数值类型 Number()：可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN 可以把true和false转换成 1和0 如果是空字符串，会转换成0 parseInt()：把字符串转换成整数 会忽略前面的空格，直到找到第一个字符串为止，还会将后面的非数字字符串去掉 “ 123abc”会转换成123， 如果第一个字符不是数字或者正负号，返回NaN “abc123”会转换成NaN “-123”会转换为-123-“+123”会转换为123 可以传递两个参数 要转换的字符串 第二个是要转换的数原先为几进制数，在2到36之间，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 parseFloat()：把字符串转换成浮点数 转换方式与parseInt一样 parseInt()和parseFloat()的区别 parseFloat()会解析第一个，遇到第二个或者非数字结束 parseFloat()不支持第二个参数，只能解析10进制数 parseFloat()如果解析的内容里只有整数，解析成整数 10.00会被解析成10 转换成布尔类型——Boolean（变量） Boolean()方法 流程控制语句会把后面的值隐式转换成布尔类型 “ ！ ”运算符 转换成为false的值：false、””、0、和NaN、null、undefined 隐式转换 转number +、-、*、/、%都会把变量转换成number类型 +号的隐式转换必须写在变量的前面：eg: +”a” 、 +”undefined”、+”NaN” 转string var a = 123; a = a + “”; 转boolean var a = 123; a = !a; 复杂数据类型ObjectFunction####","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript之基本介绍","date":"2015-03-05T13:23:08.000Z","path":"2015/03/05/JavaScript/javascript之基本介绍/","text":"javascript语言特点 javascript是一门弱类型、动态类型、解析型的脚本语言 弱类型：定义变量不需要指定变量类型 动态类型： 执行时才知道变量到底是什么类型 对象想要有属性或方法，直接 . 或者[“属性名”]就可以 解析型：一行一行解析，解析一行执行一行 脚本语言：不需要编译，直接运行时边解析边执行的语言 编译：一次性把代码转换成cpu可以看懂的语言，一行一行执行，执行速度快 解释：一行一行解析，解析一行执行一行，执行速度慢 javascript是一种客户端的脚本语言 浏览器的工作原理 浏览器基本组成 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的你请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。 渲染引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码，比如chrome的javascript解释器是V8。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5)定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 详细文章请移步 javascript组成部分 ECMAScript： javascript的语法规范 DOM： javascript操作网页上元素的API BOM： javascript操作浏览器部分功能的API javascript的使用方式 内嵌式（html页面编写javascript代码） 123&lt;script type=\"text/javascript\"&gt; // 你的javascript代码&lt;/script&gt; 外联式（在js文件中编写javascript代码，在html页面中引入js文件） src：引入文件的地址 type：引入的文件类型 写法一：type=”text/javascript” 写法二：language=”javascript” async：异步 交给浏览器去异步下载，不会阻塞程序的执行 js文件下载完就可以立马执行 sync：同步 只能一个任务一个任务的执行会阻塞程序的执行 defer： 等html文档加载并显示完之后才执行下载完的js代码 只有外部脚本才可以使用 1&lt;script src=\"/javascripts/application.js\" type=\"text/javascript\" charset=\"utf-8\" async defer&gt;&lt;/script&gt; 内联式（在html标签中编写javascript代码）1&lt;input type=\"buttom\" onclick=\"function()&#123;&#125;\"&gt; javascript注释注释的应用 - 一般用于解释某些复杂代码的逻辑，方便后期的维护与开发 - 用于对整个模块进行分割划分，方便于代码查找和维护 - 用于：模块、函数、复杂逻辑注释、文件注解、维护记录等 12345//单行注释/*多行注释*//** * 注解内容 */ 好了，现在你可以开始编写你的javascript代码了","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"Hello World","date":"2015-03-01T13:50:52.000Z","path":"2015/03/01/Hexo/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]